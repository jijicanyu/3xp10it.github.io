<!DOCTYPE html>
<html>


    <head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>漏洞战争-cve-2010-2553</title>
<meta name="description" content="A blog about programming and network security">

<link rel="profile" href="https://gmpg.org/xfn/11" />
<! -- link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bbbbootstrap.min.css"-- >
<link rel="stylesheet" href="/css/my_code.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" type="text/css" media="all" href="/css/style.css" />
<link rel="stylesheet" type="text/css" media="all" href="/css/jquery.mmenu.all.css" />
<link rel="stylesheet" href="/css/highlightjs.piperita.css">

<!-- Favicons generated at https://realfavicongenerator.net/ -->
<link rel="apple-touch-icon" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="shortcut icon" href="/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png">
<meta name="msapplication-config" content="/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">





</head>


    <body>

    <nav id="my-menu">
  <div>
    <p>quanyechavshuo</p>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <!--https://fontawesome.io/icons/ -->
    <br>
    <center>
    <font color="red" align="center"><i class="fa fa-link" aria-hidden="true"></i><a href="../../../../../bookmarks.html"><font color="red"> link</font></a></font>
    <br>
    <br>
    <font color="red" align="center"><i class="fa fa-key" aria-hidden="true"></i><a href="../../../../../book.html" target="_top"><font color="red"> book</font></a></font>
    <br>
    <br>
    <font color="red" align="center"><i class="fa fa-music" aria-hidden="true"></i><a href="../../../../../jquery-jplayer/index.html" target="_top"><font color="red"> music</font></a></font>
    <br>
    <br>
    <font color="red" align="center"><i class="fa fa-caret-square-o-right" aria-hidden="true"></i><a href="../../../../../mv.html" target="_top"><font color="red"> movie</font></a></font>
    </center>
    <p class="links">
  <a href="https://www.twitter.com/quanyechavshuo" target="_new"><i class="fa fa-twitter"></i></a>
  <a href="https://github.com/3xp10it" target="_new"><i class="fa fa-github-alt"></i></a>
  <a href="/feed.xml" target="_new"><i class="fa fa-rss"></i></a>
</p>

  </div>
</nav>
<div class="menu-button" href="#menu"><i class="fa fa-bars"></i></div>



    <div class="page-content">
      <div class="wrap">
      

<div class="container-fluid single">
  <div class="row">

    <div itemscope itemtype="https://schema.org/Article" class="col-md-12 article">
      

      <h1 class="header" itemprop="name">漏洞战争-cve-2010-2553</h1>

      <div class="author">
        <small><i>
          
          on <span itemprop="datePublished" content="2014-08-28">August 17, 2016</span>
           under 二进制
        </i></small>
      </div>

      <div class="read-time">
        <small>
          12 minute read
        </small>
      </div>

      <div class="content-panel content">

        

        <span itemprop="articleBody"><h3 id="x00-">0x00 堆溢出基础知识</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>1&gt;good link:
    http://blog.csdn.net/ithzhang/article/details/12711431
    http://www.mottoin.com/87277.html
    http://www.voidcn.com/blog/u010797814/article/p-3924286.html

2&gt;堆表只索引所有的空闲态堆块,已分配|占用的堆块由使用它的程序索引,空闲态堆块和占用态堆块:

    堆块使用_HEAP_ENTYR结构来描述,该结构占8Byte. _HEAP_ENTRY结构之后就是供应用程序使用的区域.调用HeapAlloc函数
    将返回HEAP_ENTRY之后的地址.此地址减去8Byte便可以得到_HEAP_ENTRY结构.对于已经释放的堆块,堆管理器定义了
    _HEAP_FREE_ENTRY结构来描述.该结构的前八个字节与_HEAP_ENTRY结构完全相同.但增加了8个字节来存储空闲链表的头节点.
    _HEAP_FREE_ENTRY是空闲态堆块中的块首(8byte)与flink,blink(4+4=8)的总和,_HEAP_FREE_ENTRY共16byte,_HEAP_ENTRY
    是占用态堆块中对应的块首的结构,大小为8byte.
    如下图:
</code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/3xp10it/pic/master/heap-1.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>3&gt;堆溢出实质:
    [flink+4]=blink
    [blink]=flink

    其中flink代表下一个堆块的索引,blink代表前一个堆块的索引

4&gt;调试堆与调试栈不同,不能直接用调试器来加载程序,否则堆管理函数会检测到当前进程处于调试状态,而使用调试态堆管理
  策略
</code></pre>
</div>

<h3 id="x01-">0x01 堆溢出原理</h3>

<h4 id="day2">1&gt;0day2实例</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>-----------------0dayheap.c-(page:152)--------
#include &lt;windows.h&gt;
int main()
{
    HLOCAL h1,h2,h3,h4,h5,h6;
    HANDLE hp;
    getchar();//将书中下面的__asm int 3改成这里的getchar(),因为实际中将od设为实时调试提示有问题
    hp=HeapCreate(0,0x1000,0x10000);//创建一个0x1000=4096大小的堆
    //__asm int 3,书中是__asm int 3,在winxp sp3上测试中断效果还好,改成上面的getchar()

    h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
    h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
    h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
    h4=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);
    h5=HeapAlloc(hp,HEAP_ZERO_MEMORY,19);
    h6=HeapAlloc(hp,HEAP_ZERO_MEMORY,24);

    //free block and prevent coaleses
    HeapFree(hp,0,h1);//free to freelist[2]
    HeapFree(hp,0,h3);//free to freelist[2]
    HeapFree(hp,0,h5);//free to freelist[4]

    HeapFree(hp,0,h4);//coalese h3,h4,h5,link the large block to freelist[8]

    return 0;
}
--------------------end-----------------------

编译成release版本exe
双击运行0dayheap.exe
od附加
f9
alt+e选择0dayheap.exe
在00401018的call HeapCreate处下断

    00401018    FF15 08604000   call dword ptr ds:[&lt;&amp;KERNEL32.HeapCreate&gt;; kernel32.HeapCreate
    0040101E    8B3D 04604000   mov edi,dword ptr ds:[&lt;&amp;KERNEL32.HeapAll&gt;; ntdll.RtlAllocateHeap
    
在0dayheap.exe的窗口中输入"a",enter
发现od没有成功中断,可能是od的原因
alt+v
t
resume all threads
中断在401018处
f8
    此时eax=3a0000,也即heapcreate创建的堆的起始地址为3a0000
在寄存器窗口中右键eax,在数据窗口中跟随

    003A0000  C8 00 00 00 7A 01 00 00 FF EE FF EE 00 10 00 00  ?..z..??..
    003A0010  00 00 00 00 00 FE 00 00 00 00 10 00 00 20 00 00  .....?..... ..
    003A0020  00 02 00 00 00 20 00 00 30 01 00 00 FF EF FD 7F  .... ..0..稞
    003A0030  05 00 08 06 00 00 00 00 00 00 00 00 00 00 00 00  .............
    003A0040  00 00 00 00 98 05 3A 00 0F 00 00 00 F8 FF FF FF  ....?:....?
    003A0050  50 00 3A 00 50 00 3A 00 40 06 3A 00 00 00 00 00  P.:.P.:.@:.....
    003A0060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    003A0070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

alt+m也可以查看堆的起始地址,如下图
</code></pre>
</div>

<p><img src="https://raw.githubusercontent.com/3xp10it/pic/master/heap-2.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>在003a000那一行上右键复制一行,粘贴如下:
    Memory map, 条目 15
     地址=003A0000
     大小=00001000 (4096.)
     属主=         003A0000 (自身)
     区段=
     类型=Priv 00021004
     访问=RW
     初始访问=RW

在数据窗口中的003a0000的0x178偏移也即3a0178,是空表索引,也即3a0178指向freelist,3a0178处的值为freelist的第一项内容,如下:
    
    003A0170  00 00 00 00 00 00 00 00      88 06 3A 00 88 06 3A 00  ........?:.?:.

    free[0]=0x003a0178
    free[0].flink=[3a0178]=003a0688
    free[0].blink=[3a0178+4]=003a0688

003a0688处的数据窗口值如下:

    003A0688  78 01 3A 00 78 01 3A 00 00 00 00 00 00 00 00 00  x:.x:.........
    003A0698  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

    free[-1]=0x003a0688
    free[-1].flink=[3a0688]=003a0178    ====free[0]
    free[-1].blink=[3a0688+4]=003a0178
    
    可以看出HeapCreate产生的堆中的空表只有两项,也即只有一个堆块,且堆块索引为free[-1]+8=0x003a0690
    h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,3);//实际分配16字节(2个堆块大小),预测h1=0x3a0690
    h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,5);//实际分配16字节(2个堆块大小),预测h2=0x3a0690+16=0x3a06a0
    h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,6);//实际分配16字节(2个堆块大小),预测h3=0x3a0690+16*2=0x3a06b0
    h4=HeapAlloc(hp,HEAP_ZERO_MEMORY,8);//实际分配16字节(2个堆块大小),预测h4=0x3a0690+16*3=0x3a06c0
    h5=HeapAlloc(hp,HEAP_ZERO_MEMORY,19);//实际分配32字节(4个堆块大小),预测h5=0x3a0690+16*4=0x3a06d0
    h6=HeapAlloc(hp,HEAP_ZERO_MEMORY,24);//实际分配32字节(4个堆块大小),预测h6=0x3a0690+16*4+32=0x3a06f0
    h1-h6共分配128个字节,128/8=16个堆单元

在六处HeapAlloc上下断

    00401018    FF15 08604000   call dword ptr ds:[&lt;&amp;KERNEL32.HeapCreate&gt;]          ; kernel32.HeapCreate
    0040101E    8B3D 04604000   mov edi,dword ptr ds:[&lt;&amp;KERNEL32.HeapAlloc&gt;]        ; ntdll.RtlAllocateHeap
    00401024    8BF0            mov esi,eax
    00401026    6A 03           push 0x3
    00401028    6A 08           push 0x8
    0040102A    56              push esi
    0040102B    FFD7            call edi     --------&gt;f2
    0040102D    6A 05           push 0x5
    0040102F    6A 08           push 0x8
    00401031    56              push esi
    00401032    8BD8            mov ebx,eax
    00401034    FFD7            call edi     --------&gt;f2
    00401036    6A 06           push 0x6
    00401038    6A 08           push 0x8
    0040103A    56              push esi
    0040103B    FFD7            call edi     --------&gt;f2
    0040103D    6A 08           push 0x8
    0040103F    6A 08           push 0x8
    00401041    56              push esi
    00401042    8BE8            mov ebp,eax
    00401044    FFD7            call edi     --------&gt;f2
    00401046    6A 13           push 0x13
    00401048    6A 08           push 0x8
    0040104A    56              push esi
    0040104B    894424 20       mov dword ptr ss:[esp+0x20],eax
    0040104F    FFD7            call edi     --------&gt;f2
    00401051    6A 18           push 0x18
    00401053    6A 08           push 0x8
    00401055    56              push esi
    00401056    894424 1C       mov dword ptr ss:[esp+0x1C],eax
    0040105A    FFD7            call edi     --------&gt;f2

f8
f8
..
(eip=0x40102d)
    到40102d处eax=0x3a0688,也即h1=0x3a0688,说明预测错了,因为分配上面唯一的堆块(free[-1]=003a0688)分配以后就不
    再是空闲堆块了,变成占用态的堆块,占用态的堆块是没有flink和blik的,也即占用态的堆块的索引不属于空表中,属于
    应用程序.上面唯一的堆块分割以后的堆块是在0x3a0688处割下16个字节(h1的大小)后剩下的唯一的堆块
    现在0x3a688处的数据如下:
        
    003A0688  00 00 00 00 78 01 3A 00 2E 01 02 00 00 10 00 00  ....x:......
    003A0698  78 01 3A 00 78 01 3A 00 00 00 00 00 00 00 00 00  x:.x:.........

    重新预测:
    h1=003a0688
        h1堆块的块首在h1-8=3a0680处:
        003A0680:
        02 00 08 00 AA 01 0D 00          ..?..
        块首的前2个字节对应当前堆块的大小(堆块的个数,每个堆块单位为8字节大小),第3-4个字节对应前一个堆块大小,这
        里前2个字节为0002,也即当前堆块大小为2个堆块,第3-4字节为0008,即前一个堆块大小为8个堆块
    h2=003a0698
    h3=003a06a8
    h4=003a06b8
    h5=003a06c8
    h6=003a06e8

f8
f8
...
(eip=00401036)
    到00401036处eax=3a0698,也即h2=0x3a0698与预测结果一致,h2堆块的块首在h2-8=3a0690处:
    003a0690:
    02 00 02 00 A8 01 0B 00          ..?.
    前2个字节为0002,也即当前堆块大小为2,3-4个字节为0002,也即前一个堆块大小为2
    此时(h1,h2分配完成,h3还未分配)对应的空闲堆块索引(free[-1])为h2+8+8=003a06a0+8=003a06a8,其中003a06a0为空闲
    堆块块首的地址,空闲堆块的索引为块首+8处,具体如下:

    003A0698  00 00 00 00 00 01 3A 00 2C 01 02 00 00 10 00 00  .....:.,....
    003A06A8  78 01 3A 00 78 01 3A 00 00 00 00 00 00 00 00 00  x:.x:.........
    003A06B8  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    也即空闲堆块的块首为2c 01 02 00 00 10 00 00==&gt;当前空闲堆块大小为012c,前一个堆块大小为2
    此时的free[-1]=3a06a8,free[-1].flink=[3a06a8]=free[-1].blink=[3a06b0]=003a0178,依然为free[0]

f8
f8
...
(eip=0040103D)
    到0040103D处eax=3a06a8,也即h3=0x3a06a8与预测结果一致,h3堆块的块首在h3-8=3a06a0处:
    003A06A0  02 00 02 00 AE 01 0A 00 00 00 00 00 00 00 3A 00  ..?........:.
    前2个字节为0002,也即当前堆块的大小为2,3-4个字节为0002,也即前一个堆块大小为2
    此时(h1,h2,h3分配完成,h4还没分配)对应的空闲堆块索引(free[-1])为h3+8+8=3a06b0+8=3a06b8,其中003a06b0为空闲堆
    块块首的地址,空闲堆块的索引为块首+8处,具体如下:
    003A06B0  2A 01 02 00 00 10 00 00 78 01 3A 00 78 01 3A 00  *....x:.x:.
    当前空闲堆块大小为012c-2=012a,前一个堆块大小为2
    同样是free[-1].flink=free[-1].blink=003a0178=free[0]

f8
f8
...
(eip=00401046)
    到00401046处eax=3a06b8,也即h4=0x3a06b8与预测结果一致,h4堆块的块首在h4-8=30a6b0处:
    003A06B0  02 00 02 00 AC 01 08 00 00 00 00 00 00 00 00 00  ..?.........
    当前堆块大小为2,前一个堆块大小为2
    h4分配完,h5还没分配,空闲堆块索引(free[-1])为h4+8+8=30a6c0+8=30a6c8
    数据如下:
    003A06C0  28 01 02 00 00 10 00 00 78 01 3A 00 78 01 3A 00  (....x:.x:.
    当前空闲堆块的大小为012a-2=0128,前一个堆块大小为2
    同样是free[-1].flink=free[-1].blink=003a0178=free[0]

f8
f8
...
(eip=00401051)
    到00401051处eax=3a06c8,也即h5=0x3a06c8与预测结果一致,h5堆块的块首在h5-8=3a06c0处:
    003A06C0  04 00 02 00 A2 01 0D 00 00 00 00 00 00 00 00 00  ..?..........
    当前堆块的大小为4,前一个堆块大小为2

f8
f8
...
(eip=0040105c)
    到0040105c处eax=3a06e8,也即h6=0x3a06e8与预测结果一致,h6堆块的块首在h6-8=3a06e0处:
    003A06E0  04 00 04 00 A6 01 08 00 00 00 00 00 00 00 00 00  ..?.........
    当前堆块大小为4,前一堆块大小为4
    h6分配完,空闲堆块索引(free[-1])为h6+8*3+8=3a0700+8=3a0708
    数据如下:
    003A0700  20 01 04 00 00 10 00 00 78 01 3A 00 78 01 3A 00   ....x:.x:.
    当前空闲堆块的大小为0128-4-4=0120,前一个堆块大小为4
    同样是free[-1].flink=free[-1].blink=003a0178=free[0]


在下面的3个堆块释放(call heapfree,释放h1,h3,h5,h4)的函数下断

    0040105C    8B3D 00604000   mov edi,dword ptr ds:[&lt;&amp;KERNEL32.HeapFree&gt;]         ; ntdll.RtlFreeHeap
    00401062    53              push ebx
    00401063    6A 00           push 0x0
    00401065    56              push esi
f2  00401066    FFD7            call edi                                            ; ntdll.RtlAllocateHeap
    00401068    55              push ebp
    00401069    6A 00           push 0x0
    0040106B    56              push esi
f2  0040106C    FFD7            call edi                                            ; ntdll.RtlAllocateHeap
    0040106E    8B4424 10       mov eax,dword ptr ss:[esp+0x10]
    00401072    50              push eax
    00401073    6A 00           push 0x0
    00401075    56              push esi
f2  00401076    FFD7            call edi                                            ; ntdll.RtlAllocateHeap
    00401078    8B4C24 14       mov ecx,dword ptr ss:[esp+0x14]
    0040107C    51              push ecx                                            ; ntdll.7C9301BB
    0040107D    6A 00           push 0x0
    0040107F    56              push esi
    00401080    FFD7            call edi                                            ; ntdll.RtlAllocateHeap
    00401082    5F              pop edi                                             ; 00320036
    00401083    5E              pop esi                                             ; 00320036
    00401084    5D              pop ebp                                             ; 00320036
    00401085    33C0            xor eax,eax
    00401087    5B              pop ebx                                             ; 00320036
    00401088    83C4 08         add esp,0x8
    0040108B    C3              retn

f8
f8
...
(eip=401068)
    到401068处,h1堆块被释放,由于h1实际分配大小为2个堆单元大小(2*8=16字节),释放后将链入free[2]这个空闲链表中
    ,在h1释放之前只有free[0]这一个空闲链表,h1释放后会增加一个空闲链表free[2],此时free[2]这个空表只有一个结点,此
    时free[0]附近数据:

    eip=40105c时,也即上面释放h1之前,free[0]=3a0178,附近的数据如下:

    003A0170  00 00 00 00 00 00 00 00 08 07 3A 00 08 07 3A 00  ........:.:.
    003A0180  80 01 3A 00 80 01 3A 00 88 01 3A 00 88 01 3A 00  €:.€:.?:.?:.
    003A0190  90 01 3A 00 90 01 3A 00 98 01 3A 00 98 01 3A 00  ?:.?:.?:.?:.
    003A01A0  A0 01 3A 00 A0 01 3A 00 A8 01 3A 00 A8 01 3A 00  ?:.?:.?:.?:.
    003A01B0  B0 01 3A 00 B0 01 3A 00 B8 01 3A 00 B8 01 3A 00  ?:.?:.?:.?:.
    003A01C0  C0 01 3A 00 C0 01 3A 00 C8 01 3A 00 C8 01 3A 00  ?:.?:.?:.?:.
    003A01D0  D0 01 3A 00 D0 01 3A 00 D8 01 3A 00 D8 01 3A 00  ?:.?:.?:.?:.
    003A01E0  E0 01 3A 00 E0 01 3A 00 E8 01 3A 00 E8 01 3A 00  ?:.?:.?:.?:.
    003A01F0  F0 01 3A 00 F0 01 3A 00 F8 01 3A 00 F8 01 3A 00  ?:.?:.?:.?:.
    
    现在,eip=401068时,刚释放完h1,free[0]=3a0178,附近数据如下:

    003A0170  00 00 00 00 00 00 00 00 08 07 3A 00 08 07 3A 00  ........:.:.
    003A0180  80 01 3A 00 80 01 3A 00(88 06 3A 00 88 06 3A 00) €:.€:.?:.?:.
    003A0190  90 01 3A 00 90 01 3A 00 98 01 3A 00 98 01 3A 00  ?:.?:.?:.?:.
    003A01A0  A0 01 3A 00 A0 01 3A 00 A8 01 3A 00 A8 01 3A 00  ?:.?:.?:.?:.
    003A01B0  B0 01 3A 00 B0 01 3A 00 B8 01 3A 00 B8 01 3A 00  ?:.?:.?:.?:.
    003A01C0  C0 01 3A 00 C0 01 3A 00 C8 01 3A 00 C8 01 3A 00  ?:.?:.?:.?:.
    003A01D0  D0 01 3A 00 D0 01 3A 00 D8 01 3A 00 D8 01 3A 00  ?:.?:.?:.?:.
    003A01E0  E0 01 3A 00 E0 01 3A 00 E8 01 3A 00 E8 01 3A 00  ?:.?:.?:.?:.
    003A01F0  F0 01 3A 00 F0 01 3A 00 F8 01 3A 00 F8 01 3A 00  ?:.?:.?:.?:.
    
    不同之处是3a0188和3a018c处的003a0188变成了003a0688,而003a0688正是h1的值,而h1释放后将链入free[2]的空表,说明
    3a0188正是free[2]这个位置,那么3a0180就是free[1]的位置,也即从+0x178开始,有128个元素,每个8字节大小,这
    128个元素构成一个指针数组,这个数组叫做"空表索引",这个数组的每一项包括两个指针,指针代表对应空表的第一个空
    闲堆块的内存地址.

f8
f8
...
(eip=40106e)
    到这里h3释放完,由于h3也是两个堆块单元大小,所以h3也将链入到free[2]的空表当中
    可以预测:
    free[2]处的003a0688(free[2]的第一个空闲堆块的索引)对应的内存值[003a0688]=h3=003a06a8,而
    [003a0688+4]=free[2]=3a0188,而[003a06a8]=free[2]=003a0188,[003a06a8+4]=003a0688,free[2]为3a0188,h3释放后
    [3a0188]=3a0688,[3a0188+4]=3a06a8

    实际确实如此,实际数据如下:

    003A0680  02 00 08 00 AA 00 0D 00 A8 06 3A 00 88 01 3A 00  ..?..?:.?:.

    003A06A0  02 00 02 00 AE 00 0A 00 88 01 3A 00 88 06 3A 00  ..?..?:.?:.

    003A0180  80 01 3A 00 80 01 3A 00 88 06 3A 00 A8 06 3A 00  €:.€:.?:.?:.

    如下图:
</code></pre>
</div>
<p><img src="https://raw.githubusercontent.com/3xp10it/pic/master/heap-3.png" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>f8
f8
...
(eip=401078)
    到这里h5释放完,由于h5实际分配大小为4个堆块单元大小,h5堆块释放后将链入free[4]空表中,free[4]=3a0198
    可以预测:
    [3a0198]=h5=003a06c8,[3a0198+4]=h5=003a06c8
    [003a06c8]=3a0198,[003a06c8+4]=3a0198
    
    实际数据如下:

    003A0190  90 01 3A 00 90 01 3A 00 C8 06 3A 00 C8 06 3A 00  ?:.?:.?:.?:.

    003A06C0  04 00 02 00 A2 00 0D 00 98 01 3A 00 98 01 3A 00  ..?..?:.?:.
    与预测结果一致

f8
f8
...
(eip=401082)
    到这里h4释放完,由于h4实际分配大小为2个堆块单元大小,h4堆块释放后将链入free[2]空表中,free[2]=3a0188
    可以预测:
    [free[2]]=[3a0188]=h1=3a0688,[3a0188+4]=h4=3a06b8
    [h1]=[3a0688]=h3=3a06a8,[3a0688+4]=free[2]=3a0188
    [h3]=[3a06a8]=h4=3a06b8,[3a06a8+4]=h1=3a0688
    [h4]=[3a06b8]=3a0188,[3a06b8+4]=h3=3a06a8

    实际数据如下:

    003A06B0  02 00 02 00 AC 01 08 00 00 00 00 00 00 00 00 00  ..?.........

    003A0180  80 01 3A 00 80 01 3A 00 88 06 3A 00 88 06 3A 00  €:.€:.?:.?:.

    003A0680  02 00 08 00 AA 00 0D 00 88 01 3A 00 88 01 3A 00  ..?..?:.?:.

    003A06A0  08 00 02 00 AE 00 0A 00 B8 01 3A 00 B8 01 3A 00  ..?..?:.?:.

    与实际数据并不一致,因为h4释放完后,h3,h4,h5三个空闲堆块相邻,会发生合并,3个堆块大小一共为2+2+4=8个堆单元大小,
    合并后将链入free[8]空表中(free[8]是128个空表中的第9个空表的索引,也即0x3a0000+0x178+8*8=0x3a01b8)
    ,预测:
    [free[8]]=[3a01b8]=h3=3a06a8(h3,h4,h5合并后由h3索引)
    [free[2]]=[3a0188]=h1=3a0688(2个堆块单元大小的空闲堆只剩下h1,原来是h1,h3,h4)
    [h1]=[3a0688]=free[2]=3a0188,[h1+4]=[3a0688+4]=free[2]=3a0188
    [h3]=[3a06a8]=free[8]=3a01b8,[h3+4]=[3a06a8+4]=free[8]=3a01b8

    实际数据如下:

    003A01B0  B0 01 3A 00 B0 01 3A 00 A8 06 3A 00 A8 06 3A 00  ?:.?:.?:.?:.

    003A0180  80 01 3A 00 80 01 3A 00 88 06 3A 00 88 06 3A 00  €:.€:.?:.?:.

    003A0680  02 00 08 00 AA 00 0D 00 88 01 3A 00 88 01 3A 00  ..?..?:.?:.

    003A06A0  08 00 02 00 AE 00 0A 00 B8 01 3A 00 B8 01 3A 00  ..?..?:.?:.

    可见,实际数据与预测结果完全一样,此时[free[0]]=[0x3a0178]=3a0708(一直不变),3a0708处数据如下:
    003A0700  20 01 04 00 00 10 00 00 78 01 3A 00 78 01 3A 00   ....x:.x:.
    可见当前堆块大小为0x120(个堆块单元大小),上一个堆块大小为4?
    并不是这样,因为0x178偏移处并不是堆块,而是大小为128的指针数组中的第一个数组的位置,所以0x178-8并不是块首
    ,偏移0x178是free[0],也即free[0]=0x3a0178,而偏移0x178中存放的内容也即[free[0]]为这个指针数组中的第一个元素
    的值,这个值是个指针,指向free[0]空表中的第一个堆块,此例中free[0]空表只有一个堆块,堆块的索引为3a0708,也即:
    [free[0]]=[3a0178]=3a0708,且[free[0]+4]=[3a0178+4]=3a0708
    而[3a0708]=[3a0708+4]=3a0178

使用堆的三种方法:
    a&gt;GetProcessHeap获得进程默认堆句柄,HeapAlloc(进程默认句柄)可以从默认堆上分配空间
    b&gt;形如HeapCreate(0,0x1000,0x10000)创建不可扩展堆,堆将启用空表,HeapAlloc从堆上分配空间
    c&gt;形如HeapCreate(0,0,0)创建可扩展堆,堆将启用快表,HeapAlloc从堆上分配空间

    在此例中,由于在创建堆时使用的方法是HeapCreate(0,0x1000,0x10000),如果使用的方法是HeapCreate(0,0,0)将创建可
    扩展的堆,这时堆会启用快表,指向快表的指针位于堆偏移??字节处,0day2书中同时指出快表位于0x584和0x688偏移处,通
    过下面代码的调试查看快表的偏移在哪里:

    -----------find-lookaside---------------
    #include &lt;windows.h&gt;
    int main()
    {
    	HANDLE hp;
    	HLOCAL h1,h2,h3;
    	hp=HeapCreate(0,0,0);
    	h1=HeapAlloc(hp,HEAP_ZERO_MEMORY,3);
    	h2=HeapAlloc(hp,HEAP_ZERO_MEMORY,5);
    	h3=HeapAlloc(hp,HEAP_ZERO_MEMORY,6);
    	getchar();
    	HeapFree(hp,0,h1);
    	HeapFree(hp,0,h1);
    	HeapFree(hp,0,h1);
    
    	return 0;
    
    }
    ------------------end-------------------
    编译成release版本后,运行exe,windbg加载
    dt _PEB @$peb查看进程环境块信息

    0:001&gt; dt _PEB @$peb
    ntdll!_PEB
       +0x000 InheritedAddressSpace : 0 ''
       +0x001 ReadImageFileExecOptions : 0 ''
       +0x002 BeingDebugged    : 0x1 ''
       +0x003 SpareBool        : 0 ''
       +0x004 Mutant           : 0xffffffff 
       +0x008 ImageBaseAddress : 0x00400000 
       +0x00c Ldr              : 0x00241e90 _PEB_LDR_DATA
       +0x010 ProcessParameters : 0x00020000 _RTL_USER_PROCESS_PARAMETERS
       +0x014 SubSystemData    : (null) 
       +0x018 ProcessHeap      : 0x00140000     ===&gt;进程启动创建的默认堆
       +0x01c FastPebLock      : 0x7c99d600 _RTL_CRITICAL_SECTION
       +0x020 FastPebLockRoutine : 0x7c921000 
       +0x024 FastPebUnlockRoutine : 0x7c9210e0 
       +0x028 EnvironmentUpdateCount : 1
       +0x02c KernelCallbackTable : (null) 
       +0x030 SystemReserved   : [1] 0
       +0x034 AtlThunkSListPtr32 : 0
       +0x038 FreeList         : (null) 
       +0x03c TlsExpansionCounter : 0
       +0x040 TlsBitmap        : 0x7c99d5c0 
       +0x044 TlsBitmapBits    : [2] 1
       +0x04c ReadOnlySharedMemoryBase : 0x7f6f0000 
       +0x050 ReadOnlySharedMemoryHeap : 0x7f6f0000 
       +0x054 ReadOnlyStaticServerData : 0x7f6f0688  -&gt; (null) 
       +0x058 AnsiCodePageData : 0x7ffa0000 
       +0x05c OemCodePageData  : 0x7ffa0000 
       +0x060 UnicodeCaseTableData : 0x7ffd1000 
       +0x064 NumberOfProcessors : 1
       +0x068 NtGlobalFlag     : 0
       +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000
       +0x078 HeapSegmentReserve : 0x100000
       +0x07c HeapSegmentCommit : 0x2000
       +0x080 HeapDeCommitTotalFreeThreshold : 0x10000
       +0x084 HeapDeCommitFreeBlockThreshold : 0x1000
       +0x088 NumberOfHeaps    : 5            ===&gt;进程中共有5个堆
       +0x08c MaximumNumberOfHeaps : 0x10
       +0x090 ProcessHeaps     : 0x7c99cfc0  -&gt; 0x00140000    ===&gt;进程堆指针数据
       +0x094 GdiSharedHandleTable : (null) 
       +0x098 ProcessStarterHelper : (null) 
       +0x09c GdiDCAttributeList : 0
       +0x0a0 LoaderLock       : 0x7c99b178 
       +0x0a4 OSMajorVersion   : 5
       +0x0a8 OSMinorVersion   : 1
       +0x0ac OSBuildNumber    : 0xa28
       +0x0ae OSCSDVersion     : 0x300
       +0x0b0 OSPlatformId     : 2
       +0x0b4 ImageSubsystem   : 3
       +0x0b8 ImageSubsystemMajorVersion : 4
       +0x0bc ImageSubsystemMinorVersion : 0
       +0x0c0 ImageProcessAffinityMask : 0
       +0x0c4 GdiHandleBuffer  : [34] 0
       +0x14c PostProcessInitRoutine : (null) 
       +0x150 TlsExpansionBitmap : 0x7c99d5b8 
       +0x154 TlsExpansionBitmapBits : [32] 0
       +0x1d4 SessionId        : 0
       +0x1d8 AppCompatFlags   : _ULARGE_INTEGER 0x0
       +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0
       +0x1e8 pShimData        : (null) 
       +0x1ec AppCompatInfo    : (null) 
       +0x1f0 CSDVersion       : _UNICODE_STRING "Service Pack 3"
       +0x1f8 ActivationContextData : (null) 
       +0x1fc ProcessAssemblyStorageMap : (null) 
       +0x200 SystemDefaultActivationContextData : 0x00130000 
       +0x204 SystemAssemblyStorageMap : (null) 
       +0x208 MinimumStackCommit : 0

    +0x018和+0x088处分别为进程默认堆和进程中堆的个数
    +0x090处为进程中所有堆的地址组成的指针数组

    dd 0x7c99cfc0查看进程堆数组
    0:001&gt; dd 0x7c99cfc0
    7c99cfc0  00140000 00240000 00250000 00380000
    7c99cfd0  003a0000 00000000 00000000 00000000
    7c99cfe0  00000000 00000000 00000000 00000000
    7c99cff0  00000000 00000000 00000000 00000000

    或者!heap -h查看所有堆的地址
    0:001&gt; !heap -h
    Index   Address  Name      Debugging options enabled
      1:   00140000 
        Segment at 00140000 to 00240000 (00004000 bytes committed)
      2:   00240000 
        Segment at 00240000 to 00250000 (00006000 bytes committed)
      3:   00250000 
        Segment at 00250000 to 00260000 (00003000 bytes committed)
      4:   00380000 
        Segment at 00380000 to 00390000 (00002000 bytes committed)
      5:   003a0000 
        Segment at 003a0000 to 003e0000 (00003000 bytes committed)

    两种方法得到的结果一样,其中最后一个堆的地址0x003a0000是代码中HeapCreate(0,0,0)创建得到的堆地址

    dt _HEAP 0x3a0000查看这个堆的结构
    0:001&gt; dt _HEAP 0x3a0000
    ntdll!_HEAP
       +0x000 Entry            : _HEAP_ENTRY
       +0x008 Signature        : 0xeeffeeff
       +0x00c Flags            : 0x1002
       +0x010 ForceFlags       : 0
       +0x014 VirtualMemoryThreshold : 0xfe00
       +0x018 SegmentReserve   : 0x100000
       +0x01c SegmentCommit    : 0x2000
       +0x020 DeCommitFreeBlockThreshold : 0x200
       +0x024 DeCommitTotalFreeThreshold : 0x2000
       +0x028 TotalFreeSize    : 0x229
       +0x02c MaximumAllocationSize : 0x7ffdefff
       +0x030 ProcessHeapsListIndex : 5
       +0x032 HeaderValidateLength : 0x608
       +0x034 HeaderValidateCopy : (null) 
       +0x038 NextAvailableTagIndex : 0
       +0x03a MaximumTagIndex  : 0
       +0x03c TagEntries       : (null) 
       +0x040 UCRSegments      : (null) 
       +0x044 UnusedUnCommittedRanges : 0x003a0598 _HEAP_UNCOMMMTTED_RANGE
       +0x048 AlignRound       : 0xf
       +0x04c AlignMask        : 0xfffffff8
       +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x3a0050 - 0x3a0050 ]
       +0x058 Segments         : [64] 0x003a0640 _HEAP_SEGMENT
       +0x158 u                : __unnamed
       +0x168 u2               : __unnamed
       +0x16a AllocatorBackTraceIndex : 0
       +0x16c NonDedicatedListLength : 1
       +0x170 LargeBlocksIndex : (null) 
       +0x174 PseudoTagEntries : (null) 
       +0x178 FreeLists        : [128] _LIST_ENTRY [ 0x3a1ec0 - 0x3a1ec0 ]
       +0x578 LockVariable     : 0x003a0608 _HEAP_LOCK
       +0x57c CommitRoutine    : (null) 
       +0x580 FrontEndHeap     : 0x003a0688 
       +0x584 FrontHeapLockCount : 0
       +0x586 FrontEndHeapType : 0x1 ''
       +0x587 LastSegmentIndex : 0 ''

    可以在0x178偏移处找到free[0](0号空表)

    dt _LIST_ENTRY 0x3a0178
    ntdll!_LIST_ENTRY
     [ 0x3a1ec0 - 0x3a1ec0 ]
       +0x000 Flink            : 0x003a1ec0 _LIST_ENTRY [ 0x3a0178 - 0x3a0178 ]
       +0x004 Blink            : 0x003a1ec0 _LIST_ENTRY [ 0x3a0178 - 0x3a0178 ]

    dd 0x3a0688
    0:001&gt; dd 0x3a0688
    003a0688  00000000 00000000 01000004 00000000
    003a0698  00000000 00000000 00000000 00000000
    003a06a8  00000000 00000003 00000000 00000000
    003a06b8  00000000 00000000 01000004 00000000

    0x3a0000堆中能找到0号空表但是却找不到快表,0day2中说的0x688和0x584偏移处并不是快表的所在,关于快表的所在和出
    现条件,暂惑不得解
</code></pre>
</div>

<h4 id="section">2&gt;漏洞战争实例</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>------------------heapoverflow.c---------------------
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    HANDLE hHeap;
    char *heap;
    char str[]="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    hHeap=HeapCreate(HEAP_GENERATE_EXCEPTIONS,0x1000,0xffff);
    getchar();

    heap=HeapAlloc(hHeap,0,0x10);
    printf("heap addr:0x%08x\n",heap);

    strcpy(heap,str);
    HeapFree(hHeap,0,heap);

    HeapDestroy(hHeap);
    return 0;
}
------------------------end--------------------------
</code></pre>
</div>
</span>

        


        
        <div class="tags">
          <small>
          <i class="fa fa-tags"></i>
            漏洞战争, 漏洞分析, 堆溢出
          </small>
        </div>
        

      </div>

      
      <div class="content-panel feedback">
        I <i class="fa fa-heart"></i> feedback.<br />
        Let me know what you think of this article on twitter <a href="https://www.twitter.com/quanyechavshuo">@quanyechavshuo</a>!
      </div>
      


      



      
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/08/17/漏洞战争-cve-2010-2553" data-title="" data-url="https://3xp10it.github.io//%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/08/17/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-2553/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"3xp10it"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
      


      

    </div>

  </div>

</div>





      </div>
    </div>

    <div class="footer clearfix">
  <div class="col-md-12">
    for better experience please install font 文泉驿等宽正黑
  </div>
</div>

<div class="my-home"><i class="fa fa-home" aria-hidden="true"></i><a href="/index2.html"> <font color="white">home</font></a></div>
<div class="my-papers"><i class="fa fa-github" aria-hidden="true"></i><a href="https://github.com/3xp10it" target="_top"> <font color="white">papers</font></a></div>
<div class="my-search"><i class="fa fa-search" aria-hidden="true"></i><a href="/search/"> <font color="white">search</font></a></div>
<div class="my-archive"><i class="fa fa-apple" aria-hidden="true"></i><a href="/my-archive/"> <font color="white">archive</font></a></div>
<div class="my-categories"><i class="fa fa-tags" aria-hidden="true"></i><a href="/my-categories/"> <font color="white">categories</font></a></div>


<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
<script src="/js/jquery.mmenu.min.all.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.7/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
   $(document).ready(function() {
      $("#my-menu").mmenu().on( "closed.mm", function() {
            $(".menu-button").show();
         });
      $(".menu-button").click(function() {
        $(".menu-button").hide();
        $("#my-menu").trigger("open.mm");
      });
   });
</script>






    </body>
</html>
